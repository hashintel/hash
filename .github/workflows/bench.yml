name: Bench

on:
  pull_request:
  push:
    branches:
      - main

env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: hashintel
  TURBO_REMOTE_ONLY: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  setup:
    runs-on: ubuntu-22.04
    outputs:
      unit: ${{ steps.packages.outputs.unit }}
      integration: ${{ steps.packages.outputs.integration }}
      dockers: ${{ steps.packages.outputs.dockers }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4
        with:
          fetch-depth: 2

      - name: Install turbo
        uses: ./.github/actions/install-turbo

      - name: Determine changed packages
        id: packages
        run: |
          UNIT_BENCH_FILTER=$(turbo run bench:unit --dry-run=json --filter '...[HEAD^]' | jq -e '.packages | contains(["//"])' > /dev/null && echo '' || echo '--filter ...[HEAD^]')
          UNIT_BENCH_TASKS=$(sh -c "turbo run bench:unit --dry-run=json $UNIT_BENCH_FILTER" | jq -c '.tasks[]')
          UNIT_BENCH_PACKAGES=$(echo "$UNIT_BENCH_TASKS" \
            | jq 'select(.task == "bench:unit" and .command != "<NONEXISTENT>")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          INTEGRATION_BENCH_FILTER=$(turbo run bench:integration --dry-run=json --filter '...[HEAD^]' | jq -e '.packages | contains(["//"])' > /dev/null && echo '' || echo '--filter ...[HEAD^]')
          INTEGRATION_BENCH_TASKS=$(sh -c "turbo run bench:integration --dry-run=json $INTEGRATION_BENCH_FILTER" | jq -c '.tasks[]')
          INTEGRATION_BENCH_PACKAGES=$(echo "$INTEGRATION_BENCH_TASKS" \
            | jq 'select(.task == "bench:integration" and .command != "<NONEXISTENT>")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          REQUIRES_GRAPH=$(echo "$INTEGRATION_BENCH_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-graph" and .task == "build")] != []')
          REQUIRES_AI_WORKER_TS=$(echo "$INTEGRATION_BENCH_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-ts" and .task == "build")] != []')
          REQUIRES_INTEGRATION_WORKER=$(echo "$INTEGRATION_BENCH_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-worker-integration" and .task == "build")] != []')
          REQUIRES_API=$(echo "$INTEGRATION_BENCH_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-api" and .task == "build")] != []')

          DOCKER_PACKAGES=[]
          if [[ $REQUIRES_GRAPH == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-graph"]')
          fi
          if [[ $REQUIRES_AI_WORKER_TS == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-ai-worker-ts"]')
          fi
          if [[ $REQUIRES_INTEGRATION_WORKER == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-integration-worker"]')
          fi
          if [[ $REQUIRES_API == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-api"]')
          fi

          # We currently don't have benchmarks relying on a service running in a docker container
          DOCKER_PACKAGES=[]
          DOCKER_PACKAGES=$(echo $DOCKER_PACKAGES | jq -c '{ include: [{ package: .[] }] }')

          set -x
          echo "unit=$UNIT_BENCH_PACKAGES" >> $GITHUB_OUTPUT
          echo "integration=$INTEGRATION_BENCH_PACKAGES" >> $GITHUB_OUTPUT
          echo "dockers=$DOCKER_PACKAGES" >> $GITHUB_OUTPUT

  unit-benches:
    name: Unit
    needs: [setup]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.unit) }}
      fail-fast: false
    if: needs.setup.outputs.unit != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4

      - name: Install turbo
        uses: ./.github/actions/install-turbo

      - name: Find bench steps to run
        id: benches
        run: |
          HAS_RUST=$([[ -f "${{ matrix.directory }}/Cargo.toml" || ${{ matrix.directory }} = "apps/hash-graph" ]] && echo 'true' || echo 'false')
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            if [[ -f "${{ matrix.directory }}/rust-toolchain.toml" ]]; then
              RUST_TOOLCHAIN_FILE="${{ matrix.directory }}/rust-toolchain.toml"
            else
              RUST_TOOLCHAIN_FILE="rust-toolchain.toml"
            fi
            echo "rust-toolchain=$(yq '.toolchain.channel' $RUST_TOOLCHAIN_FILE)" >> $GITHUB_OUTPUT
          fi

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: ${{ matrix.package }}

      - name: Install Protobuf
        if: always() && steps.benches.outputs.has-rust == 'true'
        run: sudo apt install protobuf-compiler

      - name: Install Rust toolchain
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.benches.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: taiki-e/install-action@00a67321d66e038602baf558d366a594a7019ea2 # v2.33.9
        with:
          tool: just@1.13.0

      - name: Warm up repository
        uses: ./.github/actions/warm-up-repo

      - name: Cache Rust dependencies
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@23bce251a8cd2ffc3c1075eaa2367cf899916d84 # v2.7.3
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Run benches
        continue-on-error: ${{ steps.benches.outputs.allow-failure == 'true' }}
        run: |
          turbo run bench:unit --filter "${{ matrix.package }}"
          echo "TRIMMED_PACKAGE_NAME=$(echo "${{ matrix.package }}" | sed 's|@||g' | sed 's|/|.|g')" >> $GITHUB_ENV

  build:
    name: Build
    runs-on: ubuntu-22.04
    needs: [setup]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.dockers) }}
      fail-fast: false
    if: needs.setup.outputs.dockers != '{"include":[]}'
    steps:
      - name: Checkout
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4

      - name: Build image
        uses: ./.github/actions/build-docker-images
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          hash-graph: ${{ matrix.package == '@apps/hash-graph' }}
          hash-ai-worker-ts: ${{ matrix.package == '@apps/hash-ai-worker-ts' }}
          hash-integration-worker: ${{ matrix.package == '@apps/hash-integration-worker' }}
          hash-api: ${{ matrix.package == '@apps/hash-api' }}

  integration-benches:
    name: Integration
    needs: [setup, build]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.integration) }}
      fail-fast: false
    if: needs.setup.outputs.integration != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4

      - name: Install turbo
        uses: ./.github/actions/install-turbo

      - name: Find bench steps to run
        id: benches
        run: |
          TEST_TASKS=$(turbo run bench:integration --dry-run=json --filter "${{ matrix.package }}" | jq -c '.tasks[]')
          REQUIRES_GRAPH=$(echo "$TEST_TASKS" | jq -s '[.[] | select((.package == "@apps/hash-graph" or .package == "@rust/graph") and .task == "build")] != []')
          REQUIRES_AI_WORKER_TS=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-ts" and .task == "build")] != []')
          REQUIRES_INTEGRATION_WORKER=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-worker-integration" and .task == "build")] != []')
          REQUIRES_API=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-api" and .task == "build")] != []')

          HAS_RUST=$([[ -f "${{ matrix.directory }}/Cargo.toml" || ${{ matrix.directory }} = "apps/hash-graph" ]] && echo 'true' || echo 'false')
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            if [[ -f "${{ matrix.directory }}/rust-toolchain.toml" ]]; then
              RUST_TOOLCHAIN_FILE="${{ matrix.directory }}/rust-toolchain.toml"
            else
              RUST_TOOLCHAIN_FILE="rust-toolchain.toml"
            fi
            echo "rust-toolchain=$(yq '.toolchain.channel' $RUST_TOOLCHAIN_FILE)" >> $GITHUB_OUTPUT
            echo "has-miri=$(yq '.toolchain.components | contains(["miri"])' $RUST_TOOLCHAIN_FILE)" >> $GITHUB_OUTPUT
          fi

          echo "external-service-graph=$REQUIRES_GRAPH" >> $GITHUB_OUTPUT
          echo "external-service-ai-worker-ts=$REQUIRES_AI_WORKER_TS" >> $GITHUB_OUTPUT
          echo "external-service-worker-integration=$REQUIRES_INTEGRATION_WORKER" >> $GITHUB_OUTPUT
          echo "external-service-api=$REQUIRES_API" >> $GITHUB_OUTPUT

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: |
            ${{ matrix.package }}
            @apps/hash-external-services

      - name: Install Rust toolchain
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.benches.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: taiki-e/install-action@00a67321d66e038602baf558d366a594a7019ea2 # v2.33.9
        with:
          tool: just@1.13.0

      - name: Warm up repository
        uses: ./.github/actions/warm-up-repo

      - name: Install Protobuf
        if: always() && steps.benches.outputs.has-rust == 'true'
        run: sudo apt install protobuf-compiler

      - name: Cache Rust dependencies
        if: always() && steps.benches.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@23bce251a8cd2ffc3c1075eaa2367cf899916d84 # v2.7.3
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Show disk usage
        run: df -h

      - name: Load Docker images
        uses: ./.github/actions/load-docker-images
        with:
          hash-graph: ${{ steps.benches.outputs.external-service-graph == 'true' }}
          hash-ai-worker-ts: ${{ steps.benches.outputs.external-service-ai-worker-ts == 'true' }}
          hash-integration-worker: ${{ steps.benches.outputs.external-service-worker-integration == 'true' }}
          hash-api: ${{ steps.benches.outputs.external-service-api == 'true' }}

      - name: Launch external services
        run: |
          turbo codegen --filter '@apps/hash-external-services'

          SERVICES="hydra kratos redis spicedb"

          if [[ ${{ steps.benches.outputs.external-service-graph == 'true' }} == 'true' ]]; then
            SERVICES="$SERVICES graph"
          fi
          if [[ ${{ steps.benches.outputs.external-service-ai-worker-ts }} == 'true' ]]; then
              echo 'OPENAI_API_KEY=dummy' >> .env.local
              echo 'ANTHROPIC_API_KEY=dummy' >> .env.local
              SERVICES="$SERVICES hash-temporal-worker-ts"
          fi
          if [[ ${{ steps.benches.outputs.external-service-worker-integration }} == 'true' ]]; then
              SERVICES="$SERVICES hash-temporal-worker-integration"
          fi

          echo "Running services: $SERVICES"
          yarn workspace @apps/hash-external-services deploy:test up $SERVICES --wait

      - name: Run benches
        continue-on-error: ${{ steps.benches.outputs.allow-failure == 'true' }}
        run: |
          turbo run bench:integration --filter "${{ matrix.package }}"
          echo "TRIMMED_PACKAGE_NAME=$(echo "${{ matrix.package }}" | sed 's|@||g' | sed 's|/|.|g')" >> $GITHUB_ENV

      - uses: codecov/codecov-action@5ecb98a3c6b747ed38dc09f787459979aebb39be # v4.3.1
        name: Upload coverage to https://app.codecov.io/gh/hashintel/hash
        with:
          flags: ${{ env.TRIMMED_PACKAGE_NAME }}
          token: ${{ secrets.CODECOV_TOKEN }} ## not required for public repos, can be removed when https://github.com/codecov/codecov-action/issues/837 is resolved

      - name: Show container logs
        if: ${{ success() || failure() }}
        run: yarn workspace @apps/hash-external-services deploy logs --timestamps

  passed:
    name: Benches passed
    needs: [setup, unit-benches, build, integration-benches]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check setup script
        run: |
          [[ ${{ needs.setup.result }} = success ]]
      - name: Check unit benches
        run: |
          echo ${{ needs.setup.outputs.unit }} | jq
          [[ ${{ needs.unit-benches.result }} =~ success|skipped ]]
      - name: Check builds
        run: |
          echo ${{ needs.setup.outputs.dockers }} | jq
          [[ ${{ needs.build.result }} =~ success|skipped ]]
      - name: Check integration benches
        run: |
          echo ${{ needs.setup.outputs.integration }} | jq
          [[ ${{ needs.integration-benches.result }} =~ success|skipped ]]

      - name: Notify Slack on failure
        uses: rtCamp/action-slack-notify@19c86e40d4bc3be986b18f1459d4549536887065
        if: ${{ failure() && github.event_name == 'merge_group' }}
        env:
          SLACK_LINK_NAMES: true
          SLACK_MESSAGE: "At least one bench job failed for a Pull Request in the Merge Queue failed <@U0143NL4GMP> <@U027NPY8Y3X> <@U02NLJY0FGX>"
          SLACK_TITLE: Tests failed
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_USERNAME: GitHub
          VAULT_ADDR: ""
          VAULT_TOKEN: ""
