name: Package

on:
  pull_request:
  push:
    branches:
      - main
  merge_group:

env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: hashintel
  TURBO_REMOTE_ONLY: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  setup:
    runs-on: ubuntu-22.04
    outputs:
      unit-tests: ${{ steps.packages.outputs.unit-tests }}
      integration-tests: ${{ steps.packages.outputs.integration-tests }}
      system-tests: ${{ steps.packages.outputs.system-tests }}
      dockers: ${{ steps.packages.outputs.dockers }}
      lints: ${{ steps.packages.outputs.lints }}
      publish: ${{ steps.packages.outputs.publish }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0
        with:
          fetch-depth: 2

      - name: Install turbo
        run: yarn global add turbo

      - name: Determine changed packages
        id: packages
        run: |
          UNIT_TEST_PACKAGES=$(turbo run test:unit --dry-run=json --filter '...[HEAD^]' \
            | jq '.tasks[]' \
            | jq 'select(.task == "test:unit" and .command != "<NONEXISTENT>")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          INTEGRATION_TEST_TASKS=$(turbo run test:integration --dry-run=json --filter '...[HEAD^]' | jq -c '.tasks[]')
          INTEGRATION_TEST_PACKAGES=$(echo "$INTEGRATION_TEST_TASKS" \
            | jq 'select(.task == "test:integration" and .command != "<NONEXISTENT>")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          SYSTEM_TEST_PACKAGES=$(turbo run test:system --dry-run=json --filter '...[HEAD^]' \
            | jq '.tasks[]' \
            | jq 'select(.task == "test:system" and .command != "<NONEXISTENT>")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          LINT_PACKAGES=$(turbo run lint --dry-run=json --filter '...[HEAD^]' \
            | jq '.tasks[]' \
            | jq 'select(.task == "lint")' \
            | jq --compact-output --slurp '{ package: [.[].package] | unique, include: [( .[] | {package: .package, directory: .directory })] | unique }')

          PUBLISH_PACKAGES=[]
          PUBLISH_INCLUDES=[]          
          while IFS= read -r file; do
            if [[ -n "$file" ]]; then
              PACKAGE_NAME=$(yq '.package.name' -p toml -oy "$file")
              if [[ "$PACKAGE_NAME" == "null" ]]; then
                continue
              fi

              if [[ "$(yq '.package.publish' -p toml -oy "$file")" == "false" ]]; then
                continue
              fi
              
              OLD_VERSION=$(git show HEAD^:"$file" | yq '.package.version' -p toml)
              if [[ "$OLD_VERSION" == "null" ]]; then
                continue
              fi
              NEW_VERSION=$(yq '.package.version' -p toml -oy "$file")
              if [[ "$OLD_VERSION" == "$NEW_VERSION" ]]; then
                continue
              fi
              
              DIR=$(dirname "$file")
              
              PUBLISH_PACKAGES=$(echo "$PUBLISH_PACKAGES" | jq -c --arg package "$PACKAGE_NAME" '. += [$package]')
              PUBLISH_INCLUDES=$(echo "$PUBLISH_INCLUDES" | jq -c --arg package "$PACKAGE_NAME" --arg directory "$DIR" '. += [{package: $package, directory: $directory}]')
            fi
          done <<< "$(find . -name 'Cargo.toml' -type f | sed 's|\./||')"
          PUBLISH_PACKAGES=$(jq -c -n --argjson packages "$PUBLISH_PACKAGES" --argjson includes "$PUBLISH_INCLUDES" '{package: $packages, include: $includes}')
           
          if $(echo $SYSTEM_TEST_PACKAGES | jq -e '.package != []'); then
            REQUIRES_GRAPH=true
            REQUIRES_AI_WORKER_TS=true
            REQUIRES_AI_WORKER_PY=true
            REQUIRES_INTEGRATION_WORKER=true
          else
            REQUIRES_GRAPH=$(echo "$INTEGRATION_TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-graph" and .task == "build")] != []')
            REQUIRES_AI_WORKER_TS=$(echo "$INTEGRATION_TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-ts" and .task == "build")] != []')
            REQUIRES_AI_WORKER_PY=$(echo "$INTEGRATION_TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-py" and .task == "build")] != []')
            REQUIRES_INTEGRATION_WORKER=$(echo "$INTEGRATION_TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-worker-integration" and .task == "build")] != []')
          fi

          DOCKER_PACKAGES=[]
          if [[ $REQUIRES_GRAPH == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-graph"]')
          fi
          if [[ $REQUIRES_AI_WORKER_TS == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-ai-worker-ts"]')
          fi
          if [[ $REQUIRES_AI_WORKER_PY == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-ai-worker-py"]')
          fi
          if [[ $REQUIRES_INTEGRATION_WORKER == 'true' ]]; then
            DOCKER_PACKAGES=$(echo "$DOCKER_PACKAGES" | jq '. += ["@apps/hash-integration-worker"]')
          fi

          DOCKER_PACKAGES=$(echo $DOCKER_PACKAGES | jq -c '{ include: [{ package: .[] }] }')

          set -x
          echo "unit-tests=$UNIT_TEST_PACKAGES" >> $GITHUB_OUTPUT
          echo "integration-tests=$INTEGRATION_TEST_PACKAGES" >> $GITHUB_OUTPUT
          echo "system-tests=$SYSTEM_TEST_PACKAGES" >> $GITHUB_OUTPUT
          echo "dockers=$DOCKER_PACKAGES" >> $GITHUB_OUTPUT
          echo "lints=$LINT_PACKAGES" >> $GITHUB_OUTPUT
          echo "publish=$PUBLISH_PACKAGES" >> $GITHUB_OUTPUT

  lint:
    name: Lint
    needs: [setup]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.lints) }}
      fail-fast: false
    if: needs.setup.outputs.lints != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    env:
      RUSTFLAGS: "--cfg hash_graph_test_environment"
    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0
        with:
          fetch-depth: 2

      - name: Install turbo
        run: yarn global add turbo

      - name: Find lint steps to run
        id: lints
        run: |
          set -x
          ESLINT=$(turbo run lint:eslint --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "lint:eslint" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "eslint=$ESLINT" >> $GITHUB_OUTPUT

          TSC=$(turbo run lint:tsc --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "lint:tsc" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "tsc=$TSC" >> $GITHUB_OUTPUT

          CODEGEN=$(turbo run codegen --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "codegen" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "codegen=$CODEGEN" >> $GITHUB_OUTPUT

          HAS_PYTHON=$(test -f "${{ matrix.directory }}/pyproject.toml" && echo 'true' || echo 'false')
          echo "has-python=$HAS_PYTHON" >> $GITHUB_OUTPUT
          if [[ $HAS_PYTHON = 'true' ]]; then
            echo "python-version=$(cat "${{ matrix.directory }}/pyproject.toml" | yq -p toml '.tool.poetry.dependencies.python')" >> $GITHUB_OUTPUT
          else
            echo "python-version=^3.11" >> $GITHUB_OUTPUT
          fi

          HAS_POETRY_DEPS=$(turbo run poetry:install --filter '${{ matrix.package }}...' --dry-run=json \
            | jq '[.tasks[] | select(.task == "poetry:install" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "has-poetry-deps=$HAS_POETRY_DEPS" >> $GITHUB_OUTPUT

          BLACK=$(turbo run lint:black --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "lint:black" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "black=$BLACK" >> $GITHUB_OUTPUT

          RUFF=$(turbo run lint:ruff --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "lint:ruff" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "ruff=$RUFF" >> $GITHUB_OUTPUT

          MYPY=$(turbo run lint:mypy --filter '${{ matrix.package }}' --dry-run=json \
            | jq '[.tasks[] | select(.task == "lint:mypy" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "mypy=$MYPY" >> $GITHUB_OUTPUT

          HAS_RUST=$(test -f "${{ matrix.directory }}/rust-toolchain.toml" && echo 'true' || echo 'false') 
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            echo "rust-toolchain=$(yq '.toolchain.channel' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
            echo "has-rustfmt=$(yq '.toolchain.components | contains(["rustfmt"])' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
            echo "has-clippy=$(yq '.toolchain.components | contains(["clippy"])' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
          fi

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: ${{ matrix.package }}

      - name: Install yarn dependencies
        uses: nick-fields/retry@14672906e672a08bd6eeb15720e9ed3ce869cdd4 # v2.9.0
        env:
          HUSKY: 0
        with:
          max_attempts: 3
          timeout_minutes: 10
          shell: bash
          command: yarn install --frozen-lockfile --prefer-offline

      - name: Install Rust toolchain
        if: always() && steps.lints.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.lints.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.lints.outputs.has-rust == 'true'
        uses: taiki-e/install-action@e659bf85ee986e37e35cc1c53bfeebe044d8133e # v2.20.2
        with:
          tool: just@1.13.0,cargo-hack@0.6.7,rust-script@0.23.0,clippy-sarif@0.3.7,sarif-fmt@0.3.7

      - name: Cache Rust dependencies
        if: always() && steps.lints.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@a95ba195448af2da9b00fb742d14ffaaf3c21f43 # v2.7.0
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Install poetry
        if: always() && steps.lints.outputs.has-poetry-deps == 'true'
        run: pipx install poetry

      - name: Set up Python
        if: always() && steps.lints.outputs.has-poetry-deps == 'true'
        uses: actions/setup-python@65d7f2d534ac1bc67fcd62888c5f4f3d2cb2b236 # v4.7.1
        with:
          python-version: ${{ steps.lints.outputs.python-version }}
          cache: poetry

      - name: Install Python dependencies
        if: always() && steps.lints.outputs.has-poetry-deps == 'true'
        run: turbo run poetry:install

      - name: Show disk usage
        run: df -h

      - name: Run codegen
        if: always() && steps.lints.outputs.codegen == 'true'
        run: |
          set -o pipefail
          turbo run codegen --filter "${{ matrix.package }}"
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              echo "Checking diff of ${{ matrix.directory }}/$line"
              git --no-pager diff --exit-code --color -- "${{ matrix.directory }}/$line"
            fi
          done <<< "$(cat ${{ matrix.directory }}/turbo.json | grep -v '^ *//' | jq -r '.pipeline.codegen.outputs | if . == null then "." else .[] end')"

      - name: Show disk usage
        run: df -h

      - name: Run ESLint
        if: always() && steps.lints.outputs.eslint == 'true'
        run: turbo run lint:eslint --filter "${{ matrix.package }}"

      - name: Run TSC
        if: always() && steps.lints.outputs.tsc == 'true'
        run: turbo run lint:tsc --filter "${{ matrix.package }}"

      - name: Run rustfmt
        if: always() && steps.lints.outputs.has-rustfmt == 'true'
        working-directory: ${{ matrix.directory }}
        run: just format --check

      - name: Run clippy
        if: always() && steps.lints.outputs.has-clippy == 'true'
        working-directory: ${{ matrix.directory }}
        run: |
          just lint-toml "check"

          # For some reason, clippy does not use the rustflags from `.cargo/config.toml`. This is not a solution
          # but a workaround to make sure that the flags are used.
          RUSTFLAGS="$(yq -oy '.target["cfg(all())"].rustflags | join(" ")' .cargo/config.toml) $RUSTFLAGS"
          # If `export` would be on the same line this would not fail the workflow if the above line fails
          export RUSTFLAGS

          just clippy --message-format=json \
            | clippy-sarif \
            | jq '.runs[].results |= unique' \
            | tee clippy.sarif \
            | sarif-fmt

          jq -e '.runs[].results == []' clippy.sarif> /dev/null

      - name: Process SARIF file
        working-directory: ${{ matrix.directory }}
        if: always() && steps.lints.outputs.has-clippy == 'true'
        run: |
          tmp=$(mktemp)

          jq --arg pwd "${{ matrix.directory }}" '.runs[].results[].locations[].physicalLocation.artifactLocation.uri |= $pwd + "/" + .' clippy.sarif > "$tmp"

          mv "$tmp" clippy.sarif

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@fdcae64e1484d349b3366718cdfef3d404390e85 # v2.22.1
        if: always() && steps.lints.outputs.has-clippy == 'true'
        with:
          sarif_file: ${{ matrix.directory }}/clippy.sarif
          category: ${{ matrix.name }}

      - name: Check public documentation
        if: always() && steps.lints.outputs.has-rust == 'true'
        working-directory: ${{ matrix.directory }}
        env:
          RUSTDOCFLAGS: "--check -Z unstable-options -D warnings"
        run: just doc

      - name: Check private documentation
        if: always() && steps.lints.outputs.has-rust == 'true'
        working-directory: ${{ matrix.directory }}
        env:
          RUSTDOCFLAGS: "--check -Z unstable-options -D warnings"
        run: just doc --document-private-items

      - name: Check poetry
        if: always() && steps.lints.outputs.has-python == 'true'
        working-directory: ${{ matrix.directory }}
        run: poetry check

      - name: Run black
        if: always() && steps.lints.outputs.black == 'true'
        run: turbo run lint:black --filter "${{ matrix.package }}"

      - name: Run ruff
        if: always() && steps.lints.outputs.ruff == 'true'
        run: turbo run lint:ruff --filter "${{ matrix.package }}"

      - name: Run MyPy
        if: always() && steps.lints.outputs.mypy == 'true'
        run: turbo run lint:mypy --filter "${{ matrix.package }}"

      - name: Show disk usage
        run: df -h

  unit-tests:
    name: Unit Tests
    needs: [setup]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.unit-tests) }}
      fail-fast: false
    if: needs.setup.outputs.unit-tests != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0

      - name: Install turbo
        run: yarn global add turbo

      - name: Find test steps to run
        id: tests
        run: |
          HAS_RUST=$(test -f "${{ matrix.directory }}/rust-toolchain.toml" && echo 'true' || echo 'false') 
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            echo "rust-toolchain=$(yq '.toolchain.channel' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
            echo "has-miri=$(yq '.toolchain.components | contains(["miri"])' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
          fi

          HAS_PYTHON=$(test -f "${{ matrix.directory }}/pyproject.toml" && echo 'true' || echo 'false')
          echo "has-python=$HAS_PYTHON" >> $GITHUB_OUTPUT
          if [[ $HAS_PYTHON = 'true' ]]; then
            echo "python-version=$(cat "${{ matrix.directory }}/pyproject.toml" | yq -p toml '.tool.poetry.dependencies.python')" >> $GITHUB_OUTPUT
          else
            echo "python-version=^3.11" >> $GITHUB_OUTPUT
          fi

          HAS_POETRY_DEPS=$(turbo run poetry:install --filter '${{ matrix.package }}...' --dry-run=json \
            | jq '[.tasks[] | select(.task == "poetry:install" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "has-poetry-deps=$HAS_POETRY_DEPS" >> $GITHUB_OUTPUT

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: ${{ matrix.package }}

      - name: Install yarn dependencies
        uses: nick-fields/retry@14672906e672a08bd6eeb15720e9ed3ce869cdd4 # v2.9.0
        env:
          HUSKY: 0
        with:
          max_attempts: 3
          timeout_minutes: 10
          shell: bash
          command: yarn install --frozen-lockfile --prefer-offline

      - name: Install Rust toolchain
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.tests.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: taiki-e/install-action@e659bf85ee986e37e35cc1c53bfeebe044d8133e # v2.20.2
        with:
          tool: just@1.13.0,cargo-hack@0.6.7,cargo-nextest@0.9.37,cargo-llvm-cov@0.5.9

      - name: Cache Rust dependencies
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@a95ba195448af2da9b00fb742d14ffaaf3c21f43 # v2.7.0
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Install poetry
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        run: pipx install poetry

      - name: Set up Python
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        uses: actions/setup-python@65d7f2d534ac1bc67fcd62888c5f4f3d2cb2b236 # v4.7.1
        with:
          python-version: ${{ steps.tests.outputs.python-version }}
          cache: poetry

      - name: Install Python dependencies
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        run: turbo run poetry:install

      - name: Show disk usage
        run: df -h

      - name: Run tests
        env:
          TEST_COVERAGE: ${{ github.event_name != 'merge_group' }}
        run: |
          turbo run test:unit --filter "${{ matrix.package }}"
          echo "TRIMMED_PACKAGE_NAME=$(echo "${{ matrix.package }}" | sed 's|@||g' | sed 's|/|.|g')" >> $GITHUB_ENV

      - name: Show disk usage
        run: df -h

      - uses: codecov/codecov-action@eaaf4bedf32dbdc6b720b63067d99c4d77d6047d # v3.1.4
        name: Upload coverage to https://app.codecov.io/gh/hashintel/hash
        with:
          flags: ${{ env.TRIMMED_PACKAGE_NAME }}
          token: ${{ secrets.CODECOV_TOKEN }} ## not required for public repos, can be removed when https://github.com/codecov/codecov-action/issues/837 is resolved

      - name: Run miri
        if: always() && steps.tests.outputs.has-miri == 'true'
        run: |
          turbo run test:miri --filter "${{ matrix.package }}"

  build:
    name: Build
    runs-on: ubuntu-22.04
    needs: [setup]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.dockers) }}
      fail-fast: false
    if: needs.setup.outputs.dockers != '{"include":[]}'
    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0

      - name: Build image
        uses: ./.github/actions/build-docker-images
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          hash-graph: ${{ matrix.package == '@apps/hash-graph' }}
          hash-ai-worker-ts: ${{ matrix.package == '@apps/hash-ai-worker-ts' }}
          hash-ai-worker-py: ${{ matrix.package == '@apps/hash-ai-worker-py' }}
          hash-integration-worker: ${{ matrix.package == '@apps/hash-integration-worker' }}

  integration-tests:
    name: Integration Tests
    needs: [setup, build]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.integration-tests) }}
      fail-fast: false
    if: needs.setup.outputs.integration-tests != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0

      - name: Install turbo
        run: yarn global add turbo

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: |
            ${{ matrix.package }}
            @apps/hash-external-services

      - name: Install yarn dependencies
        uses: nick-fields/retry@14672906e672a08bd6eeb15720e9ed3ce869cdd4 # v2.9.0
        env:
          HUSKY: 0
        with:
          max_attempts: 3
          timeout_minutes: 10
          shell: bash
          command: yarn install --frozen-lockfile --prefer-offline

      - name: Find test steps to run
        id: tests
        run: |
          HAS_RUST=$(test -f "${{ matrix.directory }}/rust-toolchain.toml" && echo 'true' || echo 'false')

          TEST_TASKS=$(turbo run test:integration --dry-run=json --filter "${{ matrix.package }}" | jq -c '.tasks[]')
          REQUIRES_GRAPH=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-graph" and .task == "build")] != []')
          REQUIRES_AI_WORKER_TS=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-ts" and .task == "build")] != []')
          REQUIRES_AI_WORKER_PY=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-ai-worker-py" and .task == "build")] != []')
          REQUIRES_INTEGRATION_WORKER=$(echo "$TEST_TASKS" | jq -s '[.[] | select(.package == "@apps/hash-worker-integration" and .task == "build")] != []')

          HAS_PYTHON=$(test -f "${{ matrix.directory }}/pyproject.toml" && echo 'true' || echo 'false')
          echo "has-python=$HAS_PYTHON" >> $GITHUB_OUTPUT
          if [[ $HAS_PYTHON = 'true' ]]; then
            echo "python-version=$(cat "${{ matrix.directory }}/pyproject.toml" | yq -p toml '.tool.poetry.dependencies.python')" >> $GITHUB_OUTPUT
          else
            echo "python-version=^3.11" >> $GITHUB_OUTPUT
          fi

          HAS_POETRY_DEPS=$(turbo run poetry:install --filter '${{ matrix.package }}...' --dry-run=json \
            | jq '[.tasks[] | select(.task == "poetry:install" and .command != "<NONEXISTENT>")] != []' || echo 'false')
          echo "has-poetry-deps=$HAS_POETRY_DEPS" >> $GITHUB_OUTPUT

          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            echo "rust-toolchain=$(yq '.toolchain.channel' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
            echo "has-miri=$(yq '.toolchain.components | contains(["miri"])' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
          fi

          echo "external-service-graph=$REQUIRES_GRAPH" >> $GITHUB_OUTPUT
          echo "external-service-ai-worker-ts=$REQUIRES_AI_WORKER_TS" >> $GITHUB_OUTPUT
          echo "external-service-ai-worker-py=$REQUIRES_AI_WORKER_PY" >> $GITHUB_OUTPUT
          echo "external-service-worker-integration=$REQUIRES_INTEGRATION_WORKER" >> $GITHUB_OUTPUT

      - name: Install Rust toolchain
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.tests.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: taiki-e/install-action@e659bf85ee986e37e35cc1c53bfeebe044d8133e # v2.20.2
        with:
          tool: just@1.13.0,cargo-hack@0.6.7,cargo-nextest@0.9.37,cargo-llvm-cov@0.5.9

      - name: Cache Rust dependencies
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@a95ba195448af2da9b00fb742d14ffaaf3c21f43 # v2.7.0
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Install poetry
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        run: pipx install poetry

      - name: Set up Python
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        uses: actions/setup-python@65d7f2d534ac1bc67fcd62888c5f4f3d2cb2b236 # v4.7.1
        with:
          python-version: ${{ steps.tests.outputs.python-version }}
          cache: poetry

      - name: Install Python dependencies
        if: always() && steps.tests.outputs.has-poetry-deps == 'true'
        run: turbo run poetry:install

      - name: Show disk usage
        run: df -h

      - name: Load Docker images
        uses: ./.github/actions/load-docker-images
        with:
          hash-graph: ${{ steps.tests.outputs.external-service-graph == 'true' }}
          hash-ai-worker-ts: ${{ steps.tests.outputs.external-service-ai-worker-ts == 'true' }}
          hash-ai-worker-py: ${{ steps.tests.outputs.external-service-ai-worker-py == 'true' }}
          hash-integration-worker: ${{ steps.tests.outputs.external-service-worker-integration == 'true' }}

      - name: Show disk usage
        run: df -h

      - name: Launch external services
        run: |
          turbo codegen --filter '@apps/hash-external-services'

          SERVICES="kratos mailslurper redis temporal temporal-setup spicedb"

          if [[ ${{ steps.tests.outputs.external-service-graph == 'true' }} == 'true' ]]; then
            SERVICES="$SERVICES graph"
          fi
          if [[ ${{ steps.tests.outputs.external-service-ai-worker-ts }} == 'true' ]]; then
              SERVICES="$SERVICES hash-temporal-worker-ts"
          fi
          if [[ ${{ steps.tests.outputs.external-service-ai-worker-py }} == 'true' ]]; then
              SERVICES="$SERVICES hash-temporal-worker-py"
          fi
          if [[ ${{ steps.tests.outputs.external-service-worker-integration }} == 'true' ]]; then
              SERVICES="$SERVICES hash-temporal-worker-integration"
          fi

          echo "Running services: $SERVICES"
          yarn workspace @apps/hash-external-services deploy:test up $SERVICES --detach

      - name: Show disk usage
        run: df -h

      - name: Run tests
        run: |
          turbo run test:integration --filter "${{ matrix.package }}"
          echo "TRIMMED_PACKAGE_NAME=$(echo "${{ matrix.package }}" | sed 's|@||g' | sed 's|/|.|g')" >> $GITHUB_ENV

      - name: Show disk usage
        run: df -h

      - uses: codecov/codecov-action@eaaf4bedf32dbdc6b720b63067d99c4d77d6047d # v3.1.4
        name: Upload coverage to https://app.codecov.io/gh/hashintel/hash
        with:
          flags: ${{ env.TRIMMED_PACKAGE_NAME }}
          token: ${{ secrets.CODECOV_TOKEN }} ## not required for public repos, can be removed when https://github.com/codecov/codecov-action/issues/837 is resolved

      - name: Show container logs
        if: ${{ success() || failure() }}
        run: yarn workspace @apps/hash-external-services deploy logs --timestamps

  system-tests:
    name: System Tests
    needs: [setup, build]
    strategy:
      matrix: ${{ fromJSON(needs.setup.outputs.system-tests) }}
      fail-fast: false
    if: needs.setup.outputs.system-tests != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0

      - name: Install turbo
        run: yarn global add turbo

      - name: Find test steps to run
        id: tests
        run: |
          set -x
          HAS_RUST=$(test -f "${{ matrix.directory }}/rust-toolchain.toml" && echo 'true' || echo 'false') 
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            echo "rust-toolchain=$(yq '.toolchain.channel' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
            echo "has-miri=$(yq '.toolchain.components | contains(["miri"])' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
          fi

      - name: Prune repository
        uses: ./.github/actions/prune-repository
        with:
          scope: |
            ${{ matrix.package }}
            @apps/hash-external-services

      - name: Install yarn dependencies
        uses: nick-fields/retry@14672906e672a08bd6eeb15720e9ed3ce869cdd4 # v2.9.0
        env:
          HUSKY: 0
        with:
          max_attempts: 3
          timeout_minutes: 10
          shell: bash
          command: yarn install --frozen-lockfile --prefer-offline

      - name: Install Rust toolchain
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.tests.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install Rust tools
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: taiki-e/install-action@e659bf85ee986e37e35cc1c53bfeebe044d8133e # v2.20.2
        with:
          tool: just@1.13.0,cargo-hack@0.6.7,cargo-nextest@0.9.37,cargo-llvm-cov@0.5.9

      - name: Cache Rust dependencies
        if: always() && steps.tests.outputs.has-rust == 'true'
        uses: Swatinem/rust-cache@a95ba195448af2da9b00fb742d14ffaaf3c21f43 # v2.7.0
        with:
          workspaces: ${{ matrix.directory }}
          save-if: ${{ !startsWith(github.ref, 'refs/heads/gh-readonly-queue') }}

      - name: Install playwright
        if: matrix.package == '@tests/hash-playwright'
        uses: nick-fields/retry@14672906e672a08bd6eeb15720e9ed3ce869cdd4 # v2.9.0
        with:
          max_attempts: 3
          timeout_minutes: 10
          shell: bash
          command: npx playwright install --with-deps chromium

      - name: Show disk usage
        run: df -h

      - name: Load Docker images
        uses: ./.github/actions/load-docker-images
        with:
          hash-graph: true
          hash-ai-worker-ts: true
          hash-ai-worker-py: true
          hash-integration-worker: true

      - name: Show disk usage
        run: df -h

      - name: Launch external services
        run: |
          turbo codegen --filter '@apps/hash-external-services'
          yarn workspace @apps/hash-external-services deploy up --detach

      - name: Launch HASH-API
        run: |
          turbo run start --filter "@apps/hash-api" &
          yarn wait-on --timeout 120000 http://0.0.0.0:5001

      - name: Launch frontend
        run: |
          turbo run build --filter "@apps/hash-frontend"
          yarn workspace @apps/hash-frontend start &
          yarn wait-on --timeout 30000 http://0.0.0.0:3000

      - name: Show disk usage
        run: df -h

      - name: Run tests
        run: |
          turbo run test:system --filter "${{ matrix.package }}"

      - name: Show disk usage
        run: df -h

      - name: Show container logs
        if: ${{ success() || failure() }}
        run: yarn workspace @apps/hash-external-services deploy logs --timestamps

  publish:
    name: Publish
    needs: [setup]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.setup.outputs.publish) }}
    if: needs.setup.outputs.publish != '{"package":[],"include":[]}'
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout source code
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0

      - name: Find publish jobs to run
        id: publish
        run: |
          set -x
          HAS_RUST=$(test -f "${{ matrix.directory }}/rust-toolchain.toml" && echo 'true' || echo 'false') 
          echo "has-rust=$HAS_RUST" >> $GITHUB_OUTPUT
          if [[ $HAS_RUST = 'true' ]]; then
            echo "rust-toolchain=$(yq '.toolchain.channel' ${{ matrix.directory }}/rust-toolchain.toml)" >> $GITHUB_OUTPUT
          fi

      - name: Install Rust toolchain
        if: always() && steps.publish.outputs.has-rust == 'true'
        uses: ./.github/actions/install-rust-toolchain
        with:
          toolchain: ${{ steps.publish.outputs.rust-toolchain }}
          working-directory: ${{ matrix.directory }}

      - name: Install tools
        if: always() && steps.publish.outputs.has-rust == 'true' && github.event_name == 'pull_request' || github.event_name == 'merge_group'
        uses: taiki-e/install-action@e659bf85ee986e37e35cc1c53bfeebe044d8133e # v2.20.2
        with:
          tool: cargo-semver-checks

      - name: Login
        run: |
          [[ -n "${{ secrets.CARGO_REGISTRY_TOKEN }}" ]]
          cargo login "${{ secrets.CARGO_REGISTRY_TOKEN }}"

      - name: SemVer check
        if: always() && steps.publish.outputs.has-rust == 'true' && github.event_name == 'pull_request' || github.event_name == 'merge_group'
        working-directory: ${{ matrix.directory }}
        run: cargo semver-checks check-release

      - name: Publish (dry run)
        if: always() && steps.publish.outputs.has-rust == 'true' && github.event_name == 'pull_request' || github.event_name == 'merge_group'
        working-directory: ${{ matrix.directory }}
        run: cargo publish --all-features --dry-run

      - name: Publish
        if: always() && steps.publish.outputs.has-rust == 'true' && github.event_name == 'push' && github.ref == 'refs/heads/main'
        working-directory: ${{ matrix.directory }}
        run: cargo publish --all-features

  passed:
    name: Workflow passed
    needs: [setup, lint, unit-tests, integration-tests, system-tests, publish]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check setup script
        run: |
          [[ ${{ needs.setup.result }} = success ]]
      - name: Check lint results
        run: |
          [[ ${{ needs.lint.result }} =~ success|skipped ]]
      - name: Check unit tests
        run: |
          [[ ${{ needs.unit-tests.result }} =~ success|skipped ]]
      - name: Check integration tests
        run: |
          [[ ${{ needs.integration-tests.result }} =~ success|skipped ]]
      - name: Check system tests
        run: |
          # TODO: Stop allowing failure of system tests
          [[ ${{ needs.system-tests.result }} =~ success|skipped|failure ]]
      - name: Check publish results
        run: |
          [[ ${{ needs.publish.result }} =~ success|skipped ]]
