on:
  # We could allow configuring environment here.
  workflow_dispatch: {}
  push:
    branches:
      - main
    paths:
      - ".github/workflows/hash-backend-cd.yml"
      - "apps/hash-ai-worker-ts/**"
      - "apps/hash-integration-worker/**"
      - "apps/hash-graph/**"
      - "apps/hash-api/**"
      - "apps/hash-external-services/temporal/**"
      - "apps/hash-external-services/kratos/**"
      - "apps/hash-external-services/hydra/**"
      - "libs/@local/**"
      - "infra/docker/api/prod/**"

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ECR_URL: ${{ secrets.AWS_ECR_URL }}

  # New artifacts account ECR (cross-account)
  ARTIFACTS_ECR_URL: 469596578827.dkr.ecr.eu-central-1.amazonaws.com
  ARTIFACTS_ECR_ROLE_ARN: arn:aws:iam::469596578827:role/h-artifacts-euc1-ecr-push
  ARTIFACTS_AWS_REGION: eu-central-1

  GH_RUN_ID: ${{ github.run_id }}

  GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON: ${{ secrets.GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON }}

  HASH_API_RESOURCE_NAME: ${{ secrets.HASH_API_RESOURCE_NAME }}
  HASH_GRAPH_RESOURCE_NAME: ${{ secrets.HASH_GRAPH_RESOURCE_NAME }}
  HASH_KRATOS_RESOURCE_NAME: ${{ secrets.HASH_KRATOS_RESOURCE_NAME }}
  HASH_HYDRA_RESOURCE_NAME: ${{ secrets.HASH_HYDRA_RESOURCE_NAME }}
  HASH_TEMPORAL_AI_TS_WORKER_RESOURCE_NAME: h-hash-prod-usea1-temporalworkeraits
  HASH_TEMPORAL_INTEGRATION_WORKER_RESOURCE_NAME: h-hash-prod-usea1-temporalworkerintegration

  HASH_TEMPORAL_SETUP_RESOURCE_NAME: h-temporal-prod-usea1-setup
  HASH_TEMPORAL_MIGRATE_RESOURCE_NAME: h-temporal-prod-usea1-migrate
  HASH_TEMPORAL_VERSION: 1.23.1.0

  HASH_ECS_CLUSTER_NAME: h-hash-prod-usea1-ecs
  HASH_APP_SERVICE_NAME: h-hash-prod-usea1-appsvc
  HASH_GRAPH_SERVICE_NAME: h-hash-prod-usea1-graph
  HASH_WORKER_SERVICE_NAME: h-hash-prod-usea1-appworker-svc

  HASH_TEMPORAL_ECS_CLUSTER_NAME: h-temporal-prod-usea1-ecs
  HASH_TEMPORAL_SERVICE_NAME: h-temporal-prod-usea1-svc

  STAGING_AWS_REGION: eu-central-1
  STAGING_APP_CLUSTER_NAME: h-stage-euc1-app
  STAGING_APP_DEPLOY_ROLE_ARN: arn:aws:iam::054238437032:role/h-stage-euc1-app-deploy
  STAGING_APP_GRAPH_SERVICE_NAME: h-stage-euc1-app-graph
  STAGING_APP_TYPE_FETCHER_SERVICE_NAME: h-stage-euc1-app-type-fetcher
  STAGING_AUTH_CLUSTER_NAME: h-stage-euc1-auth
  STAGING_AUTH_DEPLOY_ROLE_ARN: arn:aws:iam::054238437032:role/h-stage-euc1-auth-deploy
  STAGING_AUTH_KRATOS_SERVICE_NAME: h-stage-euc1-auth-kratos
  STAGING_AUTH_HYDRA_SERVICE_NAME: h-stage-euc1-auth-hydra

  PRODUCTION_AWS_REGION: eu-central-1
  PRODUCTION_APP_CLUSTER_NAME: h-prod-euc1-app
  PRODUCTION_APP_DEPLOY_ROLE_ARN: arn:aws:iam::597482567121:role/h-prod-euc1-app-deploy
  PRODUCTION_APP_GRAPH_SERVICE_NAME: h-prod-euc1-app-graph
  PRODUCTION_APP_TYPE_FETCHER_SERVICE_NAME: h-prod-euc1-app-type-fetcher
  PRODUCTION_AUTH_CLUSTER_NAME: h-prod-euc1-auth
  PRODUCTION_AUTH_DEPLOY_ROLE_ARN: arn:aws:iam::597482567121:role/h-prod-euc1-auth-deploy
  PRODUCTION_AUTH_KRATOS_SERVICE_NAME: h-prod-euc1-auth-kratos
  PRODUCTION_AUTH_HYDRA_SERVICE_NAME: h-prod-euc1-auth-hydra

name: HASH backend deployment
jobs:
  build-graph:
    name: Build and push HASH graph image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "graph"
          CONTEXT_PATH: ${{ github.workspace }}/
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-graph/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_GRAPH_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "graph"
          CONTEXT_PATH: ${{ github.workspace }}/
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-graph/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/graph
          GITHUB_TOKEN: ${{ github.token }}

  build-api:
    name: Build and push HASH api image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "api"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/infra/docker/api/prod/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_API_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "api"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/infra/docker/api/prod/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/api
          GITHUB_TOKEN: ${{ github.token }}

  build-kratos:
    name: Build and push Kratos image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "kratos"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/kratos
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/kratos/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_KRATOS_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            ENV=prod
            API_SECRET=${{ secrets.HASH_KRATOS_API_SECRET }}

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "kratos"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/kratos
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/kratos/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/kratos
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            ENV=prod
            API_SECRET=${{ secrets.HASH_KRATOS_API_SECRET }}

  build-hydra:
    name: Build and push Hydra image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "hydra"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/hydra
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/hydra/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_HYDRA_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            ENV=prod

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "hydra"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/hydra
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/hydra/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/hydra
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            ENV=prod

  build-ts-worker:
    name: Build and push Temporal TS AI Worker
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "temporal-worker-ai-ts"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-ai-worker-ts/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_TEMPORAL_AI_TS_WORKER_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON: ${{ secrets.GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON }}

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "temporal-worker-ai-ts"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-ai-worker-ts/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/ai-worker-ts
          GITHUB_TOKEN: ${{ github.token }}
          BUILD_ARGS: |
            GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON: ${{ secrets.GOOGLE_CLOUD_WORKLOAD_IDENTITY_FEDERATION_CONFIG_JSON }}

  build-integration-worker:
    name: Build and push Temporal integration Worker
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "temporal-integration-worker"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-integration-worker/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_TEMPORAL_INTEGRATION_WORKER_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}

      - name: Push to artifacts ECR
        uses: ./.github/actions/docker-build-push
        with:
          SHORTNAME: "temporal-integration-worker"
          CONTEXT_PATH: ${{ github.workspace }}
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-integration-worker/docker/Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.ARTIFACTS_AWS_REGION }}
          AWS_ECR_URL: ${{ env.ARTIFACTS_ECR_URL }}
          ROLE_ARN: ${{ env.ARTIFACTS_ECR_ROLE_ARN }}
          IMAGE_NAME: ${{ github.repository }}/integration-worker
          GITHUB_TOKEN: ${{ github.token }}

  build-temporal-migrate:
    name: Build and push Temporal Migrate image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "temporal-migrate"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/temporal
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/temporal/migrate.Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_TEMPORAL_MIGRATE_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}
          IMAGE_TAG: ${{ env.HASH_TEMPORAL_VERSION }}
          BUILD_ARGS: |
            TEMPORAL_VERSION=${{ env.HASH_TEMPORAL_VERSION }}

  build-temporal-setup:
    name: Build and push Temporal Setup image
    runs-on: ubuntu-24.04-arm
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Docker image build through docker-build-push
        uses: ./.github/actions/docker-build-push
        id: build
        with:
          SHORTNAME: "temporal-setup"
          CONTEXT_PATH: ${{ github.workspace }}/apps/hash-external-services/temporal
          DOCKERFILE_LOCATION: ${{ github.workspace }}/apps/hash-external-services/temporal/setup.Dockerfile
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ECR_URL: ${{ env.AWS_ECR_URL }}
          IMAGE_NAME: ${{ env.HASH_TEMPORAL_SETUP_RESOURCE_NAME }}
          GITHUB_TOKEN: ${{ github.token }}
          IMAGE_TAG: ${{ env.HASH_TEMPORAL_VERSION }}
          BUILD_ARGS: |
            TEMPORAL_VERSION=${{ env.HASH_TEMPORAL_VERSION }}

  deploy-graph:
    name: Deploy HASH graph images
    runs-on: ubuntu-latest
    # needs:
    # - build-graph
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Redeploy service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.HASH_ECS_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.HASH_GRAPH_SERVICE_NAME }}

      - name: Redeploy graph staging service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.STAGING_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.STAGING_APP_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.STAGING_APP_GRAPH_SERVICE_NAME }}
          ROLE_ARN: ${{ env.STAGING_APP_DEPLOY_ROLE_ARN }}

      - name: Redeploy type-fetcher staging service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.STAGING_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.STAGING_APP_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.STAGING_APP_TYPE_FETCHER_SERVICE_NAME }}
          ROLE_ARN: ${{ env.STAGING_APP_DEPLOY_ROLE_ARN }}

      - name: Redeploy graph production service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.PRODUCTION_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.PRODUCTION_APP_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.PRODUCTION_APP_GRAPH_SERVICE_NAME }}
          ROLE_ARN: ${{ env.PRODUCTION_APP_DEPLOY_ROLE_ARN }}

      - name: Redeploy type-fetcher production service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.PRODUCTION_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.PRODUCTION_APP_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.PRODUCTION_APP_TYPE_FETCHER_SERVICE_NAME }}
          ROLE_ARN: ${{ env.PRODUCTION_APP_DEPLOY_ROLE_ARN }}

  deploy-app:
    name: Deploy HASH app images
    runs-on: ubuntu-latest
    needs:
      # - build-api
      # - build-kratos
      # - build-hydra
      # Technically not needed but it's good if the graph has been finished already
      - deploy-graph
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Redeploy service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.HASH_ECS_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.HASH_APP_SERVICE_NAME }}

      - name: Redeploy kratos staging service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.STAGING_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.STAGING_AUTH_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.STAGING_AUTH_KRATOS_SERVICE_NAME }}
          ROLE_ARN: ${{ env.STAGING_AUTH_DEPLOY_ROLE_ARN }}

      - name: Redeploy hydra staging service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.STAGING_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.STAGING_AUTH_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.STAGING_AUTH_HYDRA_SERVICE_NAME }}
          ROLE_ARN: ${{ env.STAGING_AUTH_DEPLOY_ROLE_ARN }}

      - name: Redeploy kratos production service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.PRODUCTION_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.PRODUCTION_AUTH_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.PRODUCTION_AUTH_KRATOS_SERVICE_NAME }}
          ROLE_ARN: ${{ env.PRODUCTION_AUTH_DEPLOY_ROLE_ARN }}

      - name: Redeploy hydra production service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.PRODUCTION_AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.PRODUCTION_AUTH_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.PRODUCTION_AUTH_HYDRA_SERVICE_NAME }}
          ROLE_ARN: ${{ env.PRODUCTION_AUTH_DEPLOY_ROLE_ARN }}

  deploy-workers:
    name: Deploy HASH worker images
    runs-on: ubuntu-latest
    needs:
      # - build-ts-worker
      # - build-integration-worker
      # Technically not needed but it's good if the graph has been finished already
      - deploy-graph
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Redeploy service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.HASH_ECS_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.HASH_WORKER_SERVICE_NAME }}

  deploy-temporal:
    name: Deploy Temporal images
    runs-on: ubuntu-latest
    # needs:
    #   - build-temporal-migrate
    #   - build-temporal-setup
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Authenticate Vault
        id: secrets
        uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3.4.0
        with:
          exportToken: true
          url: ${{ env.VAULT_ADDR }}
          method: jwt
          role: prod
          # Even though it could look like separate calls to fetch the secrets
          # the responses here are cached, so we're only issuing a single set of credentials
          secrets: |
            aws/creds/prod-deploy access_key | AWS_ACCESS_KEY_ID ;
            aws/creds/prod-deploy secret_key | AWS_SECRET_ACCESS_KEY ;
            aws/creds/prod-deploy security_token | AWS_SESSION_TOKEN

      - name: Redeploy service
        uses: ./.github/actions/redeploy-ecs-service
        with:
          AWS_ACCESS_KEY_ID: ${{ steps.secrets.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ steps.secrets.outputs.AWS_SESSION_TOKEN }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ env.HASH_TEMPORAL_ECS_CLUSTER_NAME }}
          ECS_SERVICE_NAME: ${{ env.HASH_TEMPORAL_SERVICE_NAME }}

  # notify-slack:
  #   name: Notify Slack on failure
  #   needs:
  #     - deploy-app
  #     - deploy-graph
  #     - deploy-workers
  #     - deploy-temporal
  #   runs-on: ubuntu-latest
  #   if: ${{ failure() }}
  #   steps:
  #     - name: Slack Notification
  #       uses: rtCamp/action-slack-notify@07cbdbfd6c6190970778d8f98f11d073b2932aae
  #       env:
  #         SLACK_LINK_NAMES: true
  #         SLACK_MESSAGE: "Error deploying the HASH backend <!subteam^S09KH99698T>" # Notifies @devops
  #         SLACK_TITLE: Backend deployment failed
  #         SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
  #         SLACK_USERNAME: GitHub
  #         VAULT_ADDR: ""
  #         VAULT_TOKEN: ""
