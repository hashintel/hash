[tasks.clippy-collect-lints]
private = true
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! serde = {version = "*", features = ["derive"]}
//! toml = {version = "*", features = ["parse"]}
//! serde_json = {version = "*"}
//! ```
use serde::{Deserialize, Serialize};
use std::env;
use std::fs;
use std::collections::{HashMap, HashSet};
use std::path::PathBuf;

enum LintLevel {
    Allow,
    Warn,
    Deny,
    Forbid,
}

struct Lints(HashMap<String, LintLevel>);

impl Lints {
    pub fn new() -> Self {
        Self(HashMap::new())
    }

    // if defined multiple times this is the priority order
    // * allow
    // * warn
    // * deny
    // * forbid
    pub fn apply(&mut self, file: LintFile) {
        for lint in file.allow {
            self.0.insert(lint, LintLevel::Allow);
        }

        for lint in file.warn {
            self.0.insert(lint, LintLevel::Warn);
        }

        for lint in file.deny {
            self.0.insert(lint, LintLevel::Deny);
        }

        for lint in file.forbid {
            self.0.insert(lint, LintLevel::Forbid);
        }

        for lint in file.default {
            self.0.remove(&lint);
        }
    }

    pub fn into_file(self) -> LintFile {
        self.0.into_iter().fold(LintFile::default(), |mut acc, (lint, level)| {
            match level {
                LintLevel::Allow => acc.allow.insert(lint),
                LintLevel::Warn => acc.warn.insert(lint),
                LintLevel::Deny => acc.deny.insert(lint),
                LintLevel::Forbid => acc.forbid.insert(lint),
            };

            acc
        })
    }
}

#[derive(Deserialize, Serialize, Default)]
struct LintFile {
    #[serde(default)]
    allow: HashSet<String>,
    #[serde(default)]
    warn: HashSet<String>,
    #[serde(default)]
    deny: HashSet<String>,
    #[serde(default)]
    forbid: HashSet<String>,
    #[serde(default)]
    default: HashSet<String>,
}

fn main() {
    let cwd = env::var("CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY").expect("environment variable should exist");
    let cwd = PathBuf::from(cwd);

    let mut active = cwd.as_path();
    let mut files = vec![];

    // go up the directory tree and find all files in `.config/lints.toml`
    loop {
        let candidate = active.join(".config/lints.toml");

        if candidate.exists() && candidate.is_file() {
            files.push(candidate);
        }

        // we do this until we reach the root of the git repo (a `.git` folder is present)
        if active.join(".git").exists() && active.join(".git").is_dir() {
            break;
        }

        // ... or we have no parent anymore
        if let Some(parent) = active.parent() {
            active = parent;
        } else {
            break;
        }
    }

    // we now apply them into a single configuration this allows for easy overwrites in child directories
    files.reverse();

    let mut lints = Lints::new();

    for file in files {
        let contents = fs::read_to_string(&file).expect(&format!("should be able to read {}", file.display()));

        let file = toml::from_str(&contents).expect(&format!("should be valid toml ({})", file.display()));
        lints.apply(file);
    }

    println!("{}", serde_json::to_string_pretty(&lints.into_file()).expect("able to serialize"))
}
'''


[tasks.clippy-collect-cargo]
private = true
script_runner = "@rust"
script = '''
//! ```cargo
//! [dependencies]
//! serde = {version = "*", features = ["derive"]}
//! serde_json = {version = "*"}
//! ```
use std::env;
use std::fs;
use std::collections::HashSet;
use std::path::PathBuf;
use serde::Serialize;

#[derive(Serialize, Default)]
struct LintFile {
    allow: HashSet<String>,
    warn: HashSet<String>,
    deny: HashSet<String>,
    forbid: HashSet<String>,
    default: HashSet<String>,
}

fn main() {
    let cwd = env::var("CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY").expect("environment variable should exist");
    let cwd = PathBuf::from(cwd);

    let path = cwd.join(".cargo/config.toml");

    if !path.exists() || !path.is_file() {
        panic!(".cargo/config.toml needs to exist")
    }

    let contents = fs::read_to_string(&path).expect(&format!("should be able to read {}", path.display()));

    // brute-force, search for the line:
    // ## START CLIPPY LINTS ##
    // and then:
    // ## END CLIPPY LINTS ##
    // take all values in between

    if !contents.contains("## START CLIPPY LINTS ##") || !contents.contains("## END CLIPPY LINTS ##") {
        panic!("malformed .cargo/config.toml, please add the required markers")
    }

    let lints = contents.lines()
        .map(|value| value.trim())
        .skip_while(|value| *value != "## START CLIPPY LINTS ##")
        .take_while(|value| *value != "## END CLIPPY LINTS ##")
        .filter(|value| !value.is_empty())
        .filter(|value| value.starts_with('"'))
        // remove leading `"` and trailing `",`
        .map(|value| &value[1..(value.len() - 2)]).fold(LintFile::default(), |mut acc, line| {
            let (arg, lint) = line.split_at(2);

            match arg {
                "-A" => acc.allow.insert(lint.to_owned()),
                "-W" => acc.warn.insert(lint.to_owned()),
                "-D" => acc.deny.insert(lint.to_owned()),
                "-F" => acc.forbid.insert(lint.to_owned()),
                _ => panic!("unrecognized rust flag {arg}")
            };

            acc
        });

    println!("{}", serde_json::to_string_pretty(&lints).expect("able to serialize"))
}
'''
