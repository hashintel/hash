#![allow(
    clippy::module_name_repetitions,
    clippy::must_use_candidate,
    clippy::cast_sign_loss,
    clippy::empty_enum,
    clippy::used_underscore_binding,
    clippy::redundant_static_lifetimes,
    clippy::redundant_field_names,
    unused_imports
)]
// automatically generated by the FlatBuffers compiler, do not modify

use std::{cmp::Ordering, mem};

use super::{
    batch_generated::*, metaversion_generated::*, package_config_generated::*,
    serialized_generated::*, shared_context_generated::*,
};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum DatastoreInitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DatastoreInit<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatastoreInit<'a> {
    type Inner = DatastoreInit<'a>;

    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatastoreInit<'a> {
    pub const VT_AGENT_BATCH_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_CONTEXT_BATCH_SCHEMA: flatbuffers::VOffsetT = 8;
    pub const VT_MESSAGE_BATCH_SCHEMA: flatbuffers::VOffsetT = 6;
    pub const VT_SHARED_CONTEXT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatastoreInit { _tab: table }
    }

    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatastoreInitArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatastoreInit<'bldr>> {
        let mut builder = DatastoreInitBuilder::new(_fbb);
        if let Some(x) = args.shared_context {
            builder.add_shared_context(x);
        }
        if let Some(x) = args.context_batch_schema {
            builder.add_context_batch_schema(x);
        }
        if let Some(x) = args.message_batch_schema {
            builder.add_message_batch_schema(x);
        }
        if let Some(x) = args.agent_batch_schema {
            builder.add_agent_batch_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn agent_batch_schema(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                DatastoreInit::VT_AGENT_BATCH_SCHEMA,
                None,
            )
            .map(|v| v.safe_slice())
    }

    #[inline]
    pub fn message_batch_schema(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                DatastoreInit::VT_MESSAGE_BATCH_SCHEMA,
                None,
            )
            .map(|v| v.safe_slice())
    }

    #[inline]
    pub fn context_batch_schema(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                DatastoreInit::VT_CONTEXT_BATCH_SCHEMA,
                None,
            )
            .map(|v| v.safe_slice())
    }

    #[inline]
    pub fn shared_context(&self) -> Option<SharedContext<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<SharedContext>>(
                DatastoreInit::VT_SHARED_CONTEXT,
                None,
            )
    }
}

impl flatbuffers::Verifiable for DatastoreInit<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                &"agent_batch_schema",
                Self::VT_AGENT_BATCH_SCHEMA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                &"message_batch_schema",
                Self::VT_MESSAGE_BATCH_SCHEMA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                &"context_batch_schema",
                Self::VT_CONTEXT_BATCH_SCHEMA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<SharedContext>>(
                &"shared_context",
                Self::VT_SHARED_CONTEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DatastoreInitArgs<'a> {
    pub agent_batch_schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub message_batch_schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub context_batch_schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub shared_context: Option<flatbuffers::WIPOffset<SharedContext<'a>>>,
}
impl<'a> Default for DatastoreInitArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatastoreInitArgs {
            agent_batch_schema: None,
            message_batch_schema: None,
            context_batch_schema: None,
            shared_context: None,
        }
    }
}
pub struct DatastoreInitBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatastoreInitBuilder<'a, 'b> {
    #[inline]
    pub fn add_agent_batch_schema(
        &mut self,
        agent_batch_schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatastoreInit::VT_AGENT_BATCH_SCHEMA,
            agent_batch_schema,
        );
    }

    #[inline]
    pub fn add_message_batch_schema(
        &mut self,
        message_batch_schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatastoreInit::VT_MESSAGE_BATCH_SCHEMA,
            message_batch_schema,
        );
    }

    #[inline]
    pub fn add_context_batch_schema(
        &mut self,
        context_batch_schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatastoreInit::VT_CONTEXT_BATCH_SCHEMA,
            context_batch_schema,
        );
    }

    #[inline]
    pub fn add_shared_context(
        &mut self,
        shared_context: flatbuffers::WIPOffset<SharedContext<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<SharedContext>>(
                DatastoreInit::VT_SHARED_CONTEXT,
                shared_context,
            );
    }

    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatastoreInitBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatastoreInitBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }

    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatastoreInit<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for DatastoreInit<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("DatastoreInit");
        ds.field("agent_batch_schema", &self.agent_batch_schema());
        ds.field("message_batch_schema", &self.message_batch_schema());
        ds.field("context_batch_schema", &self.context_batch_schema());
        ds.field("shared_context", &self.shared_context());
        ds.finish()
    }
}
pub enum NewSimulationRunOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NewSimulationRun<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewSimulationRun<'a> {
    type Inner = NewSimulationRun<'a>;

    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> NewSimulationRun<'a> {
    pub const VT_DATASTORE_INIT: flatbuffers::VOffsetT = 12;
    pub const VT_GLOBALS: flatbuffers::VOffsetT = 8;
    pub const VT_PACKAGE_CONFIG: flatbuffers::VOffsetT = 10;
    pub const VT_SID: flatbuffers::VOffsetT = 6;
    pub const VT_SIM_ID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NewSimulationRun { _tab: table }
    }

    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NewSimulationRunArgs<'args>,
    ) -> flatbuffers::WIPOffset<NewSimulationRun<'bldr>> {
        let mut builder = NewSimulationRunBuilder::new(_fbb);
        if let Some(x) = args.datastore_init {
            builder.add_datastore_init(x);
        }
        if let Some(x) = args.package_config {
            builder.add_package_config(x);
        }
        if let Some(x) = args.globals {
            builder.add_globals(x);
        }
        builder.add_sid(args.sid);
        if let Some(x) = args.sim_id {
            builder.add_sim_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn sim_id(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(NewSimulationRun::VT_SIM_ID, None)
            .unwrap()
    }

    #[inline]
    pub fn sid(&self) -> u32 {
        self._tab
            .get::<u32>(NewSimulationRun::VT_SID, Some(0))
            .unwrap()
    }

    #[inline]
    pub fn globals(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(NewSimulationRun::VT_GLOBALS, None)
            .unwrap()
    }

    #[inline]
    pub fn package_config(&self) -> PackageConfig<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<PackageConfig>>(
                NewSimulationRun::VT_PACKAGE_CONFIG,
                None,
            )
            .unwrap()
    }

    #[inline]
    pub fn datastore_init(&self) -> DatastoreInit<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatastoreInit>>(
                NewSimulationRun::VT_DATASTORE_INIT,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for NewSimulationRun<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"sim_id", Self::VT_SIM_ID, true)?
            .visit_field::<u32>(&"sid", Self::VT_SID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"globals", Self::VT_GLOBALS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<PackageConfig>>(
                &"package_config",
                Self::VT_PACKAGE_CONFIG,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DatastoreInit>>(
                &"datastore_init",
                Self::VT_DATASTORE_INIT,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct NewSimulationRunArgs<'a> {
    pub sim_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sid: u32,
    pub globals: Option<flatbuffers::WIPOffset<&'a str>>,
    pub package_config: Option<flatbuffers::WIPOffset<PackageConfig<'a>>>,
    pub datastore_init: Option<flatbuffers::WIPOffset<DatastoreInit<'a>>>,
}
impl<'a> Default for NewSimulationRunArgs<'a> {
    #[inline]
    fn default() -> Self {
        NewSimulationRunArgs {
            sim_id: None, // required field
            sid: 0,
            globals: None,        // required field
            package_config: None, // required field
            datastore_init: None, // required field
        }
    }
}
pub struct NewSimulationRunBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewSimulationRunBuilder<'a, 'b> {
    #[inline]
    pub fn add_sim_id(&mut self, sim_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(NewSimulationRun::VT_SIM_ID, sim_id);
    }

    #[inline]
    pub fn add_sid(&mut self, sid: u32) {
        self.fbb_.push_slot::<u32>(NewSimulationRun::VT_SID, sid, 0);
    }

    #[inline]
    pub fn add_globals(&mut self, globals: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(NewSimulationRun::VT_GLOBALS, globals);
    }

    #[inline]
    pub fn add_package_config(
        &mut self,
        package_config: flatbuffers::WIPOffset<PackageConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<PackageConfig>>(
                NewSimulationRun::VT_PACKAGE_CONFIG,
                package_config,
            );
    }

    #[inline]
    pub fn add_datastore_init(
        &mut self,
        datastore_init: flatbuffers::WIPOffset<DatastoreInit<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatastoreInit>>(
                NewSimulationRun::VT_DATASTORE_INIT,
                datastore_init,
            );
    }

    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> NewSimulationRunBuilder<'a, 'b> {
        let start = _fbb.start_table();
        NewSimulationRunBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }

    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<NewSimulationRun<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, NewSimulationRun::VT_SIM_ID, "sim_id");
        self.fbb_
            .required(o, NewSimulationRun::VT_GLOBALS, "globals");
        self.fbb_
            .required(o, NewSimulationRun::VT_PACKAGE_CONFIG, "package_config");
        self.fbb_
            .required(o, NewSimulationRun::VT_DATASTORE_INIT, "datastore_init");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for NewSimulationRun<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("NewSimulationRun");
        ds.field("sim_id", &self.sim_id());
        ds.field("sid", &self.sid());
        ds.field("globals", &self.globals());
        ds.field("package_config", &self.package_config());
        ds.field("datastore_init", &self.datastore_init());
        ds.finish()
    }
}
#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_new_simulation_run<'a>(buf: &'a [u8]) -> NewSimulationRun<'a> {
    unsafe { flatbuffers::root_unchecked::<NewSimulationRun<'a>>(buf) }
}

#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_new_simulation_run<'a>(buf: &'a [u8]) -> NewSimulationRun<'a> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<NewSimulationRun<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `NewSimulationRun`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_new_simulation_run_unchecked`.
pub fn root_as_new_simulation_run(
    buf: &[u8],
) -> Result<NewSimulationRun, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<NewSimulationRun>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `NewSimulationRun` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_new_simulation_run_unchecked`.
pub fn size_prefixed_root_as_new_simulation_run(
    buf: &[u8],
) -> Result<NewSimulationRun, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<NewSimulationRun>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `NewSimulationRun` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_new_simulation_run_unchecked`.
pub fn root_as_new_simulation_run_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<NewSimulationRun<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<NewSimulationRun<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `NewSimulationRun` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_new_simulation_run_unchecked`.
pub fn size_prefixed_root_as_new_simulation_run_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<NewSimulationRun<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<NewSimulationRun<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a NewSimulationRun and returns
/// it. # Safety
/// Callers must trust the given bytes do indeed contain a valid `NewSimulationRun`.
pub unsafe fn root_as_new_simulation_run_unchecked(buf: &[u8]) -> NewSimulationRun {
    flatbuffers::root_unchecked::<NewSimulationRun>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed NewSimulationRun
/// and returns it. # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `NewSimulationRun`.
pub unsafe fn size_prefixed_root_as_new_simulation_run_unchecked(buf: &[u8]) -> NewSimulationRun {
    flatbuffers::size_prefixed_root_unchecked::<NewSimulationRun>(buf)
}
#[inline]
pub fn finish_new_simulation_run_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<NewSimulationRun<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_new_simulation_run_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<NewSimulationRun<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
