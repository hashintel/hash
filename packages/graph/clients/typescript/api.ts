/* tslint:disable */
/* eslint-disable */
/**
 * graph
 * HASH Graph API
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AllFilter
 */
export interface AllFilter {
  /**
   *
   * @type {Array<Filter>}
   * @memberof AllFilter
   */
  all: Array<Filter>;
}
/**
 *
 * @export
 * @interface AnyFilter
 */
export interface AnyFilter {
  /**
   *
   * @type {Array<Filter>}
   * @memberof AnyFilter
   */
  any: Array<Filter>;
}
/**
 *
 * @export
 * @interface CreateDataTypeRequest
 */
export interface CreateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateDataTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateDataTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {DataType}
   * @memberof CreateDataTypeRequest
   */
  schema: DataType;
}
/**
 *
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityTypeId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityUuid?: string;
  /**
   *
   * @type {LinkData}
   * @memberof CreateEntityRequest
   */
  linkData?: LinkData;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  ownedById: string;
  /**
   *
   * @type {object}
   * @memberof CreateEntityRequest
   */
  properties: object;
}
/**
 *
 * @export
 * @interface CreateEntityTypeRequest
 */
export interface CreateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {EntityType}
   * @memberof CreateEntityTypeRequest
   */
  schema: EntityType;
}
/**
 *
 * @export
 * @interface CreatePropertyTypeRequest
 */
export interface CreatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePropertyTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {PropertyType}
   * @memberof CreatePropertyTypeRequest
   */
  schema: PropertyType;
}
/**
 * Specifies the structure of a Data Type
 * @export
 * @interface DataType
 */
export interface DataType {
  [key: string]: any;

  /**
   *
   * @type {object}
   * @memberof DataType
   */
  kind: DataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  type: string;
}

export const DataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type DataTypeKindEnum =
  typeof DataTypeKindEnum[keyof typeof DataTypeKindEnum];

/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const DataTypeQueryToken = {
  BaseUri: "baseUri",
  Version: "version",
  VersionedUri: "versionedUri",
  OwnedById: "ownedById",
  UpdatedById: "updatedById",
  Title: "title",
  Description: "description",
  Type: "type",
} as const;

export type DataTypeQueryToken =
  typeof DataTypeQueryToken[keyof typeof DataTypeQueryToken];

/**
 *
 * @export
 * @interface DataTypeReference
 */
export interface DataTypeReference {
  /**
   *
   * @type {string}
   * @memberof DataTypeReference
   */
  $ref: string;
}
/**
 *
 * @export
 * @interface DataTypeReferenceUpdate
 */
export interface DataTypeReferenceUpdate {
  /**
   *
   * @type {string}
   * @memberof DataTypeReferenceUpdate
   */
  $ref: string;
}
/**
 * Structural queries are the main entry point to read data from the Graph.  They are used to query the graph for a set of vertices and edges that match a set of filters. Alongside the filters, the query can specify the depth of the query, which determines how many edges the query will follow from the root vertices. The root vertices are determined by the filters. For example, if the query is for all entities of a certain type, the root vertices will be the entities of that type.  # Filters  [`Filter`]s are used to specify which root vertices to include in the query. They consist of a variety of different types of filters, which are described in the [`Filter`] documentation. At the leaf level, filters are composed of [`RecordPath`]s and [`Parameter`]s, which identify the root vertices to include in the query.  Each [`RecordPath`] is a sequence of tokens, which are used to traverse the graph. For example, a `StructuralQuery<Entity>` with the path `[\"type\", \"version\"]` will traverse the graph from an entity to its type to the version. When associating the above path with a [`Parameter`] with the value `1` in an equality filter, the query will return all entities whose type has version `1` as a root vertex.  Depending on the type of the [`StructuralQuery`], different [`RecordPath`]s are valid. Please see the documentation on the implementation of [`Record::QueryPath`] for the valid paths for each type.  # Depth  The depth of a query determines how many edges the query will follow from the root vertices. For an in-depth explanation of the depth of a query, please see the documentation on [`GraphResolveDepths`].  # Examples  Typically, a structural will be deserialized from a JSON request. The following examples assume, that the type of the request body is `StructuralQuery<Entity>`.  This will return all entities with the latest version of the `foo` type:  ```json { \"filter\": { \"all\": [ { \"equal\": [ { \"path\": [\"type\", \"baseUri\"] }, { \"parameter\": \"foo\" } ] }, { \"equal\": [ { \"path\": [\"type\", \"version\"] }, { \"parameter\": \"latest\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } ```  This query will return any entity, which was either created by or is owned by the account `12345678-90ab-cdef-1234-567890abcdef`:  ```json { \"filter\": { \"any\": [ { \"equal\": [ { \"path\": [\"updatedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] }, { \"equal\": [ { \"path\": [\"ownedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } } ```  [`RecordPath`]: crate::store::query::QueryPath [`Parameter`]: crate::store::query::Parameter
 * @export
 * @interface DataTypeStructuralQuery
 */
export interface DataTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof DataTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof DataTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {UnresolvedTimeProjection}
   * @memberof DataTypeStructuralQuery
   */
  timeProjection?: UnresolvedTimeProjection;
}
/**
 *
 * @export
 * @interface DataTypeWithMetadata
 */
export interface DataTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof DataTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {DataType}
   * @memberof DataTypeWithMetadata
   */
  schema: DataType;
}
/**
 * Time axis for the decision time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const DecisionTime = {
  Decision: "decision",
} as const;

export type DecisionTime = typeof DecisionTime[keyof typeof DecisionTime];

/**
 *
 * @export
 * @interface DecisionTimeImage
 */
export interface DecisionTimeImage {
  /**
   *
   * @type {DecisionTime}
   * @memberof DecisionTimeImage
   */
  axis: DecisionTime;
  /**
   *
   * @type {TimespanBound}
   * @memberof DecisionTimeImage
   */
  end: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof DecisionTimeImage
   */
  start: TimespanBound;
}
/**
 *
 * @export
 * @interface DecisionTimeImageAllOf
 */
export interface DecisionTimeImageAllOf {
  /**
   *
   * @type {DecisionTime}
   * @memberof DecisionTimeImageAllOf
   */
  axis: DecisionTime;
}
/**
 *
 * @export
 * @interface DecisionTimeImageAllOf1
 */
export interface DecisionTimeImageAllOf1 {
  /**
   *
   * @type {TimespanBound}
   * @memberof DecisionTimeImageAllOf1
   */
  end: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof DecisionTimeImageAllOf1
   */
  start: TimespanBound;
}
/**
 *
 * @export
 * @interface DecisionTimeKernel
 */
export interface DecisionTimeKernel {
  /**
   *
   * @type {DecisionTime}
   * @memberof DecisionTimeKernel
   */
  axis: DecisionTime;
  /**
   *
   * @type {string}
   * @memberof DecisionTimeKernel
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface DecisionTimeProjection
 */
export interface DecisionTimeProjection {
  /**
   *
   * @type {DecisionTimeImage}
   * @memberof DecisionTimeProjection
   */
  image: DecisionTimeImage;
  /**
   *
   * @type {TransactionTimeKernel}
   * @memberof DecisionTimeProjection
   */
  kernel: TransactionTimeKernel;
}
/**
 *
 * @export
 * @interface EdgeResolveDepths
 */
export interface EdgeResolveDepths {
  /**
   *
   * @type {number}
   * @memberof EdgeResolveDepths
   */
  incoming: number;
  /**
   *
   * @type {number}
   * @memberof EdgeResolveDepths
   */
  outgoing: number;
}
/**
 *
 * @export
 * @interface Edges
 */
export interface Edges {
  [key: string]: { [key: string]: Array<EdgesValueValueInner> };
}
/**
 * @type EdgesValueValueInner
 * @export
 */
export type EdgesValueValueInner =
  | KnowledgeGraphOutwardEdges
  | OntologyOutwardEdges;

/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated metadata.
 * @export
 * @interface Entity
 */
export interface Entity {
  /**
   *
   * @type {LinkData}
   * @memberof Entity
   */
  linkData?: LinkData;
  /**
   *
   * @type {EntityMetadata}
   * @memberof Entity
   */
  metadata: EntityMetadata;
  /**
   *
   * @type {object}
   * @memberof Entity
   */
  properties: object;
}
/**
 *
 * @export
 * @interface EntityEditionId
 */
export interface EntityEditionId {
  /**
   *
   * @type {string}
   * @memberof EntityEditionId
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof EntityEditionId
   */
  recordId: number;
}
/**
 *
 * @export
 * @interface EntityIdAndTimestamp
 */
export interface EntityIdAndTimestamp {
  /**
   *
   * @type {string}
   * @memberof EntityIdAndTimestamp
   */
  baseId: string;
  /**
   *
   * @type {string}
   * @memberof EntityIdAndTimestamp
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface EntityLinkOrder
 */
export interface EntityLinkOrder {
  /**
   *
   * @type {number}
   * @memberof EntityLinkOrder
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof EntityLinkOrder
   */
  rightToLeftOrder?: number;
}
/**
 * The metadata of an [`Entity`] record.
 * @export
 * @interface EntityMetadata
 */
export interface EntityMetadata {
  /**
   *
   * @type {boolean}
   * @memberof EntityMetadata
   */
  archived: boolean;
  /**
   *
   * @type {EntityEditionId}
   * @memberof EntityMetadata
   */
  editionId: EntityEditionId;
  /**
   *
   * @type {string}
   * @memberof EntityMetadata
   */
  entityTypeId: string;
  /**
   *
   * @type {ProvenanceMetadata}
   * @memberof EntityMetadata
   */
  provenance: ProvenanceMetadata;
  /**
   *
   * @type {EntityVersion}
   * @memberof EntityMetadata
   */
  version: EntityVersion;
}
/**
 * A single token in an [`EntityQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityQueryToken = {
  Uuid: "uuid",
  Version: "version",
  RecordId: "recordId",
  Archived: "archived",
  OwnedById: "ownedById",
  UpdatedById: "updatedById",
  Type: "type",
  Properties: "properties",
  IncomingLinks: "incomingLinks",
  OutgoingLinks: "outgoingLinks",
  LeftEntity: "leftEntity",
  RightEntity: "rightEntity",
  LeftToRightOrder: "leftToRightOrder",
  RightToLeftOrder: "rightToLeftOrder",
} as const;

export type EntityQueryToken =
  typeof EntityQueryToken[keyof typeof EntityQueryToken];

/**
 * Structural queries are the main entry point to read data from the Graph.  They are used to query the graph for a set of vertices and edges that match a set of filters. Alongside the filters, the query can specify the depth of the query, which determines how many edges the query will follow from the root vertices. The root vertices are determined by the filters. For example, if the query is for all entities of a certain type, the root vertices will be the entities of that type.  # Filters  [`Filter`]s are used to specify which root vertices to include in the query. They consist of a variety of different types of filters, which are described in the [`Filter`] documentation. At the leaf level, filters are composed of [`RecordPath`]s and [`Parameter`]s, which identify the root vertices to include in the query.  Each [`RecordPath`] is a sequence of tokens, which are used to traverse the graph. For example, a `StructuralQuery<Entity>` with the path `[\"type\", \"version\"]` will traverse the graph from an entity to its type to the version. When associating the above path with a [`Parameter`] with the value `1` in an equality filter, the query will return all entities whose type has version `1` as a root vertex.  Depending on the type of the [`StructuralQuery`], different [`RecordPath`]s are valid. Please see the documentation on the implementation of [`Record::QueryPath`] for the valid paths for each type.  # Depth  The depth of a query determines how many edges the query will follow from the root vertices. For an in-depth explanation of the depth of a query, please see the documentation on [`GraphResolveDepths`].  # Examples  Typically, a structural will be deserialized from a JSON request. The following examples assume, that the type of the request body is `StructuralQuery<Entity>`.  This will return all entities with the latest version of the `foo` type:  ```json { \"filter\": { \"all\": [ { \"equal\": [ { \"path\": [\"type\", \"baseUri\"] }, { \"parameter\": \"foo\" } ] }, { \"equal\": [ { \"path\": [\"type\", \"version\"] }, { \"parameter\": \"latest\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } ```  This query will return any entity, which was either created by or is owned by the account `12345678-90ab-cdef-1234-567890abcdef`:  ```json { \"filter\": { \"any\": [ { \"equal\": [ { \"path\": [\"updatedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] }, { \"equal\": [ { \"path\": [\"ownedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } } ```  [`RecordPath`]: crate::store::query::QueryPath [`Parameter`]: crate::store::query::Parameter
 * @export
 * @interface EntityStructuralQuery
 */
export interface EntityStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof EntityStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof EntityStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {UnresolvedTimeProjection}
   * @memberof EntityStructuralQuery
   */
  timeProjection?: UnresolvedTimeProjection;
}
/**
 * Specifies the structure of an Entity Type
 * @export
 * @interface EntityType
 */
export interface EntityType {
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  kind: EntityTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  $id: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  type: EntityTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  default?: object;
  /**
   *
   * @type {Array<object>}
   * @memberof EntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  links?: object;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityType
   */
  requiredLinks?: Array<string>;
}

export const EntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type EntityTypeKindEnum =
  typeof EntityTypeKindEnum[keyof typeof EntityTypeKindEnum];
export const EntityTypeTypeEnum = {
  Object: "object",
} as const;

export type EntityTypeTypeEnum =
  typeof EntityTypeTypeEnum[keyof typeof EntityTypeTypeEnum];

/**
 * A single token in a [`EntityTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityTypeQueryToken = {
  BaseUri: "baseUri",
  Version: "version",
  VersionedUri: "versionedUri",
  OwnedById: "ownedById",
  UpdatedById: "updatedById",
  Title: "title",
  Description: "description",
  Default: "default",
  Examples: "examples",
  Properties: "properties",
  Required: "required",
  Links: "links",
  RequiredLinks: "requiredLinks",
  InheritsFrom: "inheritsFrom",
} as const;

export type EntityTypeQueryToken =
  typeof EntityTypeQueryToken[keyof typeof EntityTypeQueryToken];

/**
 * Structural queries are the main entry point to read data from the Graph.  They are used to query the graph for a set of vertices and edges that match a set of filters. Alongside the filters, the query can specify the depth of the query, which determines how many edges the query will follow from the root vertices. The root vertices are determined by the filters. For example, if the query is for all entities of a certain type, the root vertices will be the entities of that type.  # Filters  [`Filter`]s are used to specify which root vertices to include in the query. They consist of a variety of different types of filters, which are described in the [`Filter`] documentation. At the leaf level, filters are composed of [`RecordPath`]s and [`Parameter`]s, which identify the root vertices to include in the query.  Each [`RecordPath`] is a sequence of tokens, which are used to traverse the graph. For example, a `StructuralQuery<Entity>` with the path `[\"type\", \"version\"]` will traverse the graph from an entity to its type to the version. When associating the above path with a [`Parameter`] with the value `1` in an equality filter, the query will return all entities whose type has version `1` as a root vertex.  Depending on the type of the [`StructuralQuery`], different [`RecordPath`]s are valid. Please see the documentation on the implementation of [`Record::QueryPath`] for the valid paths for each type.  # Depth  The depth of a query determines how many edges the query will follow from the root vertices. For an in-depth explanation of the depth of a query, please see the documentation on [`GraphResolveDepths`].  # Examples  Typically, a structural will be deserialized from a JSON request. The following examples assume, that the type of the request body is `StructuralQuery<Entity>`.  This will return all entities with the latest version of the `foo` type:  ```json { \"filter\": { \"all\": [ { \"equal\": [ { \"path\": [\"type\", \"baseUri\"] }, { \"parameter\": \"foo\" } ] }, { \"equal\": [ { \"path\": [\"type\", \"version\"] }, { \"parameter\": \"latest\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } ```  This query will return any entity, which was either created by or is owned by the account `12345678-90ab-cdef-1234-567890abcdef`:  ```json { \"filter\": { \"any\": [ { \"equal\": [ { \"path\": [\"updatedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] }, { \"equal\": [ { \"path\": [\"ownedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } } ```  [`RecordPath`]: crate::store::query::QueryPath [`Parameter`]: crate::store::query::Parameter
 * @export
 * @interface EntityTypeStructuralQuery
 */
export interface EntityTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof EntityTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof EntityTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {UnresolvedTimeProjection}
   * @memberof EntityTypeStructuralQuery
   */
  timeProjection?: UnresolvedTimeProjection;
}
/**
 *
 * @export
 * @interface EntityTypeWithMetadata
 */
export interface EntityTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof EntityTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {EntityType}
   * @memberof EntityTypeWithMetadata
   */
  schema: EntityType;
}
/**
 *
 * @export
 * @interface EntityVersion
 */
export interface EntityVersion {
  /**
   *
   * @type {VersionTimespan}
   * @memberof EntityVersion
   */
  decisionTime: VersionTimespan;
  /**
   *
   * @type {VersionTimespan}
   * @memberof EntityVersion
   */
  transactionTime: VersionTimespan;
}
/**
 *
 * @export
 * @interface EntityVertexId
 */
export interface EntityVertexId {
  /**
   *
   * @type {string}
   * @memberof EntityVertexId
   */
  baseId: string;
  /**
   *
   * @type {string}
   * @memberof EntityVertexId
   */
  version: string;
}
/**
 *
 * @export
 * @interface EqualFilter
 */
export interface EqualFilter {
  /**
   *
   * @type {Array<FilterExpression>}
   * @memberof EqualFilter
   */
  equal: Array<FilterExpression>;
}
/**
 * @type Filter
 * @export
 */
export type Filter =
  | AllFilter
  | AnyFilter
  | EqualFilter
  | NotEqualFilter
  | NotFilter;

/**
 * @type FilterExpression
 * @export
 */
export type FilterExpression = ParameterExpression | PathExpression;

/**
 * @type GraphElementId
 * @export
 */
export type GraphElementId = string;

/**
 * @type GraphElementVertexId
 * @export
 */
export type GraphElementVertexId = EntityVertexId | OntologyTypeEditionId;

/**
 * TODO: DOC - <https://app.asana.com/0/0/1203438518991188/f>
 * @export
 * @interface GraphResolveDepths
 */
export interface GraphResolveDepths {
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsLinkDestinationsOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsLinksOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsPropertiesOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsValuesOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {EdgeResolveDepths}
   * @memberof GraphResolveDepths
   */
  hasLeftEntity: EdgeResolveDepths;
  /**
   *
   * @type {EdgeResolveDepths}
   * @memberof GraphResolveDepths
   */
  hasRightEntity: EdgeResolveDepths;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  inheritsFrom: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  isOfType: OutgoingEdgeResolveDepth;
}
/**
 *
 * @export
 * @enum {string}
 */

export const KnowledgeGraphEdgeKind = {
  LeftEntity: "HAS_LEFT_ENTITY",
  RightEntity: "HAS_RIGHT_ENTITY",
} as const;

export type KnowledgeGraphEdgeKind =
  typeof KnowledgeGraphEdgeKind[keyof typeof KnowledgeGraphEdgeKind];

/**
 * @type KnowledgeGraphOutwardEdges
 * @export
 */
export type KnowledgeGraphOutwardEdges =
  | KnowledgeGraphOutwardEdgesOneOf
  | KnowledgeGraphOutwardEdgesOneOf1;

/**
 *
 * @export
 * @interface KnowledgeGraphOutwardEdgesOneOf
 */
export interface KnowledgeGraphOutwardEdgesOneOf {
  /**
   *
   * @type {string}
   * @memberof KnowledgeGraphOutwardEdgesOneOf
   */
  kind: KnowledgeGraphOutwardEdgesOneOfKindEnum;
  /**
   *
   * @type {boolean}
   * @memberof KnowledgeGraphOutwardEdgesOneOf
   */
  reversed: boolean;
  /**
   *
   * @type {KnowledgeGraphOutwardEdgesOneOfRightEndpoint}
   * @memberof KnowledgeGraphOutwardEdgesOneOf
   */
  rightEndpoint: KnowledgeGraphOutwardEdgesOneOfRightEndpoint;
}

export const KnowledgeGraphOutwardEdgesOneOfKindEnum = {
  LeftEntity: "HAS_LEFT_ENTITY",
  RightEntity: "HAS_RIGHT_ENTITY",
} as const;

export type KnowledgeGraphOutwardEdgesOneOfKindEnum =
  typeof KnowledgeGraphOutwardEdgesOneOfKindEnum[keyof typeof KnowledgeGraphOutwardEdgesOneOfKindEnum];

/**
 *
 * @export
 * @interface KnowledgeGraphOutwardEdgesOneOf1
 */
export interface KnowledgeGraphOutwardEdgesOneOf1 {
  /**
   *
   * @type {string}
   * @memberof KnowledgeGraphOutwardEdgesOneOf1
   */
  kind: KnowledgeGraphOutwardEdgesOneOf1KindEnum;
  /**
   *
   * @type {boolean}
   * @memberof KnowledgeGraphOutwardEdgesOneOf1
   */
  reversed: boolean;
  /**
   *
   * @type {KnowledgeGraphOutwardEdgesOneOf1RightEndpoint}
   * @memberof KnowledgeGraphOutwardEdgesOneOf1
   */
  rightEndpoint: KnowledgeGraphOutwardEdgesOneOf1RightEndpoint;
}

export const KnowledgeGraphOutwardEdgesOneOf1KindEnum = {
  IsOfType: "IS_OF_TYPE",
} as const;

export type KnowledgeGraphOutwardEdgesOneOf1KindEnum =
  typeof KnowledgeGraphOutwardEdgesOneOf1KindEnum[keyof typeof KnowledgeGraphOutwardEdgesOneOf1KindEnum];

/**
 *
 * @export
 * @interface KnowledgeGraphOutwardEdgesOneOf1RightEndpoint
 */
export interface KnowledgeGraphOutwardEdgesOneOf1RightEndpoint {
  /**
   *
   * @type {string}
   * @memberof KnowledgeGraphOutwardEdgesOneOf1RightEndpoint
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof KnowledgeGraphOutwardEdgesOneOf1RightEndpoint
   */
  version: number;
}
/**
 *
 * @export
 * @interface KnowledgeGraphOutwardEdgesOneOfRightEndpoint
 */
export interface KnowledgeGraphOutwardEdgesOneOfRightEndpoint {
  /**
   *
   * @type {string}
   * @memberof KnowledgeGraphOutwardEdgesOneOfRightEndpoint
   */
  baseId: string;
  /**
   *
   * @type {string}
   * @memberof KnowledgeGraphOutwardEdgesOneOfRightEndpoint
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface KnowledgeGraphRootedEdges
 */
export interface KnowledgeGraphRootedEdges {
  [key: string]: { [key: string]: Array<KnowledgeGraphOutwardEdges> };
}
/**
 * @type KnowledgeGraphVertex
 * @export
 */
export type KnowledgeGraphVertex = KnowledgeGraphVertexOneOf;

/**
 *
 * @export
 * @interface KnowledgeGraphVertexOneOf
 */
export interface KnowledgeGraphVertexOneOf {
  /**
   *
   * @type {KnowledgeGraphVertexOneOfInner}
   * @memberof KnowledgeGraphVertexOneOf
   */
  inner: KnowledgeGraphVertexOneOfInner;
  /**
   *
   * @type {object}
   * @memberof KnowledgeGraphVertexOneOf
   */
  kind: KnowledgeGraphVertexOneOfKindEnum;
}

export const KnowledgeGraphVertexOneOfKindEnum = {
  Entity: "entity",
} as const;

export type KnowledgeGraphVertexOneOfKindEnum =
  typeof KnowledgeGraphVertexOneOfKindEnum[keyof typeof KnowledgeGraphVertexOneOfKindEnum];

/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated metadata.
 * @export
 * @interface KnowledgeGraphVertexOneOfInner
 */
export interface KnowledgeGraphVertexOneOfInner {
  /**
   *
   * @type {LinkData}
   * @memberof KnowledgeGraphVertexOneOfInner
   */
  linkData?: LinkData;
  /**
   *
   * @type {EntityMetadata}
   * @memberof KnowledgeGraphVertexOneOfInner
   */
  metadata: EntityMetadata;
  /**
   *
   * @type {object}
   * @memberof KnowledgeGraphVertexOneOfInner
   */
  properties: object;
}
/**
 *
 * @export
 * @interface KnowledgeGraphVertices
 */
export interface KnowledgeGraphVertices {
  [key: string]: { [key: string]: KnowledgeGraphVertex };
}
/**
 * The associated information for \'Link\' entities
 * @export
 * @interface LinkData
 */
export interface LinkData {
  /**
   *
   * @type {number}
   * @memberof LinkData
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof LinkData
   */
  rightToLeftOrder?: number;
  /**
   *
   * @type {string}
   * @memberof LinkData
   */
  leftEntityId: string;
  /**
   *
   * @type {string}
   * @memberof LinkData
   */
  rightEntityId: string;
}
/**
 *
 * @export
 * @interface LinkDataAllOf
 */
export interface LinkDataAllOf {
  /**
   *
   * @type {string}
   * @memberof LinkDataAllOf
   */
  leftEntityId: string;
  /**
   *
   * @type {string}
   * @memberof LinkDataAllOf
   */
  rightEntityId: string;
}
/**
 *
 * @export
 * @interface NotEqualFilter
 */
export interface NotEqualFilter {
  /**
   *
   * @type {Array<FilterExpression>}
   * @memberof NotEqualFilter
   */
  notEqual: Array<FilterExpression>;
}
/**
 *
 * @export
 * @interface NotFilter
 */
export interface NotFilter {
  /**
   *
   * @type {Filter}
   * @memberof NotFilter
   */
  not: Filter;
}
/**
 *
 * @export
 * @enum {string}
 */

export const OntologyEdgeKind = {
  InheritsFrom: "INHERITS_FROM",
  ConstrainsValuesOn: "CONSTRAINS_VALUES_ON",
  ConstrainsPropertiesOn: "CONSTRAINS_PROPERTIES_ON",
  ConstrainsLinksOn: "CONSTRAINS_LINKS_ON",
  ConstrainsLinkDestinationsOn: "CONSTRAINS_LINK_DESTINATIONS_ON",
} as const;

export type OntologyEdgeKind =
  typeof OntologyEdgeKind[keyof typeof OntologyEdgeKind];

/**
 *
 * @export
 * @interface OntologyElementMetadata
 */
export interface OntologyElementMetadata {
  /**
   *
   * @type {OntologyTypeEditionId}
   * @memberof OntologyElementMetadata
   */
  editionId: OntologyTypeEditionId;
  /**
   *
   * @type {string}
   * @memberof OntologyElementMetadata
   */
  ownedById: string;
  /**
   *
   * @type {ProvenanceMetadata}
   * @memberof OntologyElementMetadata
   */
  provenance: ProvenanceMetadata;
}
/**
 * @type OntologyOutwardEdges
 * @export
 */
export type OntologyOutwardEdges =
  | OntologyOutwardEdgesOneOf
  | OntologyOutwardEdgesOneOf1;

/**
 *
 * @export
 * @interface OntologyOutwardEdgesOneOf
 */
export interface OntologyOutwardEdgesOneOf {
  /**
   *
   * @type {string}
   * @memberof OntologyOutwardEdgesOneOf
   */
  kind: OntologyOutwardEdgesOneOfKindEnum;
  /**
   *
   * @type {boolean}
   * @memberof OntologyOutwardEdgesOneOf
   */
  reversed: boolean;
  /**
   *
   * @type {KnowledgeGraphOutwardEdgesOneOf1RightEndpoint}
   * @memberof OntologyOutwardEdgesOneOf
   */
  rightEndpoint: KnowledgeGraphOutwardEdgesOneOf1RightEndpoint;
}

export const OntologyOutwardEdgesOneOfKindEnum = {
  InheritsFrom: "INHERITS_FROM",
  ConstrainsValuesOn: "CONSTRAINS_VALUES_ON",
  ConstrainsPropertiesOn: "CONSTRAINS_PROPERTIES_ON",
  ConstrainsLinksOn: "CONSTRAINS_LINKS_ON",
  ConstrainsLinkDestinationsOn: "CONSTRAINS_LINK_DESTINATIONS_ON",
} as const;

export type OntologyOutwardEdgesOneOfKindEnum =
  typeof OntologyOutwardEdgesOneOfKindEnum[keyof typeof OntologyOutwardEdgesOneOfKindEnum];

/**
 *
 * @export
 * @interface OntologyOutwardEdgesOneOf1
 */
export interface OntologyOutwardEdgesOneOf1 {
  /**
   *
   * @type {string}
   * @memberof OntologyOutwardEdgesOneOf1
   */
  kind: OntologyOutwardEdgesOneOf1KindEnum;
  /**
   *
   * @type {boolean}
   * @memberof OntologyOutwardEdgesOneOf1
   */
  reversed: boolean;
  /**
   *
   * @type {OntologyOutwardEdgesOneOf1RightEndpoint}
   * @memberof OntologyOutwardEdgesOneOf1
   */
  rightEndpoint: OntologyOutwardEdgesOneOf1RightEndpoint;
}

export const OntologyOutwardEdgesOneOf1KindEnum = {
  IsOfType: "IS_OF_TYPE",
} as const;

export type OntologyOutwardEdgesOneOf1KindEnum =
  typeof OntologyOutwardEdgesOneOf1KindEnum[keyof typeof OntologyOutwardEdgesOneOf1KindEnum];

/**
 *
 * @export
 * @interface OntologyOutwardEdgesOneOf1RightEndpoint
 */
export interface OntologyOutwardEdgesOneOf1RightEndpoint {
  /**
   *
   * @type {string}
   * @memberof OntologyOutwardEdgesOneOf1RightEndpoint
   */
  baseId: string;
  /**
   *
   * @type {string}
   * @memberof OntologyOutwardEdgesOneOf1RightEndpoint
   */
  version: string;
}
/**
 *
 * @export
 * @interface OntologyRootedEdges
 */
export interface OntologyRootedEdges {
  [key: string]: { [key: string]: Array<OntologyOutwardEdges> };
}
/**
 *
 * @export
 * @interface OntologyTypeEditionId
 */
export interface OntologyTypeEditionId {
  /**
   *
   * @type {string}
   * @memberof OntologyTypeEditionId
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof OntologyTypeEditionId
   */
  version: number;
}
/**
 * @type OntologyVertex
 * @export
 */
export type OntologyVertex =
  | OntologyVertexOneOf
  | OntologyVertexOneOf1
  | OntologyVertexOneOf2;

/**
 *
 * @export
 * @interface OntologyVertexOneOf
 */
export interface OntologyVertexOneOf {
  /**
   *
   * @type {OntologyVertexOneOfInner}
   * @memberof OntologyVertexOneOf
   */
  inner: OntologyVertexOneOfInner;
  /**
   *
   * @type {object}
   * @memberof OntologyVertexOneOf
   */
  kind: OntologyVertexOneOfKindEnum;
}

export const OntologyVertexOneOfKindEnum = {
  DataType: "dataType",
} as const;

export type OntologyVertexOneOfKindEnum =
  typeof OntologyVertexOneOfKindEnum[keyof typeof OntologyVertexOneOfKindEnum];

/**
 *
 * @export
 * @interface OntologyVertexOneOf1
 */
export interface OntologyVertexOneOf1 {
  /**
   *
   * @type {OntologyVertexOneOf1Inner}
   * @memberof OntologyVertexOneOf1
   */
  inner: OntologyVertexOneOf1Inner;
  /**
   *
   * @type {object}
   * @memberof OntologyVertexOneOf1
   */
  kind: OntologyVertexOneOf1KindEnum;
}

export const OntologyVertexOneOf1KindEnum = {
  PropertyType: "propertyType",
} as const;

export type OntologyVertexOneOf1KindEnum =
  typeof OntologyVertexOneOf1KindEnum[keyof typeof OntologyVertexOneOf1KindEnum];

/**
 *
 * @export
 * @interface OntologyVertexOneOf1Inner
 */
export interface OntologyVertexOneOf1Inner {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof OntologyVertexOneOf1Inner
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {PropertyType}
   * @memberof OntologyVertexOneOf1Inner
   */
  schema: PropertyType;
}
/**
 *
 * @export
 * @interface OntologyVertexOneOf2
 */
export interface OntologyVertexOneOf2 {
  /**
   *
   * @type {OntologyVertexOneOf2Inner}
   * @memberof OntologyVertexOneOf2
   */
  inner: OntologyVertexOneOf2Inner;
  /**
   *
   * @type {object}
   * @memberof OntologyVertexOneOf2
   */
  kind: OntologyVertexOneOf2KindEnum;
}

export const OntologyVertexOneOf2KindEnum = {
  EntityType: "entityType",
} as const;

export type OntologyVertexOneOf2KindEnum =
  typeof OntologyVertexOneOf2KindEnum[keyof typeof OntologyVertexOneOf2KindEnum];

/**
 *
 * @export
 * @interface OntologyVertexOneOf2Inner
 */
export interface OntologyVertexOneOf2Inner {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof OntologyVertexOneOf2Inner
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {EntityType}
   * @memberof OntologyVertexOneOf2Inner
   */
  schema: EntityType;
}
/**
 *
 * @export
 * @interface OntologyVertexOneOfInner
 */
export interface OntologyVertexOneOfInner {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof OntologyVertexOneOfInner
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {DataType}
   * @memberof OntologyVertexOneOfInner
   */
  schema: DataType;
}
/**
 *
 * @export
 * @interface OntologyVertices
 */
export interface OntologyVertices {
  [key: string]: { [key: string]: OntologyVertex };
}
/**
 *
 * @export
 * @interface OutgoingEdgeResolveDepth
 */
export interface OutgoingEdgeResolveDepth {
  /**
   *
   * @type {number}
   * @memberof OutgoingEdgeResolveDepth
   */
  outgoing: number;
}
/**
 *
 * @export
 * @interface ParameterExpression
 */
export interface ParameterExpression {
  /**
   *
   * @type {boolean | number | string}
   * @memberof ParameterExpression
   */
  parameter: boolean | number | string;
}
/**
 *
 * @export
 * @interface PathExpression
 */
export interface PathExpression {
  /**
   *
   * @type {Array<DataTypeQueryToken | PropertyTypeQueryToken | EntityTypeQueryToken | EntityQueryToken | Selector | string>}
   * @memberof PathExpression
   */
  path: Array<
    | DataTypeQueryToken
    | PropertyTypeQueryToken
    | EntityTypeQueryToken
    | EntityQueryToken
    | Selector
    | string
  >;
}
/**
 *
 * @export
 * @interface PropertyArrayValue
 */
export interface PropertyArrayValue {
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValue
   */
  type: PropertyArrayValueTypeEnum;
  /**
   *
   * @type {PropertyArrayValueItems}
   * @memberof PropertyArrayValue
   */
  items: PropertyArrayValueItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  minItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  maxItems?: number;
}

export const PropertyArrayValueTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueTypeEnum =
  typeof PropertyArrayValueTypeEnum[keyof typeof PropertyArrayValueTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueItems
 */
export interface PropertyArrayValueItems {
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyArrayValueItems
   */
  oneOf: Array<PropertyValues>;
}
/**
 *
 * @export
 * @interface PropertyArrayValueUpdate
 */
export interface PropertyArrayValueUpdate {
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValueUpdate
   */
  type: PropertyArrayValueUpdateTypeEnum;
  /**
   *
   * @type {PropertyArrayValueUpdateItems}
   * @memberof PropertyArrayValueUpdate
   */
  items: PropertyArrayValueUpdateItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  minItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  maxItems?: number;
}

export const PropertyArrayValueUpdateTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueUpdateTypeEnum =
  typeof PropertyArrayValueUpdateTypeEnum[keyof typeof PropertyArrayValueUpdateTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueUpdateItems
 */
export interface PropertyArrayValueUpdateItems {
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof PropertyArrayValueUpdateItems
   */
  oneOf: Array<PropertyValuesUpdate>;
}
/**
 *
 * @export
 * @interface PropertyObjectValue
 */
export interface PropertyObjectValue {
  /**
   *
   * @type {string}
   * @memberof PropertyObjectValue
   */
  type: PropertyObjectValueTypeEnum;
  /**
   *
   * @type {object}
   * @memberof PropertyObjectValue
   */
  properties: object;
}

export const PropertyObjectValueTypeEnum = {
  Object: "object",
} as const;

export type PropertyObjectValueTypeEnum =
  typeof PropertyObjectValueTypeEnum[keyof typeof PropertyObjectValueTypeEnum];

/**
 * Specifies the structure of a Property Type
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
  /**
   *
   * @type {object}
   * @memberof PropertyType
   */
  kind: PropertyTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  description?: string;
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyType
   */
  oneOf: Array<PropertyValues>;
}

export const PropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type PropertyTypeKindEnum =
  typeof PropertyTypeKindEnum[keyof typeof PropertyTypeKindEnum];

/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const PropertyTypeQueryToken = {
  BaseUri: "baseUri",
  Version: "version",
  VersionedUri: "versionedUri",
  OwnedById: "ownedById",
  UpdatedById: "updatedById",
  Title: "title",
  Description: "description",
  DataTypes: "dataTypes",
  PropertyTypes: "propertyTypes",
} as const;

export type PropertyTypeQueryToken =
  typeof PropertyTypeQueryToken[keyof typeof PropertyTypeQueryToken];

/**
 * Structural queries are the main entry point to read data from the Graph.  They are used to query the graph for a set of vertices and edges that match a set of filters. Alongside the filters, the query can specify the depth of the query, which determines how many edges the query will follow from the root vertices. The root vertices are determined by the filters. For example, if the query is for all entities of a certain type, the root vertices will be the entities of that type.  # Filters  [`Filter`]s are used to specify which root vertices to include in the query. They consist of a variety of different types of filters, which are described in the [`Filter`] documentation. At the leaf level, filters are composed of [`RecordPath`]s and [`Parameter`]s, which identify the root vertices to include in the query.  Each [`RecordPath`] is a sequence of tokens, which are used to traverse the graph. For example, a `StructuralQuery<Entity>` with the path `[\"type\", \"version\"]` will traverse the graph from an entity to its type to the version. When associating the above path with a [`Parameter`] with the value `1` in an equality filter, the query will return all entities whose type has version `1` as a root vertex.  Depending on the type of the [`StructuralQuery`], different [`RecordPath`]s are valid. Please see the documentation on the implementation of [`Record::QueryPath`] for the valid paths for each type.  # Depth  The depth of a query determines how many edges the query will follow from the root vertices. For an in-depth explanation of the depth of a query, please see the documentation on [`GraphResolveDepths`].  # Examples  Typically, a structural will be deserialized from a JSON request. The following examples assume, that the type of the request body is `StructuralQuery<Entity>`.  This will return all entities with the latest version of the `foo` type:  ```json { \"filter\": { \"all\": [ { \"equal\": [ { \"path\": [\"type\", \"baseUri\"] }, { \"parameter\": \"foo\" } ] }, { \"equal\": [ { \"path\": [\"type\", \"version\"] }, { \"parameter\": \"latest\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } ```  This query will return any entity, which was either created by or is owned by the account `12345678-90ab-cdef-1234-567890abcdef`:  ```json { \"filter\": { \"any\": [ { \"equal\": [ { \"path\": [\"updatedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] }, { \"equal\": [ { \"path\": [\"ownedById\"] }, { \"parameter\": \"12345678-90ab-cdef-1234-567890abcdef\" } ] } ] }, \"graphResolveDepths\": { \"inheritsFrom\": { \"outgoing\": 0 }, \"constrainsValuesOn\": { \"outgoing\": 0 }, \"constrainsPropertiesOn\": { \"outgoing\": 0 }, \"constrainsLinksOn\": { \"outgoing\": 0 }, \"constrainsLinkDestinationsOn\": { \"outgoing\": 0 }, \"isOfType\": { \"outgoing\": 0 }, \"hasLeftEntity\": { \"incoming\": 2, \"outgoing\": 2 }, \"hasRightEntity\": { \"incoming\": 2, \"outgoing\": 2 } } } ```  [`RecordPath`]: crate::store::query::QueryPath [`Parameter`]: crate::store::query::Parameter
 * @export
 * @interface PropertyTypeStructuralQuery
 */
export interface PropertyTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof PropertyTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof PropertyTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {UnresolvedTimeProjection}
   * @memberof PropertyTypeStructuralQuery
   */
  timeProjection?: UnresolvedTimeProjection;
}
/**
 *
 * @export
 * @interface PropertyTypeWithMetadata
 */
export interface PropertyTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof PropertyTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {PropertyType}
   * @memberof PropertyTypeWithMetadata
   */
  schema: PropertyType;
}
/**
 * @type PropertyValues
 * @export
 */
export type PropertyValues =
  | DataTypeReference
  | PropertyArrayValue
  | PropertyObjectValue;

/**
 * @type PropertyValuesUpdate
 * @export
 */
export type PropertyValuesUpdate =
  | DataTypeReferenceUpdate
  | PropertyArrayValueUpdate
  | PropertyObjectValue;

/**
 *
 * @export
 * @interface ProvenanceMetadata
 */
export interface ProvenanceMetadata {
  /**
   *
   * @type {string}
   * @memberof ProvenanceMetadata
   */
  updatedById: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Selector = {
  Star: "*",
} as const;

export type Selector = typeof Selector[keyof typeof Selector];

/**
 *
 * @export
 * @enum {string}
 */

export const SharedEdgeKind = {
  IsOfType: "IS_OF_TYPE",
} as const;

export type SharedEdgeKind = typeof SharedEdgeKind[keyof typeof SharedEdgeKind];

/**
 *
 * @export
 * @interface Subgraph
 */
export interface Subgraph {
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof Subgraph
   */
  depths: GraphResolveDepths;
  /**
   *
   * @type {Edges}
   * @memberof Subgraph
   */
  edges: Edges;
  /**
   *
   * @type {TimeProjection}
   * @memberof Subgraph
   */
  resolvedTimeProjection: TimeProjection;
  /**
   *
   * @type {Array<GraphElementVertexId>}
   * @memberof Subgraph
   */
  roots: Array<GraphElementVertexId>;
  /**
   *
   * @type {UnresolvedTimeProjection}
   * @memberof Subgraph
   */
  timeProjection: UnresolvedTimeProjection;
  /**
   *
   * @type {Vertices}
   * @memberof Subgraph
   */
  vertices: Vertices;
}
/**
 * @type TimeProjection
 * @export
 */
export type TimeProjection = DecisionTimeProjection | TransactionTimeProjection;

/**
 * @type TimespanBound
 * @export
 */
export type TimespanBound = TimespanBoundOneOf | TimespanBoundOneOf1;

/**
 *
 * @export
 * @interface TimespanBoundOneOf
 */
export interface TimespanBoundOneOf {
  /**
   *
   * @type {object}
   * @memberof TimespanBoundOneOf
   */
  bound: TimespanBoundOneOfBoundEnum;
}

export const TimespanBoundOneOfBoundEnum = {
  Unbounded: "unbounded",
} as const;

export type TimespanBoundOneOfBoundEnum =
  typeof TimespanBoundOneOfBoundEnum[keyof typeof TimespanBoundOneOfBoundEnum];

/**
 *
 * @export
 * @interface TimespanBoundOneOf1
 */
export interface TimespanBoundOneOf1 {
  /**
   *
   * @type {object}
   * @memberof TimespanBoundOneOf1
   */
  bound: TimespanBoundOneOf1BoundEnum;
  /**
   *
   * @type {string}
   * @memberof TimespanBoundOneOf1
   */
  timestamp: string;
}

export const TimespanBoundOneOf1BoundEnum = {
  Included: "included",
  Excluded: "excluded",
} as const;

export type TimespanBoundOneOf1BoundEnum =
  typeof TimespanBoundOneOf1BoundEnum[keyof typeof TimespanBoundOneOf1BoundEnum];

/**
 * Time axis for the transaction time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const TransactionTime = {
  Transaction: "transaction",
} as const;

export type TransactionTime =
  typeof TransactionTime[keyof typeof TransactionTime];

/**
 *
 * @export
 * @interface TransactionTimeImage
 */
export interface TransactionTimeImage {
  /**
   *
   * @type {TransactionTime}
   * @memberof TransactionTimeImage
   */
  axis: TransactionTime;
  /**
   *
   * @type {TimespanBound}
   * @memberof TransactionTimeImage
   */
  end: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof TransactionTimeImage
   */
  start: TimespanBound;
}
/**
 *
 * @export
 * @interface TransactionTimeImageAllOf
 */
export interface TransactionTimeImageAllOf {
  /**
   *
   * @type {TransactionTime}
   * @memberof TransactionTimeImageAllOf
   */
  axis: TransactionTime;
}
/**
 *
 * @export
 * @interface TransactionTimeKernel
 */
export interface TransactionTimeKernel {
  /**
   *
   * @type {TransactionTime}
   * @memberof TransactionTimeKernel
   */
  axis: TransactionTime;
  /**
   *
   * @type {string}
   * @memberof TransactionTimeKernel
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface TransactionTimeProjection
 */
export interface TransactionTimeProjection {
  /**
   *
   * @type {TransactionTimeImage}
   * @memberof TransactionTimeProjection
   */
  image: TransactionTimeImage;
  /**
   *
   * @type {DecisionTimeKernel}
   * @memberof TransactionTimeProjection
   */
  kernel: DecisionTimeKernel;
}
/**
 *
 * @export
 * @interface UnresolvedDecisionTimeImage
 */
export interface UnresolvedDecisionTimeImage {
  /**
   *
   * @type {DecisionTime}
   * @memberof UnresolvedDecisionTimeImage
   */
  axis: DecisionTime;
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedDecisionTimeImage
   */
  end?: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedDecisionTimeImage
   */
  start?: TimespanBound;
}
/**
 *
 * @export
 * @interface UnresolvedDecisionTimeImageAllOf
 */
export interface UnresolvedDecisionTimeImageAllOf {
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedDecisionTimeImageAllOf
   */
  end?: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedDecisionTimeImageAllOf
   */
  start?: TimespanBound;
}
/**
 *
 * @export
 * @interface UnresolvedDecisionTimeKernel
 */
export interface UnresolvedDecisionTimeKernel {
  /**
   *
   * @type {DecisionTime}
   * @memberof UnresolvedDecisionTimeKernel
   */
  axis: DecisionTime;
  /**
   *
   * @type {string}
   * @memberof UnresolvedDecisionTimeKernel
   */
  timestamp?: string;
}
/**
 *
 * @export
 * @interface UnresolvedDecisionTimeProjection
 */
export interface UnresolvedDecisionTimeProjection {
  /**
   *
   * @type {UnresolvedDecisionTimeImage}
   * @memberof UnresolvedDecisionTimeProjection
   */
  image: UnresolvedDecisionTimeImage;
  /**
   *
   * @type {UnresolvedTransactionTimeKernel}
   * @memberof UnresolvedDecisionTimeProjection
   */
  kernel: UnresolvedTransactionTimeKernel;
}
/**
 * @type UnresolvedTimeProjection
 * @export
 */
export type UnresolvedTimeProjection =
  | UnresolvedDecisionTimeProjection
  | UnresolvedTransactionTimeProjection;

/**
 *
 * @export
 * @interface UnresolvedTransactionTimeImage
 */
export interface UnresolvedTransactionTimeImage {
  /**
   *
   * @type {TransactionTime}
   * @memberof UnresolvedTransactionTimeImage
   */
  axis: TransactionTime;
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedTransactionTimeImage
   */
  end?: TimespanBound;
  /**
   *
   * @type {TimespanBound}
   * @memberof UnresolvedTransactionTimeImage
   */
  start?: TimespanBound;
}
/**
 *
 * @export
 * @interface UnresolvedTransactionTimeKernel
 */
export interface UnresolvedTransactionTimeKernel {
  /**
   *
   * @type {TransactionTime}
   * @memberof UnresolvedTransactionTimeKernel
   */
  axis: TransactionTime;
  /**
   *
   * @type {string}
   * @memberof UnresolvedTransactionTimeKernel
   */
  timestamp?: string;
}
/**
 *
 * @export
 * @interface UnresolvedTransactionTimeProjection
 */
export interface UnresolvedTransactionTimeProjection {
  /**
   *
   * @type {UnresolvedTransactionTimeImage}
   * @memberof UnresolvedTransactionTimeProjection
   */
  image: UnresolvedTransactionTimeImage;
  /**
   *
   * @type {UnresolvedDecisionTimeKernel}
   * @memberof UnresolvedTransactionTimeProjection
   */
  kernel: UnresolvedDecisionTimeKernel;
}
/**
 * The contents of a Data Type update request
 * @export
 * @interface UpdateDataType
 */
export interface UpdateDataType {
  [key: string]: any;

  /**
   *
   * @type {object}
   * @memberof UpdateDataType
   */
  kind: UpdateDataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  type: string;
}

export const UpdateDataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type UpdateDataTypeKindEnum =
  typeof UpdateDataTypeKindEnum[keyof typeof UpdateDataTypeKindEnum];

/**
 *
 * @export
 * @interface UpdateDataTypeRequest
 */
export interface UpdateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdateDataType}
   * @memberof UpdateDataTypeRequest
   */
  schema: UpdateDataType;
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  typeToUpdate: string;
}
/**
 *
 * @export
 * @interface UpdateEntityRequest
 */
export interface UpdateEntityRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateEntityRequest
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof UpdateEntityRequest
   */
  rightToLeftOrder?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  actorId: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateEntityRequest
   */
  archived: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityTypeId: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityRequest
   */
  properties: object;
}
/**
 *
 * @export
 * @interface UpdateEntityRequestAllOf
 */
export interface UpdateEntityRequestAllOf {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  actorId: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateEntityRequestAllOf
   */
  archived: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  entityTypeId: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityRequestAllOf
   */
  properties: object;
}
/**
 * The contents of an Entity Type update request
 * @export
 * @interface UpdateEntityType
 */
export interface UpdateEntityType {
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  kind: UpdateEntityTypeKindEnum;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  type: UpdateEntityTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  default?: object;
  /**
   *
   * @type {Array<object>}
   * @memberof UpdateEntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateEntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  links?: object;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateEntityType
   */
  requiredLinks?: Array<string>;
}

export const UpdateEntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type UpdateEntityTypeKindEnum =
  typeof UpdateEntityTypeKindEnum[keyof typeof UpdateEntityTypeKindEnum];
export const UpdateEntityTypeTypeEnum = {
  Object: "object",
} as const;

export type UpdateEntityTypeTypeEnum =
  typeof UpdateEntityTypeTypeEnum[keyof typeof UpdateEntityTypeTypeEnum];

/**
 *
 * @export
 * @interface UpdateEntityTypeRequest
 */
export interface UpdateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdateEntityType}
   * @memberof UpdateEntityTypeRequest
   */
  schema: UpdateEntityType;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  typeToUpdate: string;
}
/**
 * The contents of a Property Type update request
 * @export
 * @interface UpdatePropertyType
 */
export interface UpdatePropertyType {
  /**
   *
   * @type {object}
   * @memberof UpdatePropertyType
   */
  kind: UpdatePropertyTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  description?: string;
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof UpdatePropertyType
   */
  oneOf: Array<PropertyValuesUpdate>;
}

export const UpdatePropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type UpdatePropertyTypeKindEnum =
  typeof UpdatePropertyTypeKindEnum[keyof typeof UpdatePropertyTypeKindEnum];

/**
 *
 * @export
 * @interface UpdatePropertyTypeRequest
 */
export interface UpdatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdatePropertyType}
   * @memberof UpdatePropertyTypeRequest
   */
  schema: UpdatePropertyType;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  typeToUpdate: string;
}
/**
 *
 * @export
 * @interface VersionTimespan
 */
export interface VersionTimespan {
  /**
   *
   * @type {string}
   * @memberof VersionTimespan
   */
  end?: string;
  /**
   *
   * @type {string}
   * @memberof VersionTimespan
   */
  start: string;
}
/**
 * @type Vertex
 * @export
 */
export type Vertex = KnowledgeGraphVertex | OntologyVertex;

/**
 *
 * @export
 * @interface Vertices
 */
export interface Vertices {
  [key: string]: { [key: string]: VerticesValueValue };
}
/**
 * @type VerticesValueValue
 * @export
 */
export type VerticesValueValue = KnowledgeGraphVertex | OntologyVertex;

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataTypeApi - axios parameter creator
 * @export
 */
export const DataTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "dataTypeStructuralQuery",
        dataTypeStructuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataTypeApi - functional programming interface
 * @export
 */
export const DataTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          dataTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DataTypeApi - factory interface
 * @export
 */
export const DataTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DataTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(dataTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataTypeApi - interface
 * @export
 * @interface DataTypeApi
 */
export interface DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * DataTypeApi - object-oriented interface
 * @export
 * @class DataTypeApi
 * @extends {BaseAPI}
 */
export class DataTypeApi extends BaseAPI implements DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .getDataTypesByQuery(dataTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      entityStructuralQuery: EntityStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "entityStructuralQuery",
        entityStructuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          entityStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntitiesByQuery(entityStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityApi - interface
 * @export
 * @interface EntityApi
 */
export interface EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;
}

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI implements EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .getEntitiesByQuery(entityStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityTypeApi - axios parameter creator
 * @export
 */
export const EntityTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "entityTypeStructuralQuery",
        entityTypeStructuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityTypeApi - functional programming interface
 * @export
 */
export const EntityTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EntityTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          entityTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityTypeApi - factory interface
 * @export
 */
export const EntityTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntityTypesByQuery(entityTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityTypeApi - interface
 * @export
 * @interface EntityTypeApi
 */
export interface EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * EntityTypeApi - object-oriented interface
 * @export
 * @class EntityTypeApi
 * @extends {BaseAPI}
 */
export class EntityTypeApi extends BaseAPI implements EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .getEntityTypesByQuery(entityTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "dataTypeStructuralQuery",
        dataTypeStructuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      entityStructuralQuery: EntityStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "entityStructuralQuery",
        entityStructuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "entityTypeStructuralQuery",
        entityTypeStructuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'propertyTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "propertyTypeStructuralQuery",
        propertyTypeStructuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          dataTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          entityStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          entityTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          propertyTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(dataTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntitiesByQuery(entityStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntityTypesByQuery(entityTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphApi - interface
 * @export
 * @interface GraphApi
 */
export interface GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI implements GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getDataTypesByQuery(dataTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntitiesByQuery(entityStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntityTypesByQuery(entityTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyTypeApi - axios parameter creator
 * @export
 */
export const PropertyTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'propertyTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "propertyTypeStructuralQuery",
        propertyTypeStructuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyTypeApi - functional programming interface
 * @export
 */
export const PropertyTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PropertyTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          propertyTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PropertyTypeApi - factory interface
 * @export
 */
export const PropertyTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PropertyTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PropertyTypeApi - interface
 * @export
 * @interface PropertyTypeApi
 */
export interface PropertyTypeApiInterface {
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * PropertyTypeApi - object-oriented interface
 * @export
 * @class PropertyTypeApi
 * @extends {BaseAPI}
 */
export class PropertyTypeApi
  extends BaseAPI
  implements PropertyTypeApiInterface
{
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
