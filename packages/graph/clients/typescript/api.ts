/* tslint:disable */
/* eslint-disable */
/**
 * graph
 * HASH Graph API
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact:
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface CreateDataTypeRequest
 */
export interface CreateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateDataTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {DataType}
   * @memberof CreateDataTypeRequest
   */
  schema: DataType;
}
/**
 *
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  accountId: string;
  /**
   *
   * @type {object}
   * @memberof CreateEntityRequest
   */
  entity: object;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityTypeId: string;
}
/**
 *
 * @export
 * @interface CreateEntityTypeRequest
 */
export interface CreateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {EntityType}
   * @memberof CreateEntityTypeRequest
   */
  schema: EntityType;
}
/**
 *
 * @export
 * @interface CreateLinkRequest
 */
export interface CreateLinkRequest {
  /**
   *
   * @type {number}
   * @memberof CreateLinkRequest
   */
  index?: number;
  /**
   *
   * @type {string}
   * @memberof CreateLinkRequest
   */
  linkTypeId: string;
  /**
   *
   * @type {string}
   * @memberof CreateLinkRequest
   */
  ownedById: string;
  /**
   *
   * @type {string}
   * @memberof CreateLinkRequest
   */
  targetEntityId: string;
}
/**
 *
 * @export
 * @interface CreateLinkTypeRequest
 */
export interface CreateLinkTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateLinkTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {LinkType}
   * @memberof CreateLinkTypeRequest
   */
  schema: LinkType;
}
/**
 *
 * @export
 * @interface CreatePropertyTypeRequest
 */
export interface CreatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePropertyTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {PropertyType}
   * @memberof CreatePropertyTypeRequest
   */
  schema: PropertyType;
}
/**
 * Specifies the structure of a Data Type
 * @export
 * @interface DataType
 */
export interface DataType {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof DataType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof DataType
   */
  kind: DataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  type: string;
}

export const DataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type DataTypeKindEnum =
  typeof DataTypeKindEnum[keyof typeof DataTypeKindEnum];

/**
 *
 * @export
 * @interface DataTypeReference
 */
export interface DataTypeReference {
  /**
   *
   * @type {string}
   * @memberof DataTypeReference
   */
  $ref: string;
}
/**
 *
 * @export
 * @interface DataTypeReferenceUpdate
 */
export interface DataTypeReferenceUpdate {
  /**
   *
   * @type {string}
   * @memberof DataTypeReferenceUpdate
   */
  $ref: string;
}
/**
 *
 * @export
 * @interface DataTypeRootedSubgraph
 */
export interface DataTypeRootedSubgraph {
  /**
   *
   * @type {PersistedDataType}
   * @memberof DataTypeRootedSubgraph
   */
  dataType: PersistedDataType;
}
/**
 *
 * @export
 * @enum {string}
 */

export const EdgeKind = {
  HasLink: "HAS_LINK",
  HasDestination: "HAS_DESTINATION",
  HasType: "HAS_TYPE",
  References: "REFERENCES",
} as const;

export type EdgeKind = typeof EdgeKind[keyof typeof EdgeKind];

/**
 *
 * @export
 * @interface EntityRootedSubgraph
 */
export interface EntityRootedSubgraph {
  /**
   *
   * @type {PersistedEntity}
   * @memberof EntityRootedSubgraph
   */
  entity: PersistedEntity;
  /**
   *
   * @type {Array<PersistedEntity>}
   * @memberof EntityRootedSubgraph
   */
  linkedEntities: Array<PersistedEntity>;
  /**
   *
   * @type {Array<PersistedLink>}
   * @memberof EntityRootedSubgraph
   */
  links: Array<PersistedLink>;
  /**
   *
   * @type {Array<PersistedDataType>}
   * @memberof EntityRootedSubgraph
   */
  referencedDataTypes: Array<PersistedDataType>;
  /**
   *
   * @type {Array<PersistedEntityType>}
   * @memberof EntityRootedSubgraph
   */
  referencedEntityTypes: Array<PersistedEntityType>;
  /**
   *
   * @type {Array<PersistedLinkType>}
   * @memberof EntityRootedSubgraph
   */
  referencedLinkTypes: Array<PersistedLinkType>;
  /**
   *
   * @type {Array<PersistedPropertyType>}
   * @memberof EntityRootedSubgraph
   */
  referencedPropertyTypes: Array<PersistedPropertyType>;
}
/**
 * Specifies the structure of an Entity Type
 * @export
 * @interface EntityType
 */
export interface EntityType {
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  $id: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  default?: object;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  description?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof EntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  kind: EntityTypeKindEnum;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  links?: object;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  pluralTitle: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityType
   */
  requiredLinks?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  title: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  type: EntityTypeTypeEnum;
}

export const EntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type EntityTypeKindEnum =
  typeof EntityTypeKindEnum[keyof typeof EntityTypeKindEnum];
export const EntityTypeTypeEnum = {
  Object: "object",
} as const;

export type EntityTypeTypeEnum =
  typeof EntityTypeTypeEnum[keyof typeof EntityTypeTypeEnum];

/**
 *
 * @export
 * @interface EntityTypeRootedSubgraph
 */
export interface EntityTypeRootedSubgraph {
  /**
   *
   * @type {PersistedEntityType}
   * @memberof EntityTypeRootedSubgraph
   */
  entityType: PersistedEntityType;
  /**
   *
   * @type {Array<PersistedDataType>}
   * @memberof EntityTypeRootedSubgraph
   */
  referencedDataTypes: Array<PersistedDataType>;
  /**
   *
   * @type {Array<PersistedEntityType>}
   * @memberof EntityTypeRootedSubgraph
   */
  referencedEntityTypes: Array<PersistedEntityType>;
  /**
   *
   * @type {Array<PersistedLinkType>}
   * @memberof EntityTypeRootedSubgraph
   */
  referencedLinkTypes: Array<PersistedLinkType>;
  /**
   *
   * @type {Array<PersistedPropertyType>}
   * @memberof EntityTypeRootedSubgraph
   */
  referencedPropertyTypes: Array<PersistedPropertyType>;
}
/**
 * @type GraphElementIdentifier
 * @export
 */
export type GraphElementIdentifier = string;

/**
 *
 * @export
 * @interface GraphResolveDepths
 */
export interface GraphResolveDepths {
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  dataTypeResolveDepth: number;
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  entityTypeResolveDepth: number;
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  linkResolveDepth: number;
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  linkTargetEntityResolveDepth: number;
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  linkTypeResolveDepth: number;
  /**
   *
   * @type {number}
   * @memberof GraphResolveDepths
   */
  propertyTypeResolveDepth: number;
}
/**
 * A Link between a source and a target entity identified by [`EntityId`]s.
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {number}
   * @memberof Link
   */
  index?: number;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  linkTypeId: string;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  sourceEntityId: string;
  /**
   *
   * @type {string}
   * @memberof Link
   */
  targetEntityId: string;
}
/**
 *
 * @export
 * @interface LinkRootedSubgraph
 */
export interface LinkRootedSubgraph {
  /**
   *
   * @type {PersistedLink}
   * @memberof LinkRootedSubgraph
   */
  link: PersistedLink;
  /**
   *
   * @type {Array<PersistedEntity>}
   * @memberof LinkRootedSubgraph
   */
  linkedEntities: Array<PersistedEntity>;
  /**
   *
   * @type {Array<PersistedLink>}
   * @memberof LinkRootedSubgraph
   */
  links: Array<PersistedLink>;
  /**
   *
   * @type {Array<PersistedDataType>}
   * @memberof LinkRootedSubgraph
   */
  referencedDataTypes: Array<PersistedDataType>;
  /**
   *
   * @type {Array<PersistedEntityType>}
   * @memberof LinkRootedSubgraph
   */
  referencedEntityTypes: Array<PersistedEntityType>;
  /**
   *
   * @type {Array<PersistedLinkType>}
   * @memberof LinkRootedSubgraph
   */
  referencedLinkTypes: Array<PersistedLinkType>;
  /**
   *
   * @type {Array<PersistedPropertyType>}
   * @memberof LinkRootedSubgraph
   */
  referencedPropertyTypes: Array<PersistedPropertyType>;
}
/**
 * Specifies the structure of a Link Type
 * @export
 * @interface LinkType
 */
export interface LinkType {
  /**
   *
   * @type {string}
   * @memberof LinkType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof LinkType
   */
  description: string;
  /**
   *
   * @type {object}
   * @memberof LinkType
   */
  kind: LinkTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof LinkType
   */
  pluralTitle: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LinkType
   */
  relatedKeywords?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LinkType
   */
  title: string;
}

export const LinkTypeKindEnum = {
  LinkType: "linkType",
} as const;

export type LinkTypeKindEnum =
  typeof LinkTypeKindEnum[keyof typeof LinkTypeKindEnum];

/**
 *
 * @export
 * @interface LinkTypeRootedSubgraph
 */
export interface LinkTypeRootedSubgraph {
  /**
   *
   * @type {PersistedLinkType}
   * @memberof LinkTypeRootedSubgraph
   */
  linkType: PersistedLinkType;
}
/**
 *
 * @export
 * @interface OutwardEdge
 */
export interface OutwardEdge {
  /**
   *
   * @type {GraphElementIdentifier}
   * @memberof OutwardEdge
   */
  destination: GraphElementIdentifier;
  /**
   *
   * @type {EdgeKind}
   * @memberof OutwardEdge
   */
  edgeKind: EdgeKind;
}
/**
 *
 * @export
 * @interface PersistedDataType
 */
export interface PersistedDataType {
  /**
   *
   * @type {DataType}
   * @memberof PersistedDataType
   */
  inner: DataType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof PersistedDataType
   */
  metadata: PersistedOntologyMetadata;
}
/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated
 * @export
 * @interface PersistedEntity
 */
export interface PersistedEntity {
  /**
   *
   * @type {object}
   * @memberof PersistedEntity
   */
  inner: object;
  /**
   *
   * @type {PersistedEntityMetadata}
   * @memberof PersistedEntity
   */
  metadata: PersistedEntityMetadata;
}
/**
 * The metadata required to uniquely identify an instance of an [`Entity`] that has been persisted
 * @export
 * @interface PersistedEntityIdentifier
 */
export interface PersistedEntityIdentifier {
  /**
   *
   * @type {string}
   * @memberof PersistedEntityIdentifier
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof PersistedEntityIdentifier
   */
  ownedById: string;
  /**
   *
   * @type {string}
   * @memberof PersistedEntityIdentifier
   */
  version: string;
}
/**
 * The metadata of an [`Entity`] record.
 * @export
 * @interface PersistedEntityMetadata
 */
export interface PersistedEntityMetadata {
  /**
   *
   * @type {string}
   * @memberof PersistedEntityMetadata
   */
  entityTypeId: string;
  /**
   *
   * @type {PersistedEntityIdentifier}
   * @memberof PersistedEntityMetadata
   */
  identifier: PersistedEntityIdentifier;
}
/**
 *
 * @export
 * @interface PersistedEntityType
 */
export interface PersistedEntityType {
  /**
   *
   * @type {EntityType}
   * @memberof PersistedEntityType
   */
  inner: EntityType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof PersistedEntityType
   */
  metadata: PersistedOntologyMetadata;
}
/**
 * A record of a [`Link`] that has been persisted in the datastore, with its associated
 * @export
 * @interface PersistedLink
 */
export interface PersistedLink {
  /**
   *
   * @type {Link}
   * @memberof PersistedLink
   */
  inner: Link;
  /**
   *
   * @type {PersistedLinkMetadata}
   * @memberof PersistedLink
   */
  metadata: PersistedLinkMetadata;
}
/**
 * The metadata of a [`Link`] record.
 * @export
 * @interface PersistedLinkMetadata
 */
export interface PersistedLinkMetadata {
  /**
   *
   * @type {string}
   * @memberof PersistedLinkMetadata
   */
  ownedById: string;
}
/**
 *
 * @export
 * @interface PersistedLinkType
 */
export interface PersistedLinkType {
  /**
   *
   * @type {LinkType}
   * @memberof PersistedLinkType
   */
  inner: LinkType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof PersistedLinkType
   */
  metadata: PersistedOntologyMetadata;
}
/**
 * The metadata required to uniquely identify an ontology element that has been persisted in the
 * @export
 * @interface PersistedOntologyIdentifier
 */
export interface PersistedOntologyIdentifier {
  /**
   *
   * @type {string}
   * @memberof PersistedOntologyIdentifier
   */
  ownedById: string;
  /**
   *
   * @type {string}
   * @memberof PersistedOntologyIdentifier
   */
  uri: string;
}
/**
 *
 * @export
 * @interface PersistedOntologyMetadata
 */
export interface PersistedOntologyMetadata {
  /**
   *
   * @type {PersistedOntologyIdentifier}
   * @memberof PersistedOntologyMetadata
   */
  identifier: PersistedOntologyIdentifier;
}
/**
 *
 * @export
 * @interface PersistedPropertyType
 */
export interface PersistedPropertyType {
  /**
   *
   * @type {PropertyType}
   * @memberof PersistedPropertyType
   */
  inner: PropertyType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof PersistedPropertyType
   */
  metadata: PersistedOntologyMetadata;
}
/**
 *
 * @export
 * @interface PropertyArrayValue
 */
export interface PropertyArrayValue {
  /**
   *
   * @type {PropertyArrayValueItems}
   * @memberof PropertyArrayValue
   */
  items: PropertyArrayValueItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  maxItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  minItems?: number;
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValue
   */
  type: PropertyArrayValueTypeEnum;
}

export const PropertyArrayValueTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueTypeEnum =
  typeof PropertyArrayValueTypeEnum[keyof typeof PropertyArrayValueTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueItems
 */
export interface PropertyArrayValueItems {
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyArrayValueItems
   */
  oneOf: Array<PropertyValues>;
}
/**
 *
 * @export
 * @interface PropertyArrayValueUpdate
 */
export interface PropertyArrayValueUpdate {
  /**
   *
   * @type {PropertyArrayValueUpdateItems}
   * @memberof PropertyArrayValueUpdate
   */
  items: PropertyArrayValueUpdateItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  maxItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  minItems?: number;
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValueUpdate
   */
  type: PropertyArrayValueUpdateTypeEnum;
}

export const PropertyArrayValueUpdateTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueUpdateTypeEnum =
  typeof PropertyArrayValueUpdateTypeEnum[keyof typeof PropertyArrayValueUpdateTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueUpdateItems
 */
export interface PropertyArrayValueUpdateItems {
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof PropertyArrayValueUpdateItems
   */
  oneOf: Array<PropertyValuesUpdate>;
}
/**
 *
 * @export
 * @interface PropertyObjectValue
 */
export interface PropertyObjectValue {
  /**
   *
   * @type {object}
   * @memberof PropertyObjectValue
   */
  properties: object;
  /**
   *
   * @type {string}
   * @memberof PropertyObjectValue
   */
  type: PropertyObjectValueTypeEnum;
}

export const PropertyObjectValueTypeEnum = {
  Object: "object",
} as const;

export type PropertyObjectValueTypeEnum =
  typeof PropertyObjectValueTypeEnum[keyof typeof PropertyObjectValueTypeEnum];

/**
 * Specifies the structure of a Property Type
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof PropertyType
   */
  kind: PropertyTypeKindEnum;
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyType
   */
  oneOf: Array<PropertyValues>;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  pluralTitle: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  title: string;
}

export const PropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type PropertyTypeKindEnum =
  typeof PropertyTypeKindEnum[keyof typeof PropertyTypeKindEnum];

/**
 * @type PropertyValues
 * @export
 */
export type PropertyValues =
  | DataTypeReference
  | PropertyArrayValue
  | PropertyObjectValue;

/**
 * @type PropertyValuesUpdate
 * @export
 */
export type PropertyValuesUpdate =
  | DataTypeReferenceUpdate
  | PropertyArrayValueUpdate
  | PropertyObjectValue;

/**
 *
 * @export
 * @interface RemoveLinkRequest
 */
export interface RemoveLinkRequest {
  /**
   *
   * @type {string}
   * @memberof RemoveLinkRequest
   */
  linkTypeId: string;
  /**
   *
   * @type {string}
   * @memberof RemoveLinkRequest
   */
  removedById: string;
  /**
   *
   * @type {string}
   * @memberof RemoveLinkRequest
   */
  targetEntityId: string;
}
/**
 * An [`Expression`] to query the datastore, recursively resolving according to the
 * @export
 * @interface StructuralQuery
 */
export interface StructuralQuery {
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof StructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {object}
   * @memberof StructuralQuery
   */
  query: object;
}
/**
 *
 * @export
 * @interface Subgraph
 */
export interface Subgraph {
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof Subgraph
   */
  depths: GraphResolveDepths;
  /**
   *
   * @type {Edges}
   * @memberof Subgraph
   */
  edges: Edges;
  /**
   *
   * @type {Array<GraphElementIdentifier>}
   * @memberof Subgraph
   */
  roots: Array<GraphElementIdentifier>;
  /**
   *
   * @type {{ [key: string]: Vertex; }}
   * @memberof Subgraph
   */
  vertices: { [key: string]: Vertex };
}
/**
 * The contents of a Data Type update request
 * @export
 * @interface UpdateDataType
 */
export interface UpdateDataType {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof UpdateDataType
   */
  kind: UpdateDataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  type: string;
}

export const UpdateDataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type UpdateDataTypeKindEnum =
  typeof UpdateDataTypeKindEnum[keyof typeof UpdateDataTypeKindEnum];

/**
 *
 * @export
 * @interface UpdateDataTypeRequest
 */
export interface UpdateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {UpdateDataType}
   * @memberof UpdateDataTypeRequest
   */
  schema: UpdateDataType;
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  typeToUpdate: string;
}
/**
 *
 * @export
 * @interface UpdateEntityRequest
 */
export interface UpdateEntityRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  accountId: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityRequest
   */
  entity: object;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityTypeId: string;
}
/**
 * The contents of an Entity Type update request
 * @export
 * @interface UpdateEntityType
 */
export interface UpdateEntityType {
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  default?: object;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  description?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof UpdateEntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  kind: UpdateEntityTypeKindEnum;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  links?: object;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  pluralTitle: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateEntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateEntityType
   */
  requiredLinks?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  title: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  type: UpdateEntityTypeTypeEnum;
}

export const UpdateEntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type UpdateEntityTypeKindEnum =
  typeof UpdateEntityTypeKindEnum[keyof typeof UpdateEntityTypeKindEnum];
export const UpdateEntityTypeTypeEnum = {
  Object: "object",
} as const;

export type UpdateEntityTypeTypeEnum =
  typeof UpdateEntityTypeTypeEnum[keyof typeof UpdateEntityTypeTypeEnum];

/**
 *
 * @export
 * @interface UpdateEntityTypeRequest
 */
export interface UpdateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {UpdateEntityType}
   * @memberof UpdateEntityTypeRequest
   */
  schema: UpdateEntityType;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  typeToUpdate: string;
}
/**
 * The contents of a Link Type update request
 * @export
 * @interface UpdateLinkType
 */
export interface UpdateLinkType {
  /**
   *
   * @type {string}
   * @memberof UpdateLinkType
   */
  description: string;
  /**
   *
   * @type {object}
   * @memberof UpdateLinkType
   */
  kind: UpdateLinkTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateLinkType
   */
  pluralTitle: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateLinkType
   */
  relatedKeywords?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateLinkType
   */
  title: string;
}

export const UpdateLinkTypeKindEnum = {
  LinkType: "linkType",
} as const;

export type UpdateLinkTypeKindEnum =
  typeof UpdateLinkTypeKindEnum[keyof typeof UpdateLinkTypeKindEnum];

/**
 *
 * @export
 * @interface UpdateLinkTypeRequest
 */
export interface UpdateLinkTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateLinkTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {UpdateLinkType}
   * @memberof UpdateLinkTypeRequest
   */
  schema: UpdateLinkType;
  /**
   *
   * @type {string}
   * @memberof UpdateLinkTypeRequest
   */
  typeToUpdate: string;
}
/**
 * The contents of a Property Type update request
 * @export
 * @interface UpdatePropertyType
 */
export interface UpdatePropertyType {
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof UpdatePropertyType
   */
  kind: UpdatePropertyTypeKindEnum;
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof UpdatePropertyType
   */
  oneOf: Array<PropertyValuesUpdate>;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  pluralTitle: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  title: string;
}

export const UpdatePropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type UpdatePropertyTypeKindEnum =
  typeof UpdatePropertyTypeKindEnum[keyof typeof UpdatePropertyTypeKindEnum];

/**
 *
 * @export
 * @interface UpdatePropertyTypeRequest
 */
export interface UpdatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  accountId: string;
  /**
   *
   * @type {UpdatePropertyType}
   * @memberof UpdatePropertyTypeRequest
   */
  schema: UpdatePropertyType;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  typeToUpdate: string;
}
/**
 * @type Vertex
 * @export
 */
export type Vertex =
  | VertexOneOf
  | VertexOneOf1
  | VertexOneOf2
  | VertexOneOf3
  | VertexOneOf4
  | VertexOneOf5;

/**
 *
 * @export
 * @interface VertexOneOf
 */
export interface VertexOneOf {
  /**
   *
   * @type {VertexOneOfInner}
   * @memberof VertexOneOf
   */
  inner: VertexOneOfInner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf
   */
  kind: VertexOneOfKindEnum;
}

export const VertexOneOfKindEnum = {
  DataType: "DATA_TYPE",
} as const;

export type VertexOneOfKindEnum =
  typeof VertexOneOfKindEnum[keyof typeof VertexOneOfKindEnum];

/**
 *
 * @export
 * @interface VertexOneOf1
 */
export interface VertexOneOf1 {
  /**
   *
   * @type {VertexOneOf1Inner}
   * @memberof VertexOneOf1
   */
  inner: VertexOneOf1Inner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf1
   */
  kind: VertexOneOf1KindEnum;
}

export const VertexOneOf1KindEnum = {
  PropertyType: "PROPERTY_TYPE",
} as const;

export type VertexOneOf1KindEnum =
  typeof VertexOneOf1KindEnum[keyof typeof VertexOneOf1KindEnum];

/**
 *
 * @export
 * @interface VertexOneOf1Inner
 */
export interface VertexOneOf1Inner {
  /**
   *
   * @type {PropertyType}
   * @memberof VertexOneOf1Inner
   */
  inner: PropertyType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof VertexOneOf1Inner
   */
  metadata: PersistedOntologyMetadata;
}
/**
 *
 * @export
 * @interface VertexOneOf2
 */
export interface VertexOneOf2 {
  /**
   *
   * @type {VertexOneOf2Inner}
   * @memberof VertexOneOf2
   */
  inner: VertexOneOf2Inner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf2
   */
  kind: VertexOneOf2KindEnum;
}

export const VertexOneOf2KindEnum = {
  LinkType: "LINK_TYPE",
} as const;

export type VertexOneOf2KindEnum =
  typeof VertexOneOf2KindEnum[keyof typeof VertexOneOf2KindEnum];

/**
 *
 * @export
 * @interface VertexOneOf2Inner
 */
export interface VertexOneOf2Inner {
  /**
   *
   * @type {LinkType}
   * @memberof VertexOneOf2Inner
   */
  inner: LinkType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof VertexOneOf2Inner
   */
  metadata: PersistedOntologyMetadata;
}
/**
 *
 * @export
 * @interface VertexOneOf3
 */
export interface VertexOneOf3 {
  /**
   *
   * @type {VertexOneOf3Inner}
   * @memberof VertexOneOf3
   */
  inner: VertexOneOf3Inner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf3
   */
  kind: VertexOneOf3KindEnum;
}

export const VertexOneOf3KindEnum = {
  EntityType: "ENTITY_TYPE",
} as const;

export type VertexOneOf3KindEnum =
  typeof VertexOneOf3KindEnum[keyof typeof VertexOneOf3KindEnum];

/**
 *
 * @export
 * @interface VertexOneOf3Inner
 */
export interface VertexOneOf3Inner {
  /**
   *
   * @type {EntityType}
   * @memberof VertexOneOf3Inner
   */
  inner: EntityType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof VertexOneOf3Inner
   */
  metadata: PersistedOntologyMetadata;
}
/**
 *
 * @export
 * @interface VertexOneOf4
 */
export interface VertexOneOf4 {
  /**
   *
   * @type {VertexOneOf4Inner}
   * @memberof VertexOneOf4
   */
  inner: VertexOneOf4Inner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf4
   */
  kind: VertexOneOf4KindEnum;
}

export const VertexOneOf4KindEnum = {
  Entity: "ENTITY",
} as const;

export type VertexOneOf4KindEnum =
  typeof VertexOneOf4KindEnum[keyof typeof VertexOneOf4KindEnum];

/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated
 * @export
 * @interface VertexOneOf4Inner
 */
export interface VertexOneOf4Inner {
  /**
   *
   * @type {object}
   * @memberof VertexOneOf4Inner
   */
  inner: object;
  /**
   *
   * @type {PersistedEntityMetadata}
   * @memberof VertexOneOf4Inner
   */
  metadata: PersistedEntityMetadata;
}
/**
 *
 * @export
 * @interface VertexOneOf5
 */
export interface VertexOneOf5 {
  /**
   *
   * @type {VertexOneOf5Inner}
   * @memberof VertexOneOf5
   */
  inner: VertexOneOf5Inner;
  /**
   *
   * @type {object}
   * @memberof VertexOneOf5
   */
  kind: VertexOneOf5KindEnum;
}

export const VertexOneOf5KindEnum = {
  Link: "LINK",
} as const;

export type VertexOneOf5KindEnum =
  typeof VertexOneOf5KindEnum[keyof typeof VertexOneOf5KindEnum];

/**
 * A record of a [`Link`] that has been persisted in the datastore, with its associated
 * @export
 * @interface VertexOneOf5Inner
 */
export interface VertexOneOf5Inner {
  /**
   *
   * @type {Link}
   * @memberof VertexOneOf5Inner
   */
  inner: Link;
  /**
   *
   * @type {PersistedLinkMetadata}
   * @memberof VertexOneOf5Inner
   */
  metadata: PersistedLinkMetadata;
}
/**
 *
 * @export
 * @interface VertexOneOfInner
 */
export interface VertexOneOfInner {
  /**
   *
   * @type {DataType}
   * @memberof VertexOneOfInner
   */
  inner: DataType;
  /**
   *
   * @type {PersistedOntologyMetadata}
   * @memberof VertexOneOfInner
   */
  metadata: PersistedOntologyMetadata;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataTypeApi - axios parameter creator
 * @export
 */
export const DataTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getDataType", "uri", uri);
      const localVarPath = `/data-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestDataTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataTypeApi - functional programming interface
 * @export
 */
export const DataTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedDataType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestDataTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedDataType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestDataTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DataTypeApi - factory interface
 * @export
 */
export const DataTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DataTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataType(uri: string, options?: any): AxiosPromise<PersistedDataType> {
      return localVarFp
        .getDataType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestDataTypes(options?: any): AxiosPromise<Array<PersistedDataType>> {
      return localVarFp
        .getLatestDataTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataTypeApi - interface
 * @export
 * @interface DataTypeApi
 */
export interface DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {string} uri The URI of the data type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  getDataType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedDataType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  getDataTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  getLatestDataTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedDataType>>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;
}

/**
 * DataTypeApi - object-oriented interface
 * @export
 * @class DataTypeApi
 * @extends {BaseAPI}
 */
export class DataTypeApi extends BaseAPI implements DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the data type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public getDataType(uri: string, options?: AxiosRequestConfig) {
    return DataTypeApiFp(this.configuration)
      .getDataType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public getDataTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .getDataTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public getLatestDataTypes(options?: AxiosRequestConfig) {
    return DataTypeApiFp(this.configuration)
      .getLatestDataTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity: async (
      entityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("getEntity", "entityId", entityId);
      const localVarPath = `/entities/{entityId}`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntities: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<EntityRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntity(
      entityId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntity>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(
        entityId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestEntities(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedEntity>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestEntities(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<PersistedEntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<EntityRootedSubgraph>> {
      return localVarFp
        .getEntitiesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity(entityId: string, options?: any): AxiosPromise<PersistedEntity> {
      return localVarFp
        .getEntity(entityId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntities(options?: any): AxiosPromise<Array<PersistedEntity>> {
      return localVarFp
        .getLatestEntities(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<PersistedEntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityApi - interface
 * @export
 * @interface EntityApi
 */
export interface EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityMetadata>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  getEntitiesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<EntityRootedSubgraph>>;

  /**
   *
   * @param {string} entityId The ID of the entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  getEntity(
    entityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntity>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  getLatestEntities(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedEntity>>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityMetadata>;
}

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI implements EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public getEntitiesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .getEntitiesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public getEntity(entityId: string, options?: AxiosRequestConfig) {
    return EntityApiFp(this.configuration)
      .getEntity(entityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public getLatestEntities(options?: AxiosRequestConfig) {
    return EntityApiFp(this.configuration)
      .getLatestEntities(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityTypeApi - axios parameter creator
 * @export
 */
export const EntityTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getEntityType", "uri", uri);
      const localVarPath = `/entity-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntityTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityTypeApi - functional programming interface
 * @export
 */
export const EntityTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EntityTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<EntityTypeRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestEntityTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedEntityType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestEntityTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityTypeApi - factory interface
 * @export
 */
export const EntityTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityType(
      uri: string,
      options?: any,
    ): AxiosPromise<PersistedEntityType> {
      return localVarFp
        .getEntityType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<EntityTypeRootedSubgraph>> {
      return localVarFp
        .getEntityTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntityTypes(
      options?: any,
    ): AxiosPromise<Array<PersistedEntityType>> {
      return localVarFp
        .getLatestEntityTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityTypeApi - interface
 * @export
 * @interface EntityTypeApi
 */
export interface EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {string} uri The URI of the entity type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  getEntityType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  getEntityTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<EntityTypeRootedSubgraph>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  getLatestEntityTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedEntityType>>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;
}

/**
 * EntityTypeApi - object-oriented interface
 * @export
 * @class EntityTypeApi
 * @extends {BaseAPI}
 */
export class EntityTypeApi extends BaseAPI implements EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the entity type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public getEntityType(uri: string, options?: AxiosRequestConfig) {
    return EntityTypeApiFp(this.configuration)
      .getEntityType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public getEntityTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .getEntityTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public getLatestEntityTypes(options?: AxiosRequestConfig) {
    return EntityTypeApiFp(this.configuration)
      .getLatestEntityTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("createLink", "entityId", entityId);
      // verify required parameter 'createLinkRequest' is not null or undefined
      assertParamExists("createLink", "createLinkRequest", createLinkRequest);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkType: async (
      createLinkTypeRequest: CreateLinkTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createLinkTypeRequest' is not null or undefined
      assertParamExists(
        "createLinkType",
        "createLinkTypeRequest",
        createLinkTypeRequest,
      );
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createLinkTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getDataType", "uri", uri);
      const localVarPath = `/data-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity: async (
      entityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("getEntity", "entityId", entityId);
      const localVarPath = `/entities/{entityId}`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityLinks: async (
      entityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("getEntityLinks", "entityId", entityId);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getEntityType", "uri", uri);
      const localVarPath = `/entity-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestDataTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntities: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntityTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestLinkTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestPropertyTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getLinkType", "uri", uri);
      const localVarPath = `/link-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getLinkTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/link-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinksByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists("getLinksByQuery", "structuralQuery", structuralQuery);
      const localVarPath = `/links/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getPropertyType", "uri", uri);
      const localVarPath = `/property-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLink: async (
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("removeLink", "entityId", entityId);
      // verify required parameter 'removeLinkRequest' is not null or undefined
      assertParamExists("removeLink", "removeLinkRequest", removeLinkRequest);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLinkType: async (
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateLinkTypeRequest' is not null or undefined
      assertParamExists(
        "updateLinkType",
        "updateLinkTypeRequest",
        updateLinkTypeRequest,
      );
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateLinkTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(
        entityId,
        createLinkRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLinkType(
      createLinkTypeRequest: CreateLinkTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkType(
        createLinkTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedDataType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<EntityRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntity(
      entityId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntity>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(
        entityId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityLinks(
      entityId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedLink>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityLinks(
        entityId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<EntityTypeRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestDataTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedDataType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestDataTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestEntities(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedEntity>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestEntities(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestEntityTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedEntityType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestEntityTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestLinkTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedLinkType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestLinkTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestPropertyTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedPropertyType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestPropertyTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinkType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedLinkType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinkTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LinkTypeRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLinkTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinksByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LinkRootedSubgraph>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLinksByQuery(
        structuralQuery,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedPropertyType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeLink(
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeLink(
        entityId,
        removeLinkRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedEntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLinkType(
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkType(
        updateLinkTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<PersistedEntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options?: any,
    ): AxiosPromise<Link> {
      return localVarFp
        .createLink(entityId, createLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkType(
      createLinkTypeRequest: CreateLinkTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createLinkType(createLinkTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the data type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataType(uri: string, options?: any): AxiosPromise<PersistedDataType> {
      return localVarFp
        .getDataType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<EntityRootedSubgraph>> {
      return localVarFp
        .getEntitiesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity(entityId: string, options?: any): AxiosPromise<PersistedEntity> {
      return localVarFp
        .getEntity(entityId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityLinks(
      entityId: string,
      options?: any,
    ): AxiosPromise<Array<PersistedLink>> {
      return localVarFp
        .getEntityLinks(entityId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the entity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityType(
      uri: string,
      options?: any,
    ): AxiosPromise<PersistedEntityType> {
      return localVarFp
        .getEntityType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<EntityTypeRootedSubgraph>> {
      return localVarFp
        .getEntityTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestDataTypes(options?: any): AxiosPromise<Array<PersistedDataType>> {
      return localVarFp
        .getLatestDataTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntities(options?: any): AxiosPromise<Array<PersistedEntity>> {
      return localVarFp
        .getLatestEntities(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestEntityTypes(
      options?: any,
    ): AxiosPromise<Array<PersistedEntityType>> {
      return localVarFp
        .getLatestEntityTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestLinkTypes(options?: any): AxiosPromise<Array<PersistedLinkType>> {
      return localVarFp
        .getLatestLinkTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestPropertyTypes(
      options?: any,
    ): AxiosPromise<Array<PersistedPropertyType>> {
      return localVarFp
        .getLatestPropertyTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkType(uri: string, options?: any): AxiosPromise<PersistedLinkType> {
      return localVarFp
        .getLinkType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<LinkTypeRootedSubgraph>> {
      return localVarFp
        .getLinkTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinksByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<LinkRootedSubgraph>> {
      return localVarFp
        .getLinksByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyType(
      uri: string,
      options?: any,
    ): AxiosPromise<PersistedPropertyType> {
      return localVarFp
        .getPropertyType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLink(
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .removeLink(entityId, removeLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<PersistedEntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLinkType(
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateLinkType(updateLinkTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphApi - interface
 * @export
 * @interface GraphApi
 */
export interface GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityMetadata>;

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {CreateLinkRequest} createLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createLink(
    entityId: string,
    createLinkRequest: CreateLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Link>;

  /**
   *
   * @param {CreateLinkTypeRequest} createLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createLinkType(
    createLinkTypeRequest: CreateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {string} uri The URI of the data type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getDataType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedDataType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getDataTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntitiesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<EntityRootedSubgraph>>;

  /**
   *
   * @param {string} entityId The ID of the entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntity(
    entityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntity>;

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntityLinks(
    entityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedLink>>;

  /**
   *
   * @param {string} uri The URI of the entity type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntityType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntityTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<EntityTypeRootedSubgraph>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLatestDataTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedDataType>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLatestEntities(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedEntity>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLatestEntityTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedEntityType>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLatestLinkTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedLinkType>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLatestPropertyTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedPropertyType>>;

  /**
   *
   * @param {string} uri The URI of the link type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLinkType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedLinkType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLinkTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<LinkTypeRootedSubgraph>>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getLinksByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<LinkRootedSubgraph>>;

  /**
   *
   * @param {string} uri The URI of the property type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getPropertyType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedPropertyType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getPropertyTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {RemoveLinkRequest} removeLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  removeLink(
    entityId: string,
    removeLinkRequest: RemoveLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedEntityMetadata>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateLinkType(
    updateLinkTypeRequest: UpdateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;
}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI implements GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {CreateLinkRequest} createLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createLink(
    entityId: string,
    createLinkRequest: CreateLinkRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createLink(entityId, createLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateLinkTypeRequest} createLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createLinkType(
    createLinkTypeRequest: CreateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createLinkType(createLinkTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the data type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getDataType(uri: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getDataType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getDataTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getDataTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntitiesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntitiesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntity(entityId: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getEntity(entityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntityLinks(entityId: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getEntityLinks(entityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the entity type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntityType(uri: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getEntityType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntityTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntityTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLatestDataTypes(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLatestDataTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLatestEntities(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLatestEntities(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLatestEntityTypes(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLatestEntityTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLatestLinkTypes(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLatestLinkTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLatestPropertyTypes(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLatestPropertyTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the link type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLinkType(uri: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getLinkType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLinkTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getLinkTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getLinksByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getLinksByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the property type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getPropertyType(uri: string, options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .getPropertyType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getPropertyTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getPropertyTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {RemoveLinkRequest} removeLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public removeLink(
    entityId: string,
    removeLinkRequest: RemoveLinkRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .removeLink(entityId, removeLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateLinkType(
    updateLinkTypeRequest: UpdateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateLinkType(updateLinkTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("createLink", "entityId", entityId);
      // verify required parameter 'createLinkRequest' is not null or undefined
      assertParamExists("createLink", "createLinkRequest", createLinkRequest);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityLinks: async (
      entityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("getEntityLinks", "entityId", entityId);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinksByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists("getLinksByQuery", "structuralQuery", structuralQuery);
      const localVarPath = `/links/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLink: async (
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityId' is not null or undefined
      assertParamExists("removeLink", "entityId", entityId);
      // verify required parameter 'removeLinkRequest' is not null or undefined
      assertParamExists("removeLink", "removeLinkRequest", removeLinkRequest);
      const localVarPath = `/entities/{entityId}/links`.replace(
        `{${"entityId"}}`,
        encodeURIComponent(String(entityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(
        entityId,
        createLinkRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityLinks(
      entityId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedLink>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityLinks(
        entityId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinksByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LinkRootedSubgraph>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLinksByQuery(
        structuralQuery,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeLink(
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeLink(
        entityId,
        removeLinkRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LinkApiFp(configuration);
  return {
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {CreateLinkRequest} createLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(
      entityId: string,
      createLinkRequest: CreateLinkRequest,
      options?: any,
    ): AxiosPromise<Link> {
      return localVarFp
        .createLink(entityId, createLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityLinks(
      entityId: string,
      options?: any,
    ): AxiosPromise<Array<PersistedLink>> {
      return localVarFp
        .getEntityLinks(entityId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinksByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<LinkRootedSubgraph>> {
      return localVarFp
        .getLinksByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} entityId The ID of the source entity
     * @param {RemoveLinkRequest} removeLinkRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLink(
      entityId: string,
      removeLinkRequest: RemoveLinkRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .removeLink(entityId, removeLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {CreateLinkRequest} createLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLink(
    entityId: string,
    createLinkRequest: CreateLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Link>;

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  getEntityLinks(
    entityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedLink>>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  getLinksByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<LinkRootedSubgraph>>;

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {RemoveLinkRequest} removeLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  removeLink(
    entityId: string,
    removeLinkRequest: RemoveLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<void>;
}

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI implements LinkApiInterface {
  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {CreateLinkRequest} createLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLink(
    entityId: string,
    createLinkRequest: CreateLinkRequest,
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .createLink(entityId, createLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public getEntityLinks(entityId: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .getEntityLinks(entityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public getLinksByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .getLinksByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} entityId The ID of the source entity
   * @param {RemoveLinkRequest} removeLinkRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public removeLink(
    entityId: string,
    removeLinkRequest: RemoveLinkRequest,
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .removeLink(entityId, removeLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinkTypeApi - axios parameter creator
 * @export
 */
export const LinkTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkType: async (
      createLinkTypeRequest: CreateLinkTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createLinkTypeRequest' is not null or undefined
      assertParamExists(
        "createLinkType",
        "createLinkTypeRequest",
        createLinkTypeRequest,
      );
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createLinkTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestLinkTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getLinkType", "uri", uri);
      const localVarPath = `/link-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getLinkTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/link-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLinkType: async (
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateLinkTypeRequest' is not null or undefined
      assertParamExists(
        "updateLinkType",
        "updateLinkTypeRequest",
        updateLinkTypeRequest,
      );
      const localVarPath = `/link-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateLinkTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkTypeApi - functional programming interface
 * @export
 */
export const LinkTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLinkType(
      createLinkTypeRequest: CreateLinkTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkType(
        createLinkTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestLinkTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedLinkType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestLinkTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinkType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedLinkType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLinkTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LinkTypeRootedSubgraph>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLinkTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLinkType(
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkType(
        updateLinkTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LinkTypeApi - factory interface
 * @export
 */
export const LinkTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LinkTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateLinkTypeRequest} createLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkType(
      createLinkTypeRequest: CreateLinkTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createLinkType(createLinkTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestLinkTypes(options?: any): AxiosPromise<Array<PersistedLinkType>> {
      return localVarFp
        .getLatestLinkTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the link type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkType(uri: string, options?: any): AxiosPromise<PersistedLinkType> {
      return localVarFp
        .getLinkType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLinkTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Array<LinkTypeRootedSubgraph>> {
      return localVarFp
        .getLinkTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLinkType(
      updateLinkTypeRequest: UpdateLinkTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updateLinkType(updateLinkTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkTypeApi - interface
 * @export
 * @interface LinkTypeApi
 */
export interface LinkTypeApiInterface {
  /**
   *
   * @param {CreateLinkTypeRequest} createLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApiInterface
   */
  createLinkType(
    createLinkTypeRequest: CreateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApiInterface
   */
  getLatestLinkTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedLinkType>>;

  /**
   *
   * @param {string} uri The URI of the link type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApiInterface
   */
  getLinkType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedLinkType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApiInterface
   */
  getLinkTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<LinkTypeRootedSubgraph>>;

  /**
   *
   * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApiInterface
   */
  updateLinkType(
    updateLinkTypeRequest: UpdateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;
}

/**
 * LinkTypeApi - object-oriented interface
 * @export
 * @class LinkTypeApi
 * @extends {BaseAPI}
 */
export class LinkTypeApi extends BaseAPI implements LinkTypeApiInterface {
  /**
   *
   * @param {CreateLinkTypeRequest} createLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApi
   */
  public createLinkType(
    createLinkTypeRequest: CreateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return LinkTypeApiFp(this.configuration)
      .createLinkType(createLinkTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApi
   */
  public getLatestLinkTypes(options?: AxiosRequestConfig) {
    return LinkTypeApiFp(this.configuration)
      .getLatestLinkTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the link type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApi
   */
  public getLinkType(uri: string, options?: AxiosRequestConfig) {
    return LinkTypeApiFp(this.configuration)
      .getLinkType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApi
   */
  public getLinkTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return LinkTypeApiFp(this.configuration)
      .getLinkTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateLinkTypeRequest} updateLinkTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkTypeApi
   */
  public updateLinkType(
    updateLinkTypeRequest: UpdateLinkTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return LinkTypeApiFp(this.configuration)
      .updateLinkType(updateLinkTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyTypeApi - axios parameter creator
 * @export
 */
export const PropertyTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestPropertyTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyType: async (
      uri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uri' is not null or undefined
      assertParamExists("getPropertyType", "uri", uri);
      const localVarPath = `/property-types/{uri}`.replace(
        `{${"uri"}}`,
        encodeURIComponent(String(uri)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      structuralQuery: StructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'structuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "structuralQuery",
        structuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        structuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyTypeApi - functional programming interface
 * @export
 */
export const PropertyTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PropertyTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLatestPropertyTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PersistedPropertyType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLatestPropertyTypes(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyType(
      uri: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedPropertyType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyType(
        uri,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          structuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PersistedOntologyMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PropertyTypeApi - factory interface
 * @export
 */
export const PropertyTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PropertyTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLatestPropertyTypes(
      options?: any,
    ): AxiosPromise<Array<PersistedPropertyType>> {
      return localVarFp
        .getLatestPropertyTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uri The URI of the property type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyType(
      uri: string,
      options?: any,
    ): AxiosPromise<PersistedPropertyType> {
      return localVarFp
        .getPropertyType(uri, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StructuralQuery} structuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      structuralQuery: StructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(structuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<PersistedOntologyMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PropertyTypeApi - interface
 * @export
 * @interface PropertyTypeApi
 */
export interface PropertyTypeApiInterface {
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  getLatestPropertyTypes(
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<PersistedPropertyType>>;

  /**
   *
   * @param {string} uri The URI of the property type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  getPropertyType(
    uri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedPropertyType>;

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  getPropertyTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PersistedOntologyMetadata>;
}

/**
 * PropertyTypeApi - object-oriented interface
 * @export
 * @class PropertyTypeApi
 * @extends {BaseAPI}
 */
export class PropertyTypeApi
  extends BaseAPI
  implements PropertyTypeApiInterface
{
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public getLatestPropertyTypes(options?: AxiosRequestConfig) {
    return PropertyTypeApiFp(this.configuration)
      .getLatestPropertyTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uri The URI of the property type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public getPropertyType(uri: string, options?: AxiosRequestConfig) {
    return PropertyTypeApiFp(this.configuration)
      .getPropertyType(uri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StructuralQuery} structuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public getPropertyTypesByQuery(
    structuralQuery: StructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .getPropertyTypesByQuery(structuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
