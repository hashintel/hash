extend = { path = "../Makefile.toml" }

[env]
CARGO_CLIPPY_HACK_FLAGS = "--workspace --feature-powerset --optional-deps clap"
CARGO_TEST_HACK_FLAGS = "--workspace --feature-powerset --optional-deps clap"
RUST_LOG = "debug,hyper=warn"

[env.production]
CARGO_MAKE_CARGO_PROFILE = "production"


[tasks.test]
run_task = [
    { name = ["test-task", "yarn", "deployment-up", "sleep-for-five-seconds", "migrate-up", "test-integration", "generate-openapi-client", "deployment-down"], condition = { env_true = ["CARGO_MAKE_CI" ] } },
    { name = ["test-task"] }
]

[tasks.test-integration]
private = false
extend = "task"
args = ["nextest", "run", "--cargo-profile", "${CARGO_MAKE_CARGO_PROFILE}", "@@split(CARGO_TEST_FLAGS, )", "--workspace", "--test", "integration", "--profile", "integration", "${@}"]
dependencies = ["install-cargo-nextest"]

[tasks.test-rest-api]
# This is a temporary solution until we have e2e tests in place
command = "yarn"
args = ["httpyac", "send", "--all", "${CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY}/tests/rest-test.http"]

# If this step fails, the OpenAPI spec is invalid.
# When running in CI, a non-empty git diff will fail the pipeline.
[tasks.generate-openapi-client]
script = """
#!/usr/bin/env bash

# Fail entire script if any error occurs.
set -eo pipefail

cargo build
cargo run&
pid=$!
# Ensure the webserver process is killed regardless of script outcome.
trap "kill $pid" 0 ERR

yarn workspace @hashintel/hash-graph-client-generator generate

# This switches the current working directory to the location of the generated client.
# `.` thus refers to the root of the client directory.
yarn workspace @hashintel/hash-graph-client prettier --write .
# The generator isn't idempotent, unfortunately. The interface members are not in a strict order.
# ESlint enforces ordering, which enables us to rely on the output diff as a CI check.
yarn workspace @hashintel/hash-graph-client fix:eslint
"""

[tasks.build-docker]
category = "Deploy"
description = "Builds a docker image of the graph"
command = "docker"
cwd = "${CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY}"
env = { DOCKER_BUILDKIT = 1 }
args = ["build", "--tag", "graph", "--file", "../deployment/graph/Dockerfile", "--build-arg", "PROFILE=${CARGO_MAKE_CARGO_PROFILE}", "."]

[tasks.docker-up]
category = "Deploy"
description = "Runs the docker image of the graph"
cwd = "${CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY}"
script = """
# We need the IP for the postgres deployment. This will be easier, when the graph docker image is started from docker-compose
gateway=$(docker network inspect deployment_default | jq -r '.[0].IPAM.Config[0].Gateway')
docker run --rm --init --name graph --env RUST_LOG=debug --network deployment_default --publish "4000:4000" --detach graph --host $gateway --rest-address 0.0.0.0:4000
"""

[tasks.docker-down]
category = "Deploy"
description = "Stops the docker image of the graph"
command = "docker"
cwd = "${CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY}"
args = ["stop", "graph"]

[tasks.test-docker]
run_task = { name = ["yarn", "deployment-up", "sleep-for-five-seconds", "migrate-up", "docker-up", "test-rest-api", "docker-down", "deployment-down"] }
