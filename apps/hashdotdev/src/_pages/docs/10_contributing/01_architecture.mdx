---
title: "Architecture"
subtitle: "An architectural overview of HASH"
---

## Technical Outline

### Type System

HASH is built around a flexible type system which allows for information to be expressed as [entities](https://hash.dev/docs/entities) with [types](https://hash.dev/docs/types). Types can inherit from one another, and entities can have multiple types. Users can create their own types, keeping them private, or making them public. Types can also be composed from other types, making HASH the first multi-tenant, open-source type system in the world.

### System Types

Most entities and types you work with in HASH will be user-created, or generated by [apps](https://hash.dev/docs/apps) or [integrations](https://hash.dev/docs/integrations). But there are also a number of core system types built into HASH which you'll likely want to familiarize yourself with as a developer building on HASH.

- **Instance:** a single running node of HASH, generally available via the world wide web (e.g. at a web address like `hash.ai`), deployed within a private network (e.g. available via a VPN), or running locally for development purposes.
- **Instance Admin:** relevant in the context of self-hosting HASH, instance admins are users with the ability to perform instance-wide moderation and updates, or to change certain settings.
- **Web:** a web is a namespace within an instance that contains **entities** and **types**.
- **User:** a single account on an instance, corresponding to a real person, which can be logged into via the HASH application interface.
- **User Group:** a collectively addresable group of users on an instance.
- **Block:** an instance of a block
- **Page:** a user-created page within a web containing any number of blocks. All pages MUST be either a:
  1. **Document:** a linear page, whose blocks appear in one or more columns
  1. **Canvas:** a freeform page, whose blocks can be dragged-and-dropped anywhere
- **File:** a binary object stored as a single entity. Files MAY have a more specific system-recognized sub-type (e.g. `Image File`), extending the range of ways in which they can be used in HASH.

### System Components

Each instance of HASH relies on various subsystems. More information about each of these, as well as the corresponding code, can be found in the `hash-` prefixed subdirectories within [`apps`](https://github.com/hashintel/hash/tree/main/apps) (in our [`@hashintel/hash` public monorepo](https://github.com/hashintel)):

- **Authentication system:** based on Ory Kratos, handles user accounts and sessions
- **Authorization system** based on SpiceDB, extends a Zanzibar-like way of providing permissionsed access to information
- **Execution system:** based on Temporal, powers **flows**
- **Datastore(s):** currently Postgres, with planned support for additional specialized backends for selectively storing/offloading specific kinds of data (e.g. timeseries, financial/accounting) and queries (e.g. full-text/vector search)
- **Blobstore(s):** currently supportive of S3-compatible APIs (with Cloudflare R2 utilized by default), with planned for support for file-type specific handlers (e.g. Cloudflare Images for images, Cloudflare Stream for video)
- **Application backend:** written in Rust, with Node.js middleware, coordinates the activity of all other components
  - **HASH Graph:** a query layer that sits on top of the datastore(s)
  - **Realtime service:** a view over the datastore(s) that allows services to subscribe to realtime updates on entities.
  - **Loader service:** loads the change-stream published by the realtime service into other systems
  - **Notification service:** manages the sending of in-app web and mobile push notifications, emails, SMS/MMS messages
- **Application frontend:** built atop Next.js, utilizing ProseMirror for text-editing, tldraw for canvas editing, and the Block Protocol for blocks
