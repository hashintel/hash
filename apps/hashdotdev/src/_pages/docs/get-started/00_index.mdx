---
title: "Introduction"
subtitle: "A guide to HASH for developers"
---

## Functional Overview

**What is HASH?** HASH is a new kind of operating system, platform, or _web_ that stitches together all of your data and makes it usable in new ways. More concretely, HASH lets you:

- **aggregate information from lots of different places:** reconcile and map information to semantic 'entities' and 'types' that represent the things you care about, in a linked graph
- **sync changes to entities:** allow information changed in one system (or edited directly in HASH) to be seamlessly synced to all of the others
- **manage changes to types:** establish data contracts; understand how updates will break things for data consumers, and who those data consumers are; improve the availbility and reliability of information through full versioning and provenance trails
- **control access to information:** set visibility and edit restrictions on information; ensure compliance across systems
- **use information directly in new ways:** in addition to enhancing existing applications through two-way sync, HASH lets users reference entities, their properties and links information in pages; render information on pages using blocks, separating data from visualization logic; build whole sites, tools and apps using blocks, without writing code

Ulimately HASH lets you eliminate competing sources of truth, and reduce information failure. HASH was created with incremental adoption in mind. Services can be integrated progressively, one-by-one, and used within or alongside HASH. At no point will you need to choose between using HASH and another system you or others in your organization are accustomed to. Most external systems can also be recreated within HASH, through HASH's tool-building functionality, allowing for the optional, gradual, risk-free replacement and deprecation of legacy external services over time. See: [SaaS Consolidation (Use Case)](https://hash.dev/docs/get-started/use-cases#saas-consolidation)

## Technical Architecture

### Overview

#### The Type System

HASH is built around the Block Protocol type system, which allows for things to be expressed as 'entities' with 'types'. Types can inherit from one another, and entities can have multiple types.

##### Entities

An entity is "anything".

A **standard entity** might correspond to a physical thing, a concept or idea, an event or action, or really anything else you like _other than_ a relationship between two entities. In this case, a **link entity** is used to denote the relationship between two other entities. For example a `Sibling` link entity might connect two `Person` entities.

Link entities are the only non-standard entities that exist. For brevity, we often call link entities "links", and refer to standard entities simply as "entities".

##### Types

Types provide meaning to entities, describing the possible range of values that can be associated with them.

**Entity types** and **link types** describe the expected attributes of 

**Property types** both entity types and link types may expect

**Data types** 

#### HASH System Types

Both information created by users of HASH, and the HASH application itself, builds around these entities and types. 

- **Instance:** a single running node of HASH, generally available via the world wide web (e.g. at a web address like `hash.ai`), deployed within a private network (e.g. available via a VPN), or running locally for development purposes
- **Web:** a web is a namespace that contains **entities** and **types**
- **User:** 
- **User Group:** a group of users, 

Every user has their own **web**. Users are the sole owners of their own webs, and by default anything created in it is private, but users can choose to share information with their webs (both entities and types) with select other users, or make them public for all.

Users can also create **shared webs** which multiple users may have ownership over, or write access to. By default, anything created in a shared web is visible to its members, but can be locked down more tightly (or as with individual's webs, made entirely public).

### Components

Each instance of HASH comprises of various different subsystems. More information about each of these, as well as the corresponding code, can be found in the `hash-` prefixed subdirectories within [`apps`](https://github.com/hashintel/hash/tree/main/apps) (in our [`@hashintel/hash` public monorepo](https://github.com/hashintel)):

- **Authentication system:** based on Ory Kratos, handles user accounts and sessions
- **Authorization system** based on SpiceDB, extends a Zanzibar-like way of providing permissionsed access to information
- **Execution system:** based on Temporal, powers **flows**
- **Datastore(s):** currently Postgres, with planned support for additional specialized backends for selectively storing/offloading specific kinds of data (e.g. timeseries, financial/accounting) and queries (e.g. full-text/vector search)
- **Blobstore(s):** currently supportive of S3-compatible APIs (with Cloudflare R2 utilized by default), with planned for support for file-type specific handlers (e.g. Cloudflare Images for images, Cloudflare Stream for video)
- **Application backend:** written in Rust, with Node.js middleware, coordinates the activity of all other components
  - **HASH Graph:** a query layer that sits on top of the datastore(s)
  - **Realtime service:** a view over the datastore(s) that allows services to subscribe to realtime updates on entities.
  - **Loader service:** loads the change-stream published by the realtime service into other systems
  - **Notification service:** manages the sending of in-app web and mobile push notifications, emails, SMS/MMS messages
- **Application frontend:** built atop Next.js, utilizing ProseMirror for text-editing, tldraw for canvas editing, and the Block Protocol for blocks
