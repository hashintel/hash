---
title: "Get Started"
subtitle: "An introductory guide to HASH for developers"
---

## Functional Overview

**What is HASH?** HASH is a new kind of operating system, platform, or _web_ that stitches together all of your data and makes it usable in new ways. More concretely, HASH lets you:

- **aggregate information from lots of different places:** reconcile and map information to semantic 'entities' and 'types' that represent the things you care about, in a linked graph
- **sync changes to entities:** allow information changed in one system (or edited directly in HASH) to be seamlessly synced to all of the others
- **manage changes to types:** establish data contracts; understand how updates will break things for data consumers, and who those data consumers are; improve the availbility and reliability of information through full versioning and provenance trails
- **control access to information:** set visibility and edit restrictions on information; ensure compliance across systems
- **use information directly in new ways:** in addition to enhancing existing applications through two-way sync, HASH lets users reference entities, their properties and links information in pages; render information on pages using blocks, separating data from visualization logic; build whole sites, tools and apps using blocks, without writing code

Ulimately HASH lets you eliminate competing sources of truth, and reduce information failure. HASH was created with incremental adoption in mind. Services can be integrated progressively, one-by-one, and used within or alongside HASH. At no point will you need to choose between using HASH and another system you or others in your organization are accustomed to. Most external systems can also be recreated within HASH, through HASH's tool-building functionality, allowing for the optional, gradual, risk-free replacement and deprecation of legacy external services over time. See: [SaaS Consolidation (Use Case)](https://hash.dev/docs/get-started/use-cases#saas-consolidation)

## Technical Outline

### Type System

HASH is built around a flexible type system which allows for information to be expressed as [entities](https://hash.dev/docs/entities) with [types](https://hash.dev/docs/types). Types can inherit from one another, and entities can have multiple types. Users can create their own types, keeping them private, or making them public. Types can also be composed from other types, making HASH the first multi-tenant, open-source type system in the world.

### System Types

Most entities and types you work with in HASH will be user-created, or generated by [apps](https://hash.dev/docs/apps) or [integrations](https://hash.dev/docs/integrations). But there are also a number of core system types built into HASH which you'll likely want to familiarize yourself with as a developer building on HASH.

- **Instance:** a single running node of HASH, generally available via the world wide web (e.g. at a web address like `hash.ai`), deployed within a private network (e.g. available via a VPN), or running locally for development purposes.
- **Instance Admin:** relevant in the context of self-hosting HASH, instance admins are users with the ability to perform instance-wide moderation and updates, or to change certain settings.
- **Web:** a web is a namespace within an instance that contains **entities** and **types**.
- **User:** a single account on an instance, corresponding to a real person, which can be logged into via the HASH application interface.
- **User Group:** a collectively addresable group of users on an instance.
- **Block:** an instance of a block
- **Page:** a user-created page within a web containing any number of blocks. All pages MUST be either a:
  1. **Document:** a linear page, whose blocks appear in one or more columns
  1. **Canvas:** a freeform page, whose blocks can be dragged-and-dropped anywhere
- **File:** a binary object stored as a single entity. Files MAY have a more specific system-recognized sub-type (e.g. `Image File`), extending the range of ways in which they can be used in HASH.

### System Components

Each instance of HASH relies on various subsystems. More information about each of these, as well as the corresponding code, can be found in the `hash-` prefixed subdirectories within [`apps`](https://github.com/hashintel/hash/tree/main/apps) (in our [`@hashintel/hash` public monorepo](https://github.com/hashintel)):

- **Authentication system:** based on Ory Kratos, handles user accounts and sessions
- **Authorization system** based on SpiceDB, extends a Zanzibar-like way of providing permissionsed access to information
- **Execution system:** based on Temporal, powers **flows**
- **Datastore(s):** currently Postgres, with planned support for additional specialized backends for selectively storing/offloading specific kinds of data (e.g. timeseries, financial/accounting) and queries (e.g. full-text/vector search)
- **Blobstore(s):** currently supportive of S3-compatible APIs (with Cloudflare R2 utilized by default), with planned for support for file-type specific handlers (e.g. Cloudflare Images for images, Cloudflare Stream for video)
- **Application backend:** written in Rust, with Node.js middleware, coordinates the activity of all other components
  - **HASH Graph:** a query layer that sits on top of the datastore(s)
  - **Realtime service:** a view over the datastore(s) that allows services to subscribe to realtime updates on entities.
  - **Loader service:** loads the change-stream published by the realtime service into other systems
  - **Notification service:** manages the sending of in-app web and mobile push notifications, emails, SMS/MMS messages
- **Application frontend:** built atop Next.js, utilizing ProseMirror for text-editing, tldraw for canvas editing, and the Block Protocol for blocks
