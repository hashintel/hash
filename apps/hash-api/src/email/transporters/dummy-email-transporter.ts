import fs from "node:fs/promises";
import path from "node:path";

import dedent from "dedent";
import { convert } from "html-to-text";
import { dump } from "js-yaml";

import { logger } from "../../logger";
import type {
  EmailTransporter,
  EmailTransporterSendMailOptions,
} from "./types";

interface EmailDump {
  date: string;
  from: string;
  to: string;
  subject: string;
  text?: string;
  html?: string;
}

const yamlFileHeader = dedent`
  ## This file has been autogenerated by DummyEmailTransporter.
  ## The contents are updated every time the API server sends an email.
  ## Most recent emails are shown at the top, like in an inbox.
  ##
  ## Note that the file is emptied when the API server is restarted.
`;

export interface DummyEmailTransporterConfig {
  filePath?: string;
  from?: string;
}

const defaultFrom = "dummy-email-transporter@hash.test";

export class DummyEmailTransporter implements EmailTransporter {
  /**
   * Emails are ordered from newest [0] to oldest [length - 1]. This makes
   * it simpler to read the yaml without having to reorder items in it.
   */
  private emailDumps: EmailDump[] = [];

  constructor(private config: DummyEmailTransporterConfig = {}) {
    void this.writeEmailsToFile();
  }

  async sendMail({ to, subject, html }: EmailTransporterSendMailOptions) {
    const emailDump: EmailDump = {
      date: new Date().toString(),
      from: this.config.from ?? defaultFrom,
      to,
      subject,
      text: convert(html),
      html,
    };

    await this.logEmail(emailDump);

    this.emailDumps.unshift(emailDump);
    await this.writeEmailsToFile();
  }

  private async logEmail(emailDump: EmailDump): Promise<void> {
    const rowsToDisplay: string[] = [
      `New email to ${emailDump.to}!`,
      `Subject: ${emailDump.subject}`,
      `From: ${emailDump.from}`,
      `Date: ${emailDump.date}`,
      `Text: ${emailDump.text}`,
      "",
    ];

    if (!rowsToDisplay.length) {
      return;
    }

    const maxAllowedRowWidth = process.stdout.columns || 40;
    let maxRowWidth = 10;
    for (const rowToDisplay of rowsToDisplay) {
      const rowWidth = rowToDisplay.length;
      if (rowWidth > maxRowWidth && rowWidth <= maxAllowedRowWidth) {
        maxRowWidth = rowWidth;
      }
    }

    rowsToDisplay.unshift("=".repeat(maxRowWidth));
    rowsToDisplay.unshift("");
    rowsToDisplay.push("=".repeat(maxRowWidth));
    rowsToDisplay.push("");

    for (const rowToDisplay of rowsToDisplay) {
      process.stdout.write(`${rowToDisplay}\n`);
    }
  }

  private async writeEmailsToFile(): Promise<void> {
    if (!this.config.filePath) {
      return;
    }

    try {
      await fs.mkdir(path.dirname(this.config.filePath), {
        recursive: true,
      });

      const yamlFileContents = this.emailDumps.length
        ? `${yamlFileHeader}\n\n---\n${this.emailDumps
            .map((email) => dump(email, { lineWidth: -1 }))
            .join("\n---\n")}`
        : yamlFileHeader;

      await fs.writeFile(this.config.filePath, yamlFileContents, "utf-8");
    } catch (error) {
      logger.error(error as string);
    }
  }
}
