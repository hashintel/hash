use alloc::sync::Arc;

use authorization::{AuthorizationApiPool, schema::AccountGroupPermission};
use error_stack::{Report, ResultExt};
use graph::store::StorePool;
use graph_types::account::{AccountGroupId, AccountId};
use harpc_server::session::Session;
use harpc_service::role::Role;
use hash_graph_store::account::{AccountStore, InsertAccountGroupIdParams, InsertAccountIdParams};
use temporal_client::TemporalClient;

use super::{role, session::User};
use crate::rest::PermissionResponse;

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, derive_more::Display, derive_more::Error)]
#[display("unable to fullfil account request")]
pub struct AccountError;

pub trait AccountService<R>
where
    R: Role,
{
    async fn create_account(
        &self,
        session: R::Session,
        params: InsertAccountIdParams,
    ) -> Result<AccountId, Report<AccountError>>;

    async fn create_account_group(
        &self,
        session: R::Session,
        params: InsertAccountGroupIdParams,
    ) -> Result<AccountGroupId, Report<AccountError>>;

    async fn check_account_group_permission(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        permission: AccountGroupPermission,
    ) -> Result<PermissionResponse, Report<AccountError>>;

    async fn add_account_group_member(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>>;

    async fn remove_account_group_member(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>>;
}

mod meta {
    //! The `meta` module contains the metadata for the account service.
    //! In the future this will be automatically generated by the `harpc` crate.

    use frunk::HList;
    use harpc_service::{
        Service,
        metadata::Metadata,
        procedure::{Procedure, ProcedureIdentifier},
    };
    use harpc_types::{procedure::ProcedureId, service::ServiceId, version::Version};

    struct AccountService;

    enum AccountProcedureId {
        CreateAccount,
        CreateAccountGroup,
        CheckAccountGroupPermission,
        AddAccountGroupMember,
        RemoveAccountGroupMember,
    }

    impl ProcedureIdentifier for AccountProcedureId {
        fn from_id(id: ProcedureId) -> Option<Self> {
            match id.value() {
                0x00 => Some(Self::CreateAccount),
                0x01 => Some(Self::CreateAccountGroup),
                0x02 => Some(Self::CheckAccountGroupPermission),
                0x03 => Some(Self::AddAccountGroupMember),
                0x04 => Some(Self::RemoveAccountGroupMember),
                _ => None,
            }
        }

        fn into_id(self) -> ProcedureId {
            match self {
                Self::CreateAccount => ProcedureId::new(0x00),
                Self::CreateAccountGroup => ProcedureId::new(0x01),
                Self::CheckAccountGroupPermission => ProcedureId::new(0x02),
                Self::AddAccountGroupMember => ProcedureId::new(0x03),
                Self::RemoveAccountGroupMember => ProcedureId::new(0x04),
            }
        }
    }

    impl Service for AccountService {
        type ProcedureId = AccountProcedureId;
        type Procedures = HList![
            ProcedureCreateAccount,
            ProcedureCreateAccountGroup,
            ProcedureCheckAccountGroupPermission,
            ProcedureAddAccountGroupMember,
            ProcedureRemoveAccountGroupMember
        ];

        const ID: ServiceId = ServiceId::new(0x00);
        const VERSION: Version = Version {
            major: 0x00,
            minor: 0x00,
        };

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    struct ProcedureCreateAccount;

    impl Procedure for ProcedureCreateAccount {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId = AccountProcedureId::CreateAccount;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    struct ProcedureCreateAccountGroup;

    impl Procedure for ProcedureCreateAccountGroup {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId = AccountProcedureId::CreateAccountGroup;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    struct ProcedureCheckAccountGroupPermission;

    impl Procedure for ProcedureCheckAccountGroupPermission {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::CheckAccountGroupPermission;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    struct ProcedureAddAccountGroupMember;

    impl Procedure for ProcedureAddAccountGroupMember {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::AddAccountGroupMember;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    struct ProcedureRemoveAccountGroupMember;

    impl Procedure for ProcedureRemoveAccountGroupMember {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::RemoveAccountGroupMember;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }
}

pub struct AccountServer<S, A> {
    authorization_api_pool: Arc<A>,
    temporal_client: Option<Arc<TemporalClient>>,
    store_pool: Arc<S>,
}

impl<S, A> AccountServer<S, A>
where
    S: StorePool + Send + Sync,
    A: AuthorizationApiPool + Send + Sync,
{
    async fn store(&self) -> Result<S::Store<A::Api>, Report<AccountError>> {
        let authorization_api = self
            .authorization_api_pool
            .acquire()
            .await
            .inspect_err(|error| {
                tracing::error!(?error, "Could not acquire access to the authorization API");
            })
            .change_context(AccountError)?;

        self.store_pool
            .acquire(authorization_api, temporal_client.0)
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not acquire store");
            })
            .change_context(AccountError)
    }
}

impl<S, A> AccountService<role::Server> for AccountServer<S, A>
where
    S: StorePool + Send + Sync,
    A: AuthorizationApiPool + Send + Sync,
{
    async fn create_account(
        &self,
        session: Session<User>,
        params: InsertAccountIdParams,
    ) -> Result<AccountId, Report<AccountError>> {
        let store = self.store().await?;

        let account_id = params.account_id;
        store
            .insert_account_id(session.get().actor_id, params)
            .await
            .change_context(AccountError)?;

        Ok(account_id)
    }

    async fn create_account_group(
        &self,
        session: Session<User>,
        params: InsertAccountGroupIdParams,
    ) -> Result<AccountGroupId, Report<AccountError>> {
        let store = self.store().await?;

        let account = store
            .identify_owned_by_id(OwnedById::from(session.get().actor_id))
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not identify account");
            })
            .change_context(AccountError)?;

        if account != (WebOwnerSubject::Account { id: actor_id }) {
            tracing::error!("Account does not exist in the graph");
            return Err(StatusCode::NOT_FOUND);
        }

        let account_group_id = params.account_group_id;
        store
            .insert_account_group_id(actor_id, params)
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not create account id");
            })
            .change_context(AccountError)?;

        Ok(account_group_id)
    }

    async fn check_account_group_permission(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        permission: AccountGroupPermission,
    ) -> Result<PermissionResponse, Report<AccountError>> {
        todo!()
    }

    async fn add_account_group_member(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        todo!()
    }

    async fn remove_account_group_member(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        todo!()
    }
}
