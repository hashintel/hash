use alloc::sync::Arc;

use authorization::{
    AuthorizationApi, AuthorizationApiPool,
    backend::ModifyRelationshipOperation,
    schema::{
        AccountGroupMemberSubject, AccountGroupPermission, AccountGroupRelationAndSubject,
        WebOwnerSubject,
    },
    zanzibar::Consistency,
};
use error_stack::{Report, ResultExt};
use futures::StreamExt as _;
use graph::store::StorePool;
use graph_types::{
    account::{AccountGroupId, AccountId},
    owned_by_id::OwnedById,
};
use harpc_client::connection::Connection;
use harpc_server::session::Session;
use harpc_service::role::Role;
use hash_graph_store::account::{AccountStore, InsertAccountGroupIdParams, InsertAccountIdParams};
use temporal_client::TemporalClient;
use tower::ServiceExt as _;

use super::{role, session::User};
use crate::rest::PermissionResponse;

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, derive_more::Display, derive_more::Error)]
#[display("unable to fullfil account request")]
pub struct AccountError;

pub trait AccountService<R>
where
    R: Role,
{
    async fn create_account(
        &self,
        session: R::Session,
        params: InsertAccountIdParams,
    ) -> Result<AccountId, Report<AccountError>>;

    async fn create_account_group(
        &self,
        session: R::Session,
        params: InsertAccountGroupIdParams,
    ) -> Result<AccountGroupId, Report<AccountError>>;

    async fn check_account_group_permission(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        permission: AccountGroupPermission,
    ) -> Result<PermissionResponse, Report<AccountError>>;

    async fn add_account_group_member(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>>;

    async fn remove_account_group_member(
        &self,
        session: R::Session,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>>;
}

pub mod meta {
    //! The `meta` module contains the metadata for the account service.
    //! In the future this will be automatically generated by the `harpc` crate.

    use frunk::HList;
    use harpc_service::{
        Service,
        metadata::Metadata,
        procedure::{Procedure, ProcedureIdentifier},
    };
    use harpc_types::{procedure::ProcedureId, service::ServiceId, version::Version};

    pub enum AccountProcedureId {
        CreateAccount,
        CreateAccountGroup,
        CheckAccountGroupPermission,
        AddAccountGroupMember,
        RemoveAccountGroupMember,
    }

    impl ProcedureIdentifier for AccountProcedureId {
        fn from_id(id: ProcedureId) -> Option<Self> {
            match id.value() {
                0x00 => Some(Self::CreateAccount),
                0x01 => Some(Self::CreateAccountGroup),
                0x02 => Some(Self::CheckAccountGroupPermission),
                0x03 => Some(Self::AddAccountGroupMember),
                0x04 => Some(Self::RemoveAccountGroupMember),
                _ => None,
            }
        }

        fn into_id(self) -> ProcedureId {
            match self {
                Self::CreateAccount => ProcedureId::new(0x00),
                Self::CreateAccountGroup => ProcedureId::new(0x01),
                Self::CheckAccountGroupPermission => ProcedureId::new(0x02),
                Self::AddAccountGroupMember => ProcedureId::new(0x03),
                Self::RemoveAccountGroupMember => ProcedureId::new(0x04),
            }
        }
    }

    pub struct AccountService;

    impl Service for AccountService {
        type ProcedureId = AccountProcedureId;
        type Procedures = HList![
            ProcedureCreateAccount,
            ProcedureCreateAccountGroup,
            ProcedureCheckAccountGroupPermission,
            ProcedureAddAccountGroupMember,
            ProcedureRemoveAccountGroupMember
        ];

        const ID: ServiceId = ServiceId::new(0x01);
        const VERSION: Version = Version {
            major: 0x00,
            minor: 0x00,
        };

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureCreateAccount;

    impl Procedure for ProcedureCreateAccount {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId = AccountProcedureId::CreateAccount;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureCreateAccountGroup;

    impl Procedure for ProcedureCreateAccountGroup {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId = AccountProcedureId::CreateAccountGroup;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureCheckAccountGroupPermission;

    impl Procedure for ProcedureCheckAccountGroupPermission {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::CheckAccountGroupPermission;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureAddAccountGroupMember;

    impl Procedure for ProcedureAddAccountGroupMember {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::AddAccountGroupMember;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureRemoveAccountGroupMember;

    impl Procedure for ProcedureRemoveAccountGroupMember {
        type Service = AccountService;

        const ID: <Self::Service as Service>::ProcedureId =
            AccountProcedureId::RemoveAccountGroupMember;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }
}

pub struct AccountServer<S, A> {
    authorization_api_pool: Arc<A>,
    temporal_client: Option<Arc<TemporalClient>>,
    store_pool: Arc<S>,
}

impl<S, A> AccountServer<S, A>
where
    S: StorePool + Send + Sync,
    A: AuthorizationApiPool + Send + Sync,
{
    async fn authorization_api(&self) -> Result<A::Api<'_>, Report<AccountError>> {
        self.authorization_api_pool
            .acquire()
            .await
            .inspect_err(|error| {
                tracing::error!(?error, "Could not acquire access to the authorization API");
            })
            .change_context(AccountError)
    }

    async fn store(&self) -> Result<S::Store<'_, A::Api<'_>>, Report<AccountError>> {
        let authorization_api = self.authorization_api().await?;

        self.store_pool
            .acquire(authorization_api, self.temporal_client.clone())
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not acquire store");
            })
            .change_context(AccountError)
    }

    fn actor(session: Session<User>) -> Result<AccountId, Report<AccountError>> {
        let &User {
            actor_id: Some(actor_id),
        } = session.get()
        else {
            todo!("Handle anonymous users")
        };

        Ok(actor_id)
    }
}

impl<S, A> AccountService<role::Server> for AccountServer<S, A>
where
    S: StorePool + Send + Sync,
    A: AuthorizationApiPool + Send + Sync,
{
    async fn create_account(
        &self,
        session: Session<User>,
        params: InsertAccountIdParams,
    ) -> Result<AccountId, Report<AccountError>> {
        let actor_id = Self::actor(session)?;

        let mut store = self.store().await?;

        let account_id = params.account_id;
        store
            .insert_account_id(actor_id, params)
            .await
            .change_context(AccountError)?;

        Ok(account_id)
    }

    async fn create_account_group(
        &self,
        session: Session<User>,
        params: InsertAccountGroupIdParams,
    ) -> Result<AccountGroupId, Report<AccountError>> {
        let actor_id = Self::actor(session)?;

        let mut store = self.store().await?;

        let account = store
            .identify_owned_by_id(OwnedById::from(actor_id))
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not identify account");
            })
            .change_context(AccountError)?;

        if account != (WebOwnerSubject::Account { id: actor_id }) {
            tracing::error!("Account does not exist in the graph");
            todo!("Handle account not existing in the graph");
        }

        let account_group_id = params.account_group_id;
        store
            .insert_account_group_id(actor_id, params)
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not create account id");
            })
            .change_context(AccountError)?;

        Ok(account_group_id)
    }

    async fn check_account_group_permission(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        permission: AccountGroupPermission,
    ) -> Result<PermissionResponse, Report<AccountError>> {
        let actor_id = Self::actor(session)?;

        let auth = self.authorization_api().await?;

        let check = auth
            .check_account_group_permission(
                actor_id,
                permission,
                account_group_id,
                Consistency::FullyConsistent,
            )
            .await
            .inspect_err(|error| {
                tracing::error!(
                    ?error,
                    "Could not check if permission on the account group is granted to the \
                     specified actor"
                );
            })
            .change_context(AccountError)?;

        Ok(PermissionResponse {
            has_permission: check.has_permission,
        })
    }

    async fn add_account_group_member(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        let actor_id = Self::actor(session)?;

        let mut auth = self.authorization_api().await?;

        let check = auth
            .check_account_group_permission(
                actor_id,
                AccountGroupPermission::AddMember,
                account_group_id,
                Consistency::FullyConsistent,
            )
            .await
            .inspect_err(|error| {
                tracing::error!(
                    ?error,
                    "Could not check if account group member can be added"
                );
            })
            .change_context(AccountError)?;

        if !check.has_permission {
            todo!("Handle permission denied - forbidden")
        }

        auth.modify_account_group_relations([(
            ModifyRelationshipOperation::Create,
            account_group_id,
            AccountGroupRelationAndSubject::Member {
                subject: AccountGroupMemberSubject::Account { id: account_id },
                level: 0,
            },
        )])
        .await
        .inspect_err(|error| {
            tracing::error!(?error, "Could not add account group member");
        })
        .change_context(AccountError)?;

        Ok(())
    }

    async fn remove_account_group_member(
        &self,
        session: Session<User>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        let actor_id = Self::actor(session)?;

        let mut auth = self.authorization_api().await?;

        let check = auth
            .check_account_group_permission(
                actor_id,
                AccountGroupPermission::RemoveMember,
                account_group_id,
                Consistency::FullyConsistent,
            )
            .await
            .inspect_err(|error| {
                tracing::error!(
                    ?error,
                    "Could not check if account group member can be removed"
                );
            })
            .change_context(AccountError)?;

        if !check.has_permission {
            todo!("Handle permission denied - forbidden")
        }

        auth.modify_account_group_relations([(
            ModifyRelationshipOperation::Delete,
            account_group_id,
            AccountGroupRelationAndSubject::Member {
                subject: AccountGroupMemberSubject::Account { id: account_id },
                level: 0,
            },
        )])
        .await
        .inspect_err(|error| {
            tracing::error!(?error, "Could not remove account group member");
        })
        .change_context(AccountError)?;

        Ok(())
    }
}

// TODO: delegate, this can be auto generated by the `harpc` crate

// TODO: move this into `harpc_client`
#[derive(Debug, derive_more::Display, derive_more::Error)]
#[display("unknown error: {_0:?}")]
struct UnknownError(#[error(not(source))] serde_json::Value);

// TODO: this can be auto generated by the `harpc` crate
pub struct AccountClient;

impl<Svc, C> AccountService<role::Client<Svc, C>> for AccountClient
where
    Svc: role::ConnectionService<C>,
    C: role::ConnectionCodec,
{
    async fn create_account(
        &self,
        session: Connection<Svc, C>,
        params: InsertAccountIdParams,
    ) -> Result<AccountId, Report<AccountError>> {
        let (service, codec) = session.into_parts();

        let request = role::encode_request::<meta::AccountService, _, _>(
            codec.clone(),
            meta::AccountProcedureId::CreateAccount,
            [params],
        )
        .await
        .change_context(AccountError)?;

        let response = service
            .oneshot(request)
            .await
            .change_context(AccountError)?;

        let (_, body) = response.into_parts();

        let items = codec.decode(body);
        let mut items = core::pin::pin!(items);

        // TODO: proper error for expected item
        let data: Result<_, serde_json::Value> = items
            .next()
            .await
            .ok_or_else(|| Report::new(AccountError))?
            .change_context(AccountError)?;

        data.map_err(UnknownError).change_context(AccountError)
    }

    async fn create_account_group(
        &self,
        session: Connection<Svc, C>,
        params: InsertAccountGroupIdParams,
    ) -> Result<AccountGroupId, Report<AccountError>> {
        todo!()
    }

    async fn check_account_group_permission(
        &self,
        session: Connection<Svc, C>,
        account_group_id: AccountGroupId,
        permission: AccountGroupPermission,
    ) -> Result<PermissionResponse, Report<AccountError>> {
        todo!()
    }

    async fn add_account_group_member(
        &self,
        session: Connection<Svc, C>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        todo!()
    }

    async fn remove_account_group_member(
        &self,
        session: Connection<Svc, C>,
        account_group_id: AccountGroupId,
        account_id: AccountId,
    ) -> Result<(), Report<AccountError>> {
        todo!()
    }
}
