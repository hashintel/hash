use core::{fmt::Debug, pin::pin};

use error_stack::{Report, ResultExt as _};
use futures::{StreamExt, stream};
use graph_types::account::AccountId;
use harpc_client::{
    connection::Connection,
    error::{ExpectedItemCountMismatch, RemoteError},
};
use harpc_codec::{decode::Decoder, encode::Encoder};
use harpc_server::{error::ProcedureNotFound, session::Session};
use harpc_service::{delegate::ServiceDelegate, procedure::ProcedureIdentifier};
use harpc_tower::{
    body::{Body, BodyExt},
    request::Request,
    response::{self, Response},
};
use harpc_types::{procedure::ProcedureDescriptor, response_kind::ResponseKind};
use tower::ServiceExt as _;

use super::{role, session::User};

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, derive_more::Display, derive_more::Error)]
#[display("unable to authenticate user")]
pub struct AuthenticationError;

pub trait AuthenticationService<R>
where
    R: role::Role,
{
    async fn authenticate(
        &self,
        session: R::Session,
        actor_id: AccountId,
    ) -> Result<(), Report<AuthenticationError>>;
}

// TODO: this can be auto generated by the `harpc` crate
pub mod meta {
    //! The `meta` module contains the metadata for the account service.
    //! In the future this will be automatically generated by the `harpc` crate.

    use frunk::HList;
    use harpc_service::{
        Service,
        metadata::Metadata,
        procedure::{Procedure, ProcedureIdentifier},
    };
    use harpc_types::{procedure::ProcedureId, service::ServiceId, version::Version};

    pub enum AuthenticationProcedureId {
        Authenticate,
    }

    impl ProcedureIdentifier for AuthenticationProcedureId {
        type Service = AuthenticationService;

        fn from_id(id: ProcedureId) -> Option<Self> {
            match id.value() {
                0x00 => Some(Self::Authenticate),
                _ => None,
            }
        }

        fn into_id(self) -> ProcedureId {
            match self {
                Self::Authenticate => ProcedureId::new(0x00),
            }
        }
    }

    pub struct AuthenticationService;

    impl Service for AuthenticationService {
        type ProcedureId = AuthenticationProcedureId;
        type Procedures = HList![ProcedureAuthenticate];

        const ID: ServiceId = ServiceId::new(0x00);
        const VERSION: Version = Version {
            major: 0x00,
            minor: 0x00,
        };

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }

    pub struct ProcedureAuthenticate;

    impl Procedure for ProcedureAuthenticate {
        type Service = AuthenticationService;

        const ID: <Self::Service as Service>::ProcedureId = AuthenticationProcedureId::Authenticate;

        fn metadata() -> Metadata {
            Metadata {
                since: Version {
                    major: 0x00,
                    minor: 0x00,
                },
                deprecation: None,
            }
        }
    }
}

pub struct AuthenticationServer;

impl AuthenticationService<role::Server> for AuthenticationServer {
    async fn authenticate(
        &self,
        session: Session<User>,
        actor_id: AccountId,
    ) -> Result<(), Report<AuthenticationError>> {
        session
            .update(User {
                actor_id: Some(actor_id),
            })
            .await;

        Ok(())
    }
}

// TODO: this can be auto generated by the `harpc` crate
pub struct AuthenticationDelegate<T> {
    inner: T,
}

impl<T, C> ServiceDelegate<Session<User>, C> for AuthenticationDelegate<T>
where
    T: AuthenticationService<role::Server, authenticate(..): Send> + Send,
    C: Encoder + Decoder<Error: Debug> + Clone + Send,
{
    type Error = ProcedureNotFound;
    type Service = meta::AuthenticationService;

    type Body<Source>
        = impl Body<Control: AsRef<ResponseKind>, Error = <C as Encoder>::Error>
    where
        Source: Body<Control = !, Error: Send + Sync> + Send + Sync;

    async fn call<B>(
        self,
        request: Request<B>,
        session: Session<User>,
        codec: C,
    ) -> Result<Response<Self::Body<B>>, Self::Error>
    where
        B: Body<Control = !, Error: Send + Sync> + Send + Sync,
    {
        let session_id = request.session();
        let ProcedureDescriptor { id } = request.procedure();

        let id = meta::AuthenticationProcedureId::from_id(id).ok_or_else(|| ProcedureNotFound {
            service: request.service().id,
            version: request.service().version,
            procedure: id,
        })?;

        match id {
            meta::AuthenticationProcedureId::Authenticate => {
                let body = request.into_body();
                let data = body.into_stream().into_data_stream();

                let stream = codec.clone().decode(data);
                let mut stream = pin!(stream);

                // TODO: errors here
                let payload = stream.next().await.unwrap().unwrap();

                let response = self.inner.authenticate(session, payload).await;
                let data = codec.encode(stream::iter([response]));

                // In theory we could also box this, or use `Either` if we have multiple responses
                Ok(Response::from_ok(response::Parts::new(session_id), data))
            }
        }
    }
}

// TODO: this can be auto generated by the `harpc` crate
pub struct AuthenticationClient;

impl<Svc, C> AuthenticationService<role::Client<Svc, C>> for AuthenticationClient
where
    Svc: harpc_client::connection::ConnectionService<C>,
    C: harpc_client::connection::ConnectionCodec,
{
    async fn authenticate(
        &self,
        session: Connection<Svc, C>,
        actor_id: AccountId,
    ) -> Result<(), Report<AuthenticationError>> {
        let (service, codec) = session.into_parts();

        let request = harpc_client::common::encode_request_iter(
            codec.clone(),
            meta::AuthenticationProcedureId::Authenticate,
            [actor_id],
        )
        .await
        .change_context(AuthenticationError)?;

        let response = service
            .oneshot(request)
            .await
            .change_context(AuthenticationError)?;

        let (_, body) = response.into_parts();

        let items = codec.decode(body);
        let mut items = core::pin::pin!(items);

        let data: Result<_, _> = items
            .next()
            .await
            .ok_or_else(|| Report::new(ExpectedItemCountMismatch::exactly(1)))
            .change_context(AuthenticationError)?
            .change_context(AuthenticationError)?;

        data.map_err(RemoteError::new)
            .change_context(AuthenticationError)
    }
}
