════ Initial MIR ═══════════════════════════════════════════════════════════════

fn {closure#13}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 > 50

        return %2
    }
}

thunk is_large:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean
    let %1: ()

    bb0(): {
        %1 = ()
        %0 = closure(({closure#13} as FnPtr), %1)

        return %0
    }
}

fn {closure#14}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 < 10

        return %2
    }
}

thunk is_small:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean
    let %1: ()

    bb0(): {
        %1 = ()
        %0 = closure(({closure#14} as FnPtr), %1)

        return %0
    }
}

fn {closure#17}(%0: (), %1: Integer) -> String {
    let %2: (Integer) -> Boolean
    let %3: Boolean
    let %4: String
    let %5: (Integer) -> Boolean
    let %6: Boolean
    let %7: String

    bb0(): {
        %2 = apply (is_large:0 as FnPtr)
        %3 = apply %2.0 %2.1 %1

        switchInt(%3) -> [0: bb1(), 1: bb4()]
    }

    bb1(): {
        %5 = apply (is_small:0 as FnPtr)
        %6 = apply %5.0 %5.1 %1

        switchInt(%6) -> [0: bb3(), 1: bb2()]
    }

    bb2(): {
        goto -> bb5("small")
    }

    bb3(): {
        goto -> bb5("medium")
    }

    bb4(): {
        goto -> bb6("large")
    }

    bb5(%7): {
        goto -> bb6(%7)
    }

    bb6(%4): {
        return %4
    }
}

thunk classify:0() -> (Integer) -> String {
    let %0: (Integer) -> String
    let %1: ()

    bb0(): {
        %1 = ()
        %0 = closure(({closure#17} as FnPtr), %1)

        return %0
    }
}

*thunk {thunk#12}() -> String {
    let %0: (Integer) -> String
    let %1: String

    bb0(): {
        %0 = apply (classify:0 as FnPtr)
        %1 = apply %0.0 %0.1 75

        return %1
    }
}

════ Pre-inlining MIR ══════════════════════════════════════════════════════════

fn {closure#13}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 > 50

        return %2
    }
}

thunk is_large:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#13} as FnPtr), ())

        return %0
    }
}

fn {closure#14}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 < 10

        return %2
    }
}

thunk is_small:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#14} as FnPtr), ())

        return %0
    }
}

fn {closure#17}(%0: (), %1: Integer) -> String {
    let %2: Boolean
    let %3: Boolean
    let %4: String

    bb0(): {
        %2 = apply ({closure#13} as FnPtr) () %1

        switchInt(%2) -> [0: bb1(), 1: bb2()]
    }

    bb1(): {
        %3 = apply ({closure#14} as FnPtr) () %1

        switchInt(%3) -> [0: bb3("medium"), 1: bb3("small")]
    }

    bb2(): {
        return "large"
    }

    bb3(%4): {
        return %4
    }
}

thunk classify:0() -> (Integer) -> String {
    let %0: (Integer) -> String

    bb0(): {
        %0 = closure(({closure#17} as FnPtr), ())

        return %0
    }
}

*thunk {thunk#12}() -> String {
    let %0: String

    bb0(): {
        %0 = apply ({closure#17} as FnPtr) () 75

        return %0
    }
}

════ Inlined MIR ═══════════════════════════════════════════════════════════════

fn {closure#13}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 > 50

        return %2
    }
}

thunk is_large:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#13} as FnPtr), ())

        return %0
    }
}

fn {closure#14}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 < 10

        return %2
    }
}

thunk is_small:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#14} as FnPtr), ())

        return %0
    }
}

fn {closure#17}(%0: (), %1: Integer) -> String {
    let %2: Boolean
    let %3: Boolean
    let %4: String
    let %5: ()
    let %6: Integer
    let %7: Boolean
    let %8: ()
    let %9: Integer
    let %10: Boolean

    bb0(): {
        %8 = ()
        %9 = %1

        goto -> bb7()
    }

    bb1(): {
        %5 = ()
        %6 = %1

        goto -> bb5()
    }

    bb2(): {
        return "large"
    }

    bb3(%4): {
        return %4
    }

    bb4(%3): {
        switchInt(%3) -> [0: bb3("medium"), 1: bb3("small")]
    }

    bb5(): {
        %7 = %6 < 10

        goto -> bb4(%7)
    }

    bb6(%2): {
        switchInt(%2) -> [0: bb1(), 1: bb2()]
    }

    bb7(): {
        %10 = %9 > 50

        goto -> bb6(%10)
    }
}

thunk classify:0() -> (Integer) -> String {
    let %0: (Integer) -> String

    bb0(): {
        %0 = closure(({closure#17} as FnPtr), ())

        return %0
    }
}

*thunk {thunk#12}() -> String {
    let %0: String

    bb0(): {
        %0 = apply ({closure#17} as FnPtr) () 75

        return %0
    }
}

════ Post Inline MIR ═══════════════════════════════════════════════════════════

fn {closure#13}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 > 50

        return %2
    }
}

thunk is_large:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#13} as FnPtr), ())

        return %0
    }
}

fn {closure#14}(%0: (), %1: Integer) -> Boolean {
    let %2: Boolean

    bb0(): {
        %2 = %1 < 10

        return %2
    }
}

thunk is_small:0() -> (Integer) -> Boolean {
    let %0: (Integer) -> Boolean

    bb0(): {
        %0 = closure(({closure#14} as FnPtr), ())

        return %0
    }
}

fn {closure#17}(%0: (), %1: Integer) -> String {
    let %2: String
    let %3: Boolean
    let %4: Boolean

    bb0(): {
        %4 = %1 > 50

        switchInt(%4) -> [0: bb1(), 1: bb2()]
    }

    bb1(): {
        %3 = %1 < 10

        switchInt(%3) -> [0: bb3("medium"), 1: bb3("small")]
    }

    bb2(): {
        return "large"
    }

    bb3(%2): {
        return %2
    }
}

thunk classify:0() -> (Integer) -> String {
    let %0: (Integer) -> String

    bb0(): {
        %0 = closure(({closure#17} as FnPtr), ())

        return %0
    }
}

*thunk {thunk#12}() -> String {
    let %0: String

    bb0(): {
        %0 = apply ({closure#17} as FnPtr) () 75

        return %0
    }
}