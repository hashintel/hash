use core::fmt::{self, Display};

use hashql_core::{
    id::{self},
    span::SpanId,
    symbol::Ident,
};

use super::Node;

id::newtype!(
    /// A unique identifier for variables in the HashQL HIR.
    ///
    /// Variables are variables which have been given an explicit name by the user, or are generated by the compiler.
    ///
    /// The value space is restricted to `0..=0xFFFF_FF00`, reserving the last 256 for niches.
    pub struct VarId(u32 is 0..=0xFFFF_FF00)
);

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Binder<'heap> {
    pub id: VarId,
    pub name: Option<Ident<'heap>>,
}

impl Binder<'_> {
    #[must_use]
    pub fn mangled(&self) -> impl Display + '_ {
        struct DisplayMangled<'this>(&'this Binder<'this>);

        impl Display for DisplayMangled<'_> {
            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
                if let Some(name) = &self.0.name {
                    return Display::fmt(&name.value, fmt);
                }

                fmt.write_str("%")?;
                Display::fmt(&self.0.id, fmt)
            }
        }

        DisplayMangled(self)
    }
}

impl Display for Binder<'_> {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(name) = &self.name {
            return Display::fmt(name.value.demangle(), fmt);
        }

        fmt.write_str("%")?;
        Display::fmt(&self.id, fmt)
    }
}

/// A variable binding node in the HashQL HIR.
///
/// Represents a `let` expression that binds a value to a name within a lexical scope.
/// The binding is only visible within the body expression and creates a new variable
/// that can be referenced by name.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct Let<'heap> {
    pub span: SpanId,

    pub name: Binder<'heap>,
    pub value: Node<'heap>,

    pub body: Node<'heap>,
}
