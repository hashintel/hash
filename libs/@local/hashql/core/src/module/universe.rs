#![allow(
    exported_private_dependencies,
    reason = "equivalent is from hashbrown; false positive"
)]
use alloc::alloc::Global;
use core::{
    alloc::Allocator,
    fmt::{self, Debug, Display},
    hash::{BuildHasher, Hash},
    mem::variant_count,
    ops::{Index, IndexMut},
};

pub use hashbrown::hash_map::Entry;
use hashbrown::{Equivalent, HashMap, HashSet, hash_map::OccupiedError};

use crate::collections::{FastHashMap, FastHashSet};

/// Represents the conceptual space or "universe" an item belongs to.
///
/// In HashQL, items exist in distinct conceptual spaces known as "universes".
/// This categorization helps distinguish items like type definitions from
/// runtime values or functions, even if they might share the same name.
/// Items in one universe generally do not conflict with items in another.
///
/// As an analogy, Rust also utilizes multiple universes. For instance:
/// - **Type Universe:** Contains definitions like `struct`, `enum`, `trait`.
/// - **Value Universe:** Contains concrete values (`let x = 5;`) and functions (`fn foo() {}`).
/// - **Macro Universe:** Contains procedural and declarative macros (`println!`, `vec!`).
///
/// Similarly, HashQL uses `Universe` to differentiate between its conceptual spaces.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Universe {
    /// Represents items belonging to the type universe (e.g., type definitions).
    Type,
    /// Represents items belonging to the value universe (e.g., concrete values, functions).
    Value,
}

impl Universe {
    /// Returns the name of the universe as a string slice.
    #[must_use]
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::Type => "Type",
            Self::Value => "Value",
        }
    }
}

impl Display for Universe {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        Display::fmt(self.as_str(), fmt)
    }
}

const LENGTH: usize = variant_count::<Universe>();
const UNIVERSES: [Universe; LENGTH] = {
    let variants: [Universe; LENGTH] = [Universe::Type, Universe::Value];

    let mut index = 0;
    while index < LENGTH {
        let variant = variants[index];
        assert!(
            variant as usize == index,
            "Order of variants should match the enum definition"
        );
        index += 1;
    }

    variants
};

/// A container that manages multiple instances of a type across different [`Universe`]s.
///
/// [`Realms<T>`] provides a way to store and manage a value of type `T` for each
/// possible [`Universe`] variant. This enables organizing and accessing data
/// separately for different conceptual spaces, while maintaining a unified interface.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Realms<T> {
    data: [T; LENGTH],
}

impl<T> Realms<T> {
    /// Creates a new [`Realms<T>`] with default values for each universe.
    ///
    /// Initializes a container with a default-constructed value of type `T`
    /// for each possible [`Universe`] variant.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let realms = Realms::<Vec<String>>::new();
    /// assert!(realms.of(Universe::Type).is_empty());
    /// assert!(realms.of(Universe::Value).is_empty());
    /// ```
    #[must_use]
    pub fn new() -> Self
    where
        T: Default,
    {
        Self {
            data: core::array::from_fn(|_| T::default()),
        }
    }

    /// Creates a new [`Realms<T>`] with values generated by the provided closure.
    ///
    /// Initializes a container with values generated by the provided closure for each universe.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let realms = Realms::from_fn(|universe| format!("{}-{}", universe, universe));
    /// assert_eq!(realms.of(Universe::Type), "Type-Type");
    /// assert_eq!(realms.of(Universe::Value), "Value-Value");
    /// ```
    #[must_use]
    pub fn from_fn(mut closure: impl FnMut(Universe) -> T) -> Self {
        Self {
            data: core::array::from_fn(|index| closure(UNIVERSES[index])),
        }
    }

    /// Returns a reference to the value for the specified [`Universe`].
    ///
    /// Provides immutable access to the value stored for the given `universe`.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let realms = Realms::<usize>::new();
    /// let type_value = realms.of(Universe::Type);
    /// assert_eq!(*type_value, 0);
    /// ```
    #[inline]
    pub const fn of(&self, universe: Universe) -> &T {
        &self.data[universe as usize]
    }

    /// Returns a mutable reference to the value for the specified [`Universe`].
    ///
    /// Provides mutable access to the value stored for the given `universe`.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<usize>::new();
    /// *realms.of_mut(Universe::Type) = 42;
    /// assert_eq!(*realms.of(Universe::Type), 42);
    /// ```
    #[inline]
    pub const fn of_mut(&mut self, universe: Universe) -> &mut T {
        &mut self.data[universe as usize]
    }

    /// Transforms the [`Realms<T>`] into a [`Realms<U>`] by applying a function to each value.
    ///
    /// Maps each value in this container to a new value using the provided closure.
    /// Returns a new [`Realms<U>`] containing the mapped values for each universe.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<usize>::new();
    /// *realms.of_mut(Universe::Type) = 2;
    /// *realms.of_mut(Universe::Value) = 3;
    ///
    /// let doubled = realms.map(|&x| x * 2);
    /// assert_eq!(*doubled.of(Universe::Type), 4);
    /// assert_eq!(*doubled.of(Universe::Value), 6);
    /// ```
    pub fn map<U>(&self, mut closure: impl FnMut(&T) -> U) -> Realms<U>
    where
        U: Default,
    {
        let mut result = Realms::<U>::new();

        for (universe, value) in self.realms() {
            *result.of_mut(universe) = closure(value);
        }

        result
    }

    /// Tests if any value in this container satisfies the predicate.
    ///
    /// Returns `true` if the given predicate returns `true` for at least one value
    /// across all universes.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<i32>::new();
    /// *realms.of_mut(Universe::Type) = -5;
    /// *realms.of_mut(Universe::Value) = 10;
    ///
    /// assert!(realms.any(|&x| x > 0));
    /// assert!(!realms.any(|&x| x > 100));
    /// ```
    #[inline]
    pub fn any(&self, closure: impl FnMut(&T) -> bool) -> bool {
        self.data.iter().any(closure)
    }

    /// Tests if all values in this container satisfy the predicate.
    ///
    /// Returns `true` if the given predicate returns `true` for all values
    /// across all universes.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<i32>::new();
    /// *realms.of_mut(Universe::Type) = 5;
    /// *realms.of_mut(Universe::Value) = 10;
    ///
    /// assert!(realms.all(|&x| x > 0));
    /// assert!(!realms.all(|&x| x > 7));
    /// ```
    #[inline]
    pub fn all(&self, closure: impl FnMut(&T) -> bool) -> bool {
        self.data.iter().all(closure)
    }

    /// Returns an iterator over all universes and their associated values.
    ///
    /// Provides an iterator that yields pairs of [`Universe`] variants and
    /// references to their corresponding values.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let realms = Realms::<usize>::new();
    /// let mut count = 0;
    ///
    /// for (universe, value) in realms.realms() {
    ///     count += 1;
    ///     assert_eq!(*value, 0);
    /// }
    ///
    /// assert_eq!(count, 2); // Two universes: Type and Value
    /// ```
    #[inline]
    pub fn realms(&self) -> impl Iterator<Item = (Universe, &T)> {
        UNIVERSES.iter().copied().zip(self.data.iter())
    }

    /// Returns a mutable iterator over all universes and their associated values.
    ///
    /// Provides an iterator that yields pairs of [`Universe`] variants and
    /// mutable references to their corresponding values.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<usize>::new();
    ///
    /// let mut previous = 0;
    /// for (universe, value) in realms.realms_mut() {
    ///     *value = previous;
    ///     previous += 1;
    /// }
    ///
    /// assert_eq!(*realms.of(Universe::Type), 0);
    /// assert_eq!(*realms.of(Universe::Value), 1);
    /// ```
    #[inline]
    pub fn realms_mut(&mut self) -> impl Iterator<Item = (Universe, &mut T)> {
        UNIVERSES.iter().copied().zip(self.data.iter_mut())
    }
}

impl<K, V, S, A> Realms<HashMap<K, V, S, A>>
where
    K: Eq + Hash,
    A: Allocator,
    S: BuildHasher,
{
    /// Inserts a key-value pair into the [`HashMap`] for the specified [`Universe`].
    ///
    /// Returns the previous value associated with the key, if any.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// // Insert into the Type universe
    /// realms.insert(Universe::Type, "foo", 42);
    /// assert_eq!(realms.get(Universe::Type, &"foo"), Some(&42));
    /// ```
    #[inline]
    pub fn insert(&mut self, universe: Universe, key: K, value: V) -> Option<V> {
        let map = self.of_mut(universe);

        map.insert(key, value)
    }

    /// Inserts a key-value pair into the specified universe map, but only if the key isn't already
    /// present.
    ///
    /// Returns a mutable reference to the inserted value if the key wasn't present, or an
    /// [`OccupiedError`] if the key already exists. The error contains both the key and value
    /// that were attempted to be inserted.
    ///
    /// This method is useful when you need to handle the case of existing keys explicitly,
    /// rather than silently overwriting values as with the standard `insert` method.
    ///
    /// # Errors
    ///
    /// Returns an [`OccupiedError`] if the key already exists in the map.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// // Try to insert into the Type universe
    /// let result = realms.try_insert(Universe::Type, "foo", 42);
    /// assert!(result.is_ok());
    ///
    /// // Trying to insert with the same key will return an error
    /// let result = realms.try_insert(Universe::Type, "foo", 100);
    /// assert!(result.is_err());
    /// ```
    #[inline]
    pub fn try_insert(
        &mut self,
        universe: Universe,
        key: K,
        value: V,
    ) -> Result<&mut V, OccupiedError<'_, K, V, S, A>> {
        let map = self.of_mut(universe);

        map.try_insert(key, value)
    }

    /// Inserts a key-value pair into the specified universe map, panicking if the key already
    /// exists.
    ///
    /// This method is a convenience wrapper around [`Self::try_insert`] that panics with a default
    /// error message if the key already exists in the map. It returns a mutable reference to
    /// the inserted value when successful.
    ///
    /// Use this method when you are certain that the key doesn't exist and want to enforce this
    /// invariant at runtime, treating a key collision as a programming error.
    ///
    /// # Panics
    ///
    /// Panics if the key already exists in the map.
    ///
    /// # Examples
    ///
    /// ```should_panic
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// // This will insert the value and return a mutable reference
    /// let value_ref = realms.insert_unique(Universe::Type, "foo", 42);
    /// assert_eq!(*value_ref, 42);
    ///
    /// // This will panic because "foo" already exists
    /// realms.insert_unique(Universe::Type, "foo", 100);
    /// ```
    #[inline]
    pub fn insert_unique(&mut self, universe: Universe, key: K, value: V) -> &mut V
    where
        V: Debug,
        K: Debug,
    {
        let map = self.of_mut(universe);

        map.try_insert(key, value)
            .expect("key should not already exist in the universe map")
    }

    /// Removes a key from the [`HashMap`] in the specified [`Universe`].
    ///
    /// Returns the value associated with the key, if it exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// realms.insert(Universe::Type, "foo", 42);
    /// assert_eq!(realms.remove(Universe::Type, &"foo"), Some(42));
    /// assert_eq!(realms.remove(Universe::Type, &"foo"), None);
    /// ```
    #[inline]
    pub fn remove<Q>(&mut self, universe: Universe, key: &Q) -> Option<V>
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        let map = self.of_mut(universe);

        map.remove(key)
    }

    /// Checks if the [`HashMap`] in the specified [`Universe`] contains a key.
    ///
    /// Returns `true` if the key exists in the map.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// realms.insert(Universe::Type, "foo", 42);
    /// assert!(realms.contains_key(Universe::Type, &"foo"));
    /// assert!(!realms.contains_key(Universe::Value, &"foo"));
    /// ```
    #[inline]
    pub fn contains_key<Q>(&self, universe: Universe, key: &Q) -> bool
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        let map = self.of(universe);

        map.contains_key(key)
    }

    /// Retrieves a reference to the value associated with a key in the specified [`Universe`].
    ///
    /// Returns `None` if the key doesn't exist in the map.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// realms.insert(Universe::Type, "foo", 42);
    /// assert_eq!(realms.get(Universe::Type, &"foo"), Some(&42));
    /// assert_eq!(realms.get(Universe::Type, &"bar"), None);
    /// ```
    #[inline]
    pub fn get<Q>(&self, universe: Universe, key: &Q) -> Option<&V>
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        self.of(universe).get(key)
    }

    /// Retrieves a mutable reference to the value associated with a key in the specified
    /// [`Universe`].
    ///
    /// Returns `None` if the key doesn't exist in the map.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// realms.insert(Universe::Type, "foo", 42);
    /// if let Some(value) = realms.get_mut(Universe::Type, &"foo") {
    ///     *value += 10;
    /// }
    /// assert_eq!(realms.get(Universe::Type, &"foo"), Some(&52));
    /// ```
    #[inline]
    pub fn get_mut<Q>(&mut self, universe: Universe, key: &Q) -> Option<&mut V>
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        self.of_mut(universe).get_mut(key)
    }

    /// Gets the entry of a key in the [`HashMap`] for the specified [`Universe`] for in-place
    /// manipulation.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// // Insert a value if the key has no value
    /// realms.entry(Universe::Type, "foo").or_insert(42);
    /// assert_eq!(realms.get(Universe::Type, &"foo"), Some(&42));
    ///
    /// // Update an existing value
    /// *realms.entry(Universe::Type, "foo").or_insert(0) += 10;
    /// assert_eq!(realms.get(Universe::Type, &"foo"), Some(&52));
    /// ```
    #[inline]
    pub fn entry(&mut self, universe: Universe, key: K) -> Entry<'_, K, V, S, A> {
        self.of_mut(universe).entry(key)
    }

    /// Retains only the elements of the hashmap in the specified [`Universe`] that satisfy a
    /// predicate.
    ///
    /// In other words, removes all key-value pairs for which the predicate returns `false`.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    /// realms.insert(Universe::Type, "three", 3);
    ///
    /// // Keep only entries with even values
    /// realms.retain(Universe::Type, |_, value| *value % 2 == 0);
    /// assert_eq!(realms.len(Universe::Type), 1);
    /// assert_eq!(realms.get(Universe::Type, &"two"), Some(&2));
    /// ```
    #[inline]
    pub fn retain(&mut self, universe: Universe, closure: impl FnMut(&K, &mut V) -> bool) {
        self.of_mut(universe).retain(closure);
    }

    /// Clears the [`HashMap`] in the specified [`Universe`], removing all key-value pairs.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    /// assert_eq!(realms.len(Universe::Type), 2);
    ///
    /// realms.clear(Universe::Type);
    /// assert_eq!(realms.len(Universe::Type), 0);
    /// ```
    #[inline]
    pub fn clear(&mut self, universe: Universe) {
        self.of_mut(universe).clear();
    }

    /// Returns the number of elements in the [`HashMap`] for the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// assert_eq!(realms.len(Universe::Type), 0);
    ///
    /// realms.insert(Universe::Type, "foo", 1);
    /// realms.insert(Universe::Type, "bar", 2);
    /// assert_eq!(realms.len(Universe::Type), 2);
    /// ```
    #[inline]
    pub fn len(&self, universe: Universe) -> usize {
        self.of(universe).len()
    }

    /// Returns `true` if the [`HashMap`] for the specified [`Universe`] contains no elements.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// assert!(realms.is_empty(Universe::Type));
    ///
    /// realms.insert(Universe::Type, "foo", 1);
    /// assert!(!realms.is_empty(Universe::Type));
    /// ```
    #[inline]
    pub fn is_empty(&self, universe: Universe) -> bool {
        self.of(universe).is_empty()
    }

    /// Returns the capacity of the [`HashMap`] in the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub fn capacity(&self, universe: Universe) -> usize {
        self.of(universe).capacity()
    }

    /// Reserves capacity for at least `additional` more elements in the [`HashMap`] for the
    /// specified [`Universe`].
    ///
    /// This method may reserve more space than requested to avoid frequent reallocations.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    ///
    /// // Pre-allocate space for 10 elements
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub fn reserve(&mut self, universe: Universe, additional: usize) {
        self.of_mut(universe).reserve(additional);
    }

    /// Returns an iterator over the entries in the [`HashMap`] for the specified [`Universe`].
    ///
    /// The iterator yields key-value pairs in arbitrary order.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    ///
    /// let mut sum = 0;
    /// for (_, value) in realms.iter(Universe::Type) {
    ///     sum += value;
    /// }
    /// assert_eq!(sum, 3);
    /// ```
    #[inline]
    pub fn iter(&self, universe: Universe) -> impl Iterator<Item = (&K, &V)> {
        self.of(universe).iter()
    }

    /// Returns a mutable iterator over the entries in the [`HashMap`] for the specified
    /// [`Universe`].
    ///
    /// The iterator yields key-value pairs in arbitrary order, with mutable references to the
    /// values.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    ///
    /// // Double each value
    /// for (_, value) in realms.iter_mut(Universe::Type) {
    ///     *value *= 2;
    /// }
    ///
    /// assert_eq!(realms.get(Universe::Type, &"one"), Some(&2));
    /// assert_eq!(realms.get(Universe::Type, &"two"), Some(&4));
    /// ```
    #[inline]
    pub fn iter_mut(&mut self, universe: Universe) -> impl Iterator<Item = (&K, &mut V)> {
        self.of_mut(universe).iter_mut()
    }

    /// Returns an iterator over the keys in the [`HashMap`] for the specified [`Universe`].
    ///
    /// The iterator yields keys in arbitrary order.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    ///
    /// let keys: Vec<&&str> = realms.keys(Universe::Type).collect();
    /// assert_eq!(keys.len(), 2);
    /// assert!(keys.contains(&&"one"));
    /// assert!(keys.contains(&&"two"));
    /// ```
    #[inline]
    pub fn keys(&self, universe: Universe) -> impl Iterator<Item = &K> {
        self.of(universe).keys()
    }

    /// Returns an iterator over the values in the [`HashMap`] for the specified [`Universe`].
    ///
    /// The iterator yields values in arbitrary order.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    ///
    /// let values: Vec<&i32> = realms.values(Universe::Type).collect();
    /// assert_eq!(values.len(), 2);
    /// assert!(values.contains(&&1));
    /// assert!(values.contains(&&2));
    /// ```
    #[inline]
    pub fn values(&self, universe: Universe) -> impl Iterator<Item = &V> {
        self.of(universe).values()
    }

    /// Returns a mutable iterator over the values in the [`HashMap`] for the specified
    /// [`Universe`].
    ///
    /// The iterator yields mutable references to values in arbitrary order.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashMap,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashMap<&str, i32>>::new();
    /// realms.insert(Universe::Type, "one", 1);
    /// realms.insert(Universe::Type, "two", 2);
    ///
    /// // Double each value
    /// for value in realms.values_mut(Universe::Type) {
    ///     *value *= 2;
    /// }
    ///
    /// assert_eq!(realms.get(Universe::Type, &"one"), Some(&2));
    /// assert_eq!(realms.get(Universe::Type, &"two"), Some(&4));
    /// ```
    #[inline]
    pub fn values_mut(&mut self, universe: Universe) -> impl Iterator<Item = &mut V> {
        self.of_mut(universe).values_mut()
    }
}

/// A specialized [`Realms`] container for [`HashMap`]s.
///
/// This type alias provides a convenient way to work with a collection of [`HashMap`],
/// one for each [`Universe`]. It includes specialized methods for common map operations
/// that are universe-aware.
///
/// Considering using the [`FastRealmsMap`] instead of [`RealmsMap`] for better performance, note
/// that [`FastRealmsMap`] does not offer any `DoS` resistance and should not be used against any
/// user provided input.
pub type RealmsMap<K, V, S, A = Global> = Realms<HashMap<K, V, S, A>>;

/// A specialized [`Realms`] container for [`FastHashMap`]s.
///
/// This type alias provides a convenient way to work with a collection of fast hashmaps,
/// one for each [`Universe`]. It includes specialized methods for common map operations
/// that are universe-aware.
pub type FastRealmsMap<K, V, A = Global> = Realms<FastHashMap<K, V, A>>;

impl<K, S, A> Realms<HashSet<K, S, A>>
where
    K: Eq + Hash,
    A: Allocator,
    S: BuildHasher,
{
    /// Inserts a value into the [`HashSet`] for the specified [`Universe`].
    ///
    /// Returns `true` if the value was not present in the set.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    ///
    /// assert_eq!(realms.insert(Universe::Type, "foo"), true); // Not present before
    /// assert_eq!(realms.insert(Universe::Type, "foo"), false); // Already present
    /// ```
    #[inline]
    pub fn insert(&mut self, universe: Universe, key: K) -> bool {
        let set = self.of_mut(universe);

        set.insert(key)
    }

    /// Removes a value from the [`HashSet`] in the specified [`Universe`].
    ///
    /// Returns `true` if the value was present in the set.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    ///
    /// realms.insert(Universe::Type, "foo");
    /// assert_eq!(realms.remove(Universe::Type, &"foo"), true); // Was present
    /// assert_eq!(realms.remove(Universe::Type, &"foo"), false); // No longer present
    /// ```
    #[inline]
    pub fn remove<Q>(&mut self, universe: Universe, key: &Q) -> bool
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        let set = self.of_mut(universe);

        set.remove(key)
    }

    /// Checks if the [`HashSet`] in the specified [`Universe`] contains a value.
    ///
    /// Returns `true` if the value exists in the set.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    ///
    /// realms.insert(Universe::Type, "foo");
    /// assert!(realms.contains(Universe::Type, &"foo"));
    /// assert!(!realms.contains(Universe::Type, &"bar"));
    /// assert!(!realms.contains(Universe::Value, &"foo"));
    /// ```
    #[inline]
    pub fn contains<Q>(&self, universe: Universe, key: &Q) -> bool
    where
        Q: Hash + Equivalent<K> + ?Sized,
    {
        let set = self.of(universe);

        set.contains(key)
    }

    /// Clears the [`HashSet`] in the specified [`Universe`], removing all elements.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    /// realms.insert(Universe::Type, "foo");
    /// realms.insert(Universe::Type, "bar");
    /// assert_eq!(realms.len(Universe::Type), 2);
    ///
    /// realms.clear(Universe::Type);
    /// assert_eq!(realms.len(Universe::Type), 0);
    /// ```
    #[inline]
    pub fn clear(&mut self, universe: Universe) {
        self.of_mut(universe).clear();
    }

    /// Returns the number of elements in the [`HashSet`] for the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    /// assert_eq!(realms.len(Universe::Type), 0);
    ///
    /// realms.insert(Universe::Type, "foo");
    /// realms.insert(Universe::Type, "bar");
    /// assert_eq!(realms.len(Universe::Type), 2);
    /// ```
    #[inline]
    pub fn len(&self, universe: Universe) -> usize {
        self.of(universe).len()
    }

    /// Returns `true` if the [`HashSet`] for the specified [`Universe`] contains no elements.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    /// assert!(realms.is_empty(Universe::Type));
    ///
    /// realms.insert(Universe::Type, "foo");
    /// assert!(!realms.is_empty(Universe::Type));
    /// ```
    #[inline]
    pub fn is_empty(&self, universe: Universe) -> bool {
        self.of(universe).is_empty()
    }

    /// Returns the capacity of the [`HashSet`] in the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub fn capacity(&self, universe: Universe) -> usize {
        self.of(universe).capacity()
    }

    /// Reserves capacity for at least `additional` more elements in the [`HashSet`] for the
    /// specified [`Universe`].
    ///
    /// This method may reserve more space than requested to avoid frequent reallocations.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    ///
    /// // Pre-allocate space for 10 elements
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub fn reserve(&mut self, universe: Universe, additional: usize) {
        self.of_mut(universe).reserve(additional);
    }

    /// Returns an iterator over the elements in the [`HashSet`] for the specified [`Universe`].
    ///
    /// The iterator yields values in arbitrary order.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::{
    ///     collections::FastHashSet,
    ///     module::universe::{Realms, Universe},
    /// };
    ///
    /// let mut realms = Realms::<FastHashSet<&str>>::new();
    /// realms.insert(Universe::Type, "one");
    /// realms.insert(Universe::Type, "two");
    ///
    /// let values: Vec<&&str> = realms.iter(Universe::Type).collect();
    /// assert_eq!(values.len(), 2);
    /// assert!(values.contains(&&"one"));
    /// assert!(values.contains(&&"two"));
    /// ```
    #[inline]
    pub fn iter(&self, universe: Universe) -> impl Iterator<Item = &K> {
        self.of(universe).iter()
    }
}

/// A specialized [`Realms`] container for [`HashSet`]s.
///
/// This type alias provides a convenient way to work with a collection of [`HashSet`]s,
/// one for each [`Universe`]. It includes specialized methods for common set operations
/// that are universe-aware.
///
/// Considering using the [`FastRealmsSet`] instead of [`RealmsSet`] for better performance, note
/// that [`FastRealmsSet`] does not offer any `DoS` resistance and should not be used against any
/// user provided input.
pub type RealmsSet<K, S, A = Global> = Realms<HashSet<K, S, A>>;

/// A specialized [`Realms`] container for [`FastHashSet`]s.
///
/// This type alias provides a convenient way to work with a collection of [`FastHashSet`]s,
/// one for each [`Universe`]. It includes specialized methods for common set operations
/// that are universe-aware.
pub type FastRealmsSet<K, A = Global> = Realms<FastHashSet<K, A>>;

impl<T, A> Realms<Vec<T, A>>
where
    A: Allocator,
{
    /// Pushes a value to the vector in the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    ///
    /// realms.push(Universe::Type, 42);
    /// realms.push(Universe::Type, 100);
    /// assert_eq!(realms.len(Universe::Type), 2);
    /// assert_eq!(realms.of(Universe::Type), &vec![42, 100]);
    /// ```
    #[inline]
    pub fn push(&mut self, universe: Universe, value: T) {
        let vec = self.of_mut(universe);

        vec.push(value);
    }

    /// Removes the last element from the vector in the specified [`Universe`] and returns it.
    ///
    /// Returns `None` if the vector is empty.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    ///
    /// realms.push(Universe::Type, 42);
    /// realms.push(Universe::Type, 100);
    /// assert_eq!(realms.pop(Universe::Type), Some(100));
    /// assert_eq!(realms.pop(Universe::Type), Some(42));
    /// assert_eq!(realms.pop(Universe::Type), None);
    /// ```
    #[inline]
    pub fn pop(&mut self, universe: Universe) -> Option<T> {
        self.of_mut(universe).pop()
    }

    /// Removes all elements from the vector in the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    ///
    /// realms.push(Universe::Type, 42);
    /// realms.push(Universe::Type, 100);
    /// realms.clear(Universe::Type);
    /// assert_eq!(realms.len(Universe::Type), 0);
    /// ```
    #[inline]
    pub fn clear(&mut self, universe: Universe) {
        self.of_mut(universe).clear();
    }

    /// Returns the number of elements in the vector for the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// assert_eq!(realms.len(Universe::Type), 0);
    ///
    /// realms.push(Universe::Type, 42);
    /// realms.push(Universe::Type, 100);
    /// assert_eq!(realms.len(Universe::Type), 2);
    /// ```
    #[inline]
    pub const fn len(&self, universe: Universe) -> usize {
        self.of(universe).len()
    }

    /// Returns `true` if the vector for the specified [`Universe`] contains no elements.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// assert!(realms.is_empty(Universe::Type));
    ///
    /// realms.push(Universe::Type, 42);
    /// assert!(!realms.is_empty(Universe::Type));
    /// ```
    #[inline]
    pub const fn is_empty(&self, universe: Universe) -> bool {
        self.of(universe).is_empty()
    }

    /// Extends the vector in the specified [`Universe`] with the contents of an iterator.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![1, 2, 3]);
    /// assert_eq!(realms.of(Universe::Type), &vec![1, 2, 3]);
    ///
    /// realms.extend(Universe::Type, vec![4, 5]);
    /// assert_eq!(realms.of(Universe::Type), &vec![1, 2, 3, 4, 5]);
    /// ```
    #[inline]
    pub fn extend<I>(&mut self, universe: Universe, iter: I)
    where
        I: IntoIterator<Item = T>,
    {
        self.of_mut(universe).extend(iter);
    }

    /// Removes an element from the vector in the specified [`Universe`] and returns it.
    ///
    /// The removed element is replaced by the last element of the vector.
    /// This operation is O(1), but does not preserve ordering.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![1, 2, 3, 4]);
    ///
    /// assert_eq!(realms.swap_remove(Universe::Type, 1), 2);
    /// assert_eq!(realms.of(Universe::Type), &vec![1, 4, 3]);
    /// ```
    ///
    /// # Panics
    ///
    /// Panics if `index` is out of bounds.
    pub fn swap_remove(&mut self, universe: Universe, index: usize) -> T {
        self.of_mut(universe).swap_remove(index)
    }

    /// Retains only the elements of the vector in the specified [`Universe`] that satisfy a
    /// predicate.
    ///
    /// In other words, removes all elements for which the predicate returns `false`.
    /// This method operates in place and preserves the order of the remaining elements.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![1, 2, 3, 4, 5]);
    ///
    /// // Keep only even numbers
    /// realms.retain(Universe::Type, |x| *x % 2 == 0);
    /// assert_eq!(realms.of(Universe::Type), &vec![2, 4]);
    /// ```
    pub fn retain(&mut self, universe: Universe, closure: impl FnMut(&mut T) -> bool) {
        self.of_mut(universe).retain_mut(closure);
    }

    /// Returns a reference to an element in the vector for the specified [`Universe`] at the given
    /// index.
    ///
    /// Returns `None` if the index is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![10, 20, 30]);
    ///
    /// assert_eq!(realms.get(Universe::Type, 1), Some(&20));
    /// assert_eq!(realms.get(Universe::Type, 3), None);
    /// ```
    pub fn get(&self, universe: Universe, index: usize) -> Option<&T> {
        self.of(universe).get(index)
    }

    /// Returns a mutable reference to an element in the vector for the specified [`Universe`] at
    /// the given index.
    ///
    /// Returns `None` if the index is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![10, 20, 30]);
    ///
    /// if let Some(value) = realms.get_mut(Universe::Type, 1) {
    ///     *value *= 2;
    /// }
    ///
    /// assert_eq!(realms.of(Universe::Type), &vec![10, 40, 30]);
    /// ```
    pub fn get_mut(&mut self, universe: Universe, index: usize) -> Option<&mut T> {
        self.of_mut(universe).get_mut(index)
    }

    /// Returns the capacity of the vector in the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub const fn capacity(&self, universe: Universe) -> usize {
        self.of(universe).capacity()
    }

    /// Reserves capacity for at least `additional` more elements to be inserted in the vector in
    /// the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.reserve(Universe::Type, 10);
    /// assert!(realms.capacity(Universe::Type) >= 10);
    /// ```
    #[inline]
    pub fn reserve(&mut self, universe: Universe, additional: usize) {
        self.of_mut(universe).reserve(additional);
    }

    /// Returns an iterator over the elements in the vector for the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![1, 2, 3]);
    ///
    /// let mut sum = 0;
    /// for value in realms.iter(Universe::Type) {
    ///     sum += value;
    /// }
    /// assert_eq!(sum, 6);
    /// ```
    #[inline]
    pub fn iter(&self, universe: Universe) -> impl Iterator<Item = &T> {
        self.of(universe).iter()
    }

    /// Returns a mutable iterator over the elements in the vector for the specified [`Universe`].
    ///
    /// # Examples
    ///
    /// ```
    /// use hashql_core::module::universe::{Realms, Universe};
    ///
    /// let mut realms = Realms::<Vec<i32>>::new();
    /// realms.extend(Universe::Type, vec![1, 2, 3]);
    ///
    /// // Double each element
    /// for value in realms.iter_mut(Universe::Type) {
    ///     *value *= 2;
    /// }
    /// assert_eq!(realms.of(Universe::Type), &vec![2, 4, 6]);
    /// ```
    #[inline]
    pub fn iter_mut(&mut self, universe: Universe) -> impl Iterator<Item = &mut T> {
        self.of_mut(universe).iter_mut()
    }
}

/// A specialized [`Realms`] container for [`Vec`]s.
///
/// This type alias provides a convenient way to work with a collection of vectors,
/// one for each [`Universe`]. It includes specialized methods for common vector operations
/// that are universe-aware.
pub type RealmsVec<T, A> = Realms<Vec<T, A>>;

impl<T> Index<Universe> for Realms<T> {
    type Output = T;

    fn index(&self, index: Universe) -> &Self::Output {
        self.of(index)
    }
}

impl<T> IndexMut<Universe> for Realms<T> {
    fn index_mut(&mut self, index: Universe) -> &mut Self::Output {
        self.of_mut(index)
    }
}

impl<T> Debug for Realms<T>
where
    T: Debug,
{
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut r#struct = fmt.debug_struct("Realms");

        for (universe, realm) in self.realms() {
            r#struct.field(universe.as_str(), realm);
        }

        r#struct.finish()
    }
}

impl<T> Default for Realms<T>
where
    T: Default,
{
    fn default() -> Self {
        Self::new()
    }
}
