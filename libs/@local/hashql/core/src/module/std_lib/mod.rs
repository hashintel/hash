use super::{ModuleId, ModuleRegistry, item::IntrinsicItem, locals::TypeDef};
use crate::{
    collection::SmallVec,
    heap::Heap,
    intern::Provisioned,
    module::{
        PartialModule,
        item::{ConstructorItem, Item, ItemKind},
    },
    symbol::Symbol,
};

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
enum ItemDef<'heap> {
    Newtype(TypeDef<'heap>),
    Type(TypeDef<'heap>),
    Intrinsic(IntrinsicItem<'heap>),
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
struct ModuleEntry<'heap> {
    name: Symbol<'heap>,
    kind: ItemDef<'heap>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct ModuleDef<'heap>(SmallVec<ModuleEntry<'heap>>);

impl<'heap> ModuleDef<'heap> {
    fn find(&self, name: Symbol<'heap>) -> Option<ModuleEntry<'heap>> {
        self.0.iter().find(|item| item.name == name).copied()
    }

    fn expect(&self, name: Symbol<'heap>) -> ModuleEntry<'heap> {
        self.find(name).expect("module item not found")
    }
}

struct StandardLibraryContext<'env, 'heap> {
    heap: &'heap Heap,
    registry: &'env ModuleRegistry<'heap>,
    modules: SmallVec<(Symbol<'heap>, ModuleDef<'heap>)>,
}

impl<'env, 'heap> StandardLibraryContext<'env, 'heap> {
    fn new(heap: &'heap Heap, registry: &'env ModuleRegistry<'heap>) -> Self {
        Self {
            heap,
            registry,
            modules: SmallVec::new(),
        }
    }

    fn define_cached<M>(&mut self) -> usize
    where
        M: StandardLibraryModule<'heap>,
    {
        let module_path = M::path(self.heap);
        if let Some(position) = self
            .modules
            .iter()
            .position(|(path, _)| *path == module_path)
        {
            position
        } else {
            let contents = M::define(self);

            let position = self.modules.len();
            self.modules.push((module_path, contents));

            position
        }
    }

    fn manifest<M>(&mut self) -> &ModuleDef<'heap>
    where
        M: StandardLibraryModule<'heap>,
    {
        let index = self.define_cached::<M>();

        &self.modules[index].1
    }

    fn build<M>(&mut self, parent: Provisioned<ModuleId>) -> ModuleId
    where
        M: StandardLibraryModule<'heap>,
    {
        self.registry.intern_module(|id| {
            let items = &self.manifest::<M>().0;

            let mut output = SmallVec::with_capacity(items.capacity() + M::Children::LENGTH);

            for &ModuleEntry { name, kind } in items {
                let items = match kind {
                    ItemDef::Intrinsic(intrinsic) => [Some(ItemKind::Intrinsic(intrinsic)), None],
                    ItemDef::Type(def) => [Some(ItemKind::Type(def)), None],
                    ItemDef::Newtype(def) => [
                        Some(ItemKind::Constructor(ConstructorItem { r#type: def })),
                        Some(ItemKind::Type(def)),
                    ],
                };

                for kind in items.into_iter().flatten() {
                    output.push(Item {
                        module: id.value(),
                        name,
                        kind,
                    });
                }
            }

            // create all the child modules
            let children_names = M::Children::names(self.heap);
            let children_modules = M::Children::modules(self, id);

            for (name, module) in children_names.into_iter().zip(children_modules) {
                output.push(Item {
                    module: id.value(),
                    name,
                    kind: ItemKind::Module(module),
                });
            }

            PartialModule {
                name: M::name(&self.heap),
                parent: parent.value(),
                items: self.registry.intern_items(&output),
            }
        })
    }
}

trait Submodules<'heap> {
    const LENGTH: usize;

    fn names(heap: &'heap Heap) -> impl IntoIterator<Item = Symbol<'heap>>;

    fn modules(
        context: &mut StandardLibraryContext<'_, 'heap>,
        parent: Provisioned<ModuleId>,
    ) -> impl IntoIterator<Item = ModuleId>;
}

impl<'heap> Submodules<'heap> for () {
    const LENGTH: usize = 0;

    fn names(_: &'heap Heap) -> impl IntoIterator<Item = Symbol<'heap>> {
        core::iter::empty()
    }

    fn modules(
        _: &mut StandardLibraryContext<'_, 'heap>,
        _: Provisioned<ModuleId>,
    ) -> impl IntoIterator<Item = ModuleId> {
        core::iter::empty()
    }
}

// To be generated by a macro c:
impl<'heap, M1> Submodules<'heap> for (M1,)
where
    M1: StandardLibraryModule<'heap>,
{
    const LENGTH: usize = 1;

    fn names(heap: &'heap Heap) -> impl IntoIterator<Item = Symbol<'heap>> {
        let M1 = M1::name(heap);

        [M1]
    }

    fn modules(
        context: &mut StandardLibraryContext<'_, 'heap>,
        parent: Provisioned<ModuleId>,
    ) -> impl IntoIterator<Item = ModuleId> {
        let M1 = context.build::<M1>(parent);

        [M1]
    }
}

trait StandardLibraryModule<'heap> {
    type Children: Submodules<'heap>;

    fn name(heap: &'heap Heap) -> Symbol<'heap>;
    fn path(heap: &'heap Heap) -> Symbol<'heap>;

    fn define(context: &mut StandardLibraryContext<'_, 'heap>) -> ModuleDef<'heap>;
}
