/* tslint:disable */
/* eslint-disable */
/**
 * graph
 * HASH Graph API
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from "url";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AllFilter
 */
export interface AllFilter {
  /**
   *
   * @type {Array<Filter>}
   * @memberof AllFilter
   */
  all: Array<Filter>;
}
/**
 *
 * @export
 * @interface AnyFilter
 */
export interface AnyFilter {
  /**
   *
   * @type {Array<Filter>}
   * @memberof AnyFilter
   */
  any: Array<Filter>;
}
/**
 * @type ClosedTemporalBound
 * @export
 */
export type ClosedTemporalBound = InclusiveBound;

/**
 *
 * @export
 * @interface CreateDataTypeRequest
 */
export interface CreateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateDataTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateDataTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {CreateDataTypeRequestSchema}
   * @memberof CreateDataTypeRequest
   */
  schema: CreateDataTypeRequestSchema;
}
/**
 * @type CreateDataTypeRequestSchema
 * @export
 */
export type CreateDataTypeRequestSchema = Array<DataType> | DataType;

/**
 *
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityTypeId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  entityUuid?: string;
  /**
   *
   * @type {CreateEntityRequestLinkData}
   * @memberof CreateEntityRequest
   */
  linkData?: CreateEntityRequestLinkData;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequest
   */
  ownedById: string;
  /**
   *
   * @type {object}
   * @memberof CreateEntityRequest
   */
  properties: object;
}
/**
 *
 * @export
 * @interface CreateEntityRequestLinkData
 */
export interface CreateEntityRequestLinkData {
  /**
   *
   * @type {number}
   * @memberof CreateEntityRequestLinkData
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof CreateEntityRequestLinkData
   */
  rightToLeftOrder?: number;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequestLinkData
   */
  leftEntityId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityRequestLinkData
   */
  rightEntityId: string;
}
/**
 *
 * @export
 * @interface CreateEntityTypeRequest
 */
export interface CreateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreateEntityTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreateEntityTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {CreateEntityTypeRequestSchema}
   * @memberof CreateEntityTypeRequest
   */
  schema: CreateEntityTypeRequestSchema;
}
/**
 * @type CreateEntityTypeRequestSchema
 * @export
 */
export type CreateEntityTypeRequestSchema = Array<EntityType> | EntityType;

/**
 *
 * @export
 * @interface CreatePropertyTypeRequest
 */
export interface CreatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePropertyTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {string}
   * @memberof CreatePropertyTypeRequest
   */
  ownedById: string;
  /**
   *
   * @type {CreatePropertyTypeRequestSchema}
   * @memberof CreatePropertyTypeRequest
   */
  schema: CreatePropertyTypeRequestSchema;
}
/**
 * @type CreatePropertyTypeRequestSchema
 * @export
 */
export type CreatePropertyTypeRequestSchema =
  | Array<PropertyType>
  | PropertyType;

/**
 * Specifies the structure of a Data Type
 * @export
 * @interface DataType
 */
export interface DataType {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof DataType
   */
  $schema: DataTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof DataType
   */
  kind: DataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DataType
   */
  type: string;
}

export const DataTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaDataType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/data-type",
} as const;

export type DataTypeSchemaEnum =
  (typeof DataTypeSchemaEnum)[keyof typeof DataTypeSchemaEnum];
export const DataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type DataTypeKindEnum =
  (typeof DataTypeKindEnum)[keyof typeof DataTypeKindEnum];

/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const DataTypeQueryToken = {
  BaseUrl: "baseUrl",
  Version: "version",
  VersionedUrl: "versionedUrl",
  OwnedById: "ownedById",
  RecordCreatedById: "recordCreatedById",
  Title: "title",
  Description: "description",
  Type: "type",
} as const;

export type DataTypeQueryToken =
  (typeof DataTypeQueryToken)[keyof typeof DataTypeQueryToken];

/**
 *
 * @export
 * @interface DataTypeReference
 */
export interface DataTypeReference {
  /**
   *
   * @type {string}
   * @memberof DataTypeReference
   */
  $ref: string;
}
/**
 *
 * @export
 * @interface DataTypeReferenceUpdate
 */
export interface DataTypeReferenceUpdate {
  /**
   *
   * @type {string}
   * @memberof DataTypeReferenceUpdate
   */
  $ref: string;
}
/**
 *
 * @export
 * @interface DataTypeStructuralQuery
 */
export interface DataTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof DataTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof DataTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {QueryTemporalAxesUnresolved}
   * @memberof DataTypeStructuralQuery
   */
  temporalAxes: QueryTemporalAxesUnresolved;
}
/**
 *
 * @export
 * @interface DataTypeVertex
 */
export interface DataTypeVertex {
  /**
   *
   * @type {DataTypeWithMetadata}
   * @memberof DataTypeVertex
   */
  inner: DataTypeWithMetadata;
  /**
   *
   * @type {string}
   * @memberof DataTypeVertex
   */
  kind: DataTypeVertexKindEnum;
}

export const DataTypeVertexKindEnum = {
  DataType: "dataType",
} as const;

export type DataTypeVertexKindEnum =
  (typeof DataTypeVertexKindEnum)[keyof typeof DataTypeVertexKindEnum];

/**
 *
 * @export
 * @interface DataTypeVertexId
 */
export interface DataTypeVertexId {
  /**
   *
   * @type {string}
   * @memberof DataTypeVertexId
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof DataTypeVertexId
   */
  revisionId: number;
}
/**
 *
 * @export
 * @interface DataTypeWithMetadata
 */
export interface DataTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof DataTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {DataType}
   * @memberof DataTypeWithMetadata
   */
  schema: DataType;
}
/**
 * Time axis for the decision time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const DecisionTime = {
  DecisionTime: "decisionTime",
} as const;

export type DecisionTime = (typeof DecisionTime)[keyof typeof DecisionTime];

/**
 *
 * @export
 * @interface EdgeResolveDepths
 */
export interface EdgeResolveDepths {
  /**
   *
   * @type {number}
   * @memberof EdgeResolveDepths
   */
  incoming: number;
  /**
   *
   * @type {number}
   * @memberof EdgeResolveDepths
   */
  outgoing: number;
}
/**
 *
 * @export
 * @interface Edges
 */
export interface Edges {
  [key: string]: { [key: string]: Array<EdgesValueValueInner> };
}
/**
 * @type EdgesValueValueInner
 * @export
 */
export type EdgesValueValueInner =
  | KnowledgeGraphOutwardEdge
  | OntologyOutwardEdge;

/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated metadata.
 * @export
 * @interface Entity
 */
export interface Entity {
  /**
   *
   * @type {CreateEntityRequestLinkData}
   * @memberof Entity
   */
  linkData?: CreateEntityRequestLinkData;
  /**
   *
   * @type {EntityMetadata}
   * @memberof Entity
   */
  metadata: EntityMetadata;
  /**
   *
   * @type {object}
   * @memberof Entity
   */
  properties: object;
}
/**
 *
 * @export
 * @interface EntityIdWithInterval
 */
export interface EntityIdWithInterval {
  /**
   *
   * @type {string}
   * @memberof EntityIdWithInterval
   */
  entityId: string;
  /**
   *
   * @type {LeftClosedTemporalInterval}
   * @memberof EntityIdWithInterval
   */
  interval: LeftClosedTemporalInterval;
}
/**
 *
 * @export
 * @interface EntityLinkOrder
 */
export interface EntityLinkOrder {
  /**
   *
   * @type {number}
   * @memberof EntityLinkOrder
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof EntityLinkOrder
   */
  rightToLeftOrder?: number;
}
/**
 * The metadata of an [`Entity`] record.
 * @export
 * @interface EntityMetadata
 */
export interface EntityMetadata {
  /**
   *
   * @type {boolean}
   * @memberof EntityMetadata
   */
  archived: boolean;
  /**
   *
   * @type {string}
   * @memberof EntityMetadata
   */
  entityTypeId: string;
  /**
   *
   * @type {ProvenanceMetadata}
   * @memberof EntityMetadata
   */
  provenance: ProvenanceMetadata;
  /**
   *
   * @type {EntityRecordId}
   * @memberof EntityMetadata
   */
  recordId: EntityRecordId;
  /**
   *
   * @type {EntityTemporalMetadata}
   * @memberof EntityMetadata
   */
  temporalVersioning: EntityTemporalMetadata;
}
/**
 * A single token in an [`EntityQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityQueryToken = {
  Uuid: "uuid",
  EditionId: "editionId",
  Archived: "archived",
  OwnedById: "ownedById",
  RecordCreatedById: "recordCreatedById",
  Type: "type",
  Properties: "properties",
  IncomingLinks: "incomingLinks",
  OutgoingLinks: "outgoingLinks",
  LeftEntity: "leftEntity",
  RightEntity: "rightEntity",
  LeftToRightOrder: "leftToRightOrder",
  RightToLeftOrder: "rightToLeftOrder",
} as const;

export type EntityQueryToken =
  (typeof EntityQueryToken)[keyof typeof EntityQueryToken];

/**
 *
 * @export
 * @interface EntityRecordId
 */
export interface EntityRecordId {
  /**
   *
   * @type {string}
   * @memberof EntityRecordId
   */
  editionId: string;
  /**
   *
   * @type {string}
   * @memberof EntityRecordId
   */
  entityId: string;
}
/**
 *
 * @export
 * @interface EntityStructuralQuery
 */
export interface EntityStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof EntityStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof EntityStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {QueryTemporalAxesUnresolved}
   * @memberof EntityStructuralQuery
   */
  temporalAxes: QueryTemporalAxesUnresolved;
}
/**
 *
 * @export
 * @interface EntityTemporalMetadata
 */
export interface EntityTemporalMetadata {
  /**
   *
   * @type {LeftClosedTemporalInterval}
   * @memberof EntityTemporalMetadata
   */
  decisionTime: LeftClosedTemporalInterval;
  /**
   *
   * @type {LeftClosedTemporalInterval}
   * @memberof EntityTemporalMetadata
   */
  transactionTime: LeftClosedTemporalInterval;
}
/**
 * Specifies the structure of an Entity Type
 * @export
 * @interface EntityType
 */
export interface EntityType {
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  $schema: EntityTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  kind: EntityTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  $id: string;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  type: EntityTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof EntityType
   */
  description?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof EntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {object}
   * @memberof EntityType
   */
  links?: object;
}

export const EntityTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaEntityType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type",
} as const;

export type EntityTypeSchemaEnum =
  (typeof EntityTypeSchemaEnum)[keyof typeof EntityTypeSchemaEnum];
export const EntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type EntityTypeKindEnum =
  (typeof EntityTypeKindEnum)[keyof typeof EntityTypeKindEnum];
export const EntityTypeTypeEnum = {
  Object: "object",
} as const;

export type EntityTypeTypeEnum =
  (typeof EntityTypeTypeEnum)[keyof typeof EntityTypeTypeEnum];

/**
 * A single token in a [`EntityTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityTypeQueryToken = {
  BaseUrl: "baseUrl",
  Version: "version",
  VersionedUrl: "versionedUrl",
  OwnedById: "ownedById",
  RecordCreatedById: "recordCreatedById",
  Title: "title",
  Description: "description",
  Examples: "examples",
  Properties: "properties",
  Required: "required",
  Links: "links",
  InheritsFrom: "inheritsFrom",
} as const;

export type EntityTypeQueryToken =
  (typeof EntityTypeQueryToken)[keyof typeof EntityTypeQueryToken];

/**
 *
 * @export
 * @interface EntityTypeStructuralQuery
 */
export interface EntityTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof EntityTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof EntityTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {QueryTemporalAxesUnresolved}
   * @memberof EntityTypeStructuralQuery
   */
  temporalAxes: QueryTemporalAxesUnresolved;
}
/**
 *
 * @export
 * @interface EntityTypeVertex
 */
export interface EntityTypeVertex {
  /**
   *
   * @type {EntityTypeWithMetadata}
   * @memberof EntityTypeVertex
   */
  inner: EntityTypeWithMetadata;
  /**
   *
   * @type {string}
   * @memberof EntityTypeVertex
   */
  kind: EntityTypeVertexKindEnum;
}

export const EntityTypeVertexKindEnum = {
  EntityType: "entityType",
} as const;

export type EntityTypeVertexKindEnum =
  (typeof EntityTypeVertexKindEnum)[keyof typeof EntityTypeVertexKindEnum];

/**
 *
 * @export
 * @interface EntityTypeVertexId
 */
export interface EntityTypeVertexId {
  /**
   *
   * @type {string}
   * @memberof EntityTypeVertexId
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof EntityTypeVertexId
   */
  revisionId: number;
}
/**
 *
 * @export
 * @interface EntityTypeWithMetadata
 */
export interface EntityTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof EntityTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {EntityType}
   * @memberof EntityTypeWithMetadata
   */
  schema: EntityType;
}
/**
 *
 * @export
 * @interface EntityVertex
 */
export interface EntityVertex {
  /**
   *
   * @type {Entity}
   * @memberof EntityVertex
   */
  inner: Entity;
  /**
   *
   * @type {string}
   * @memberof EntityVertex
   */
  kind: EntityVertexKindEnum;
}

export const EntityVertexKindEnum = {
  Entity: "entity",
} as const;

export type EntityVertexKindEnum =
  (typeof EntityVertexKindEnum)[keyof typeof EntityVertexKindEnum];

/**
 *
 * @export
 * @interface EntityVertexId
 */
export interface EntityVertexId {
  /**
   *
   * @type {string}
   * @memberof EntityVertexId
   */
  baseId: string;
  /**
   *
   * @type {string}
   * @memberof EntityVertexId
   */
  revisionId: string;
}
/**
 *
 * @export
 * @interface EqualFilter
 */
export interface EqualFilter {
  /**
   *
   * @type {Array<FilterExpression>}
   * @memberof EqualFilter
   */
  equal: Array<FilterExpression>;
}
/**
 *
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
  /**
   * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
   * @type {string}
   * @memberof ErrorInfo
   */
  reason: string;
  /**
   * The logical grouping to which the \"reason\" belongs. The error domain is typically the registered service name of the tool or product that generates the error.
   * @type {string}
   * @memberof ErrorInfo
   */
  domain: string;
  /**
   * Construct a type with a set of properties K of type T
   * @type {object}
   * @memberof ErrorInfo
   */
  metadata: object;
}
/**
 *
 * @export
 * @interface ExclusiveBound
 */
export interface ExclusiveBound {
  /**
   *
   * @type {string}
   * @memberof ExclusiveBound
   */
  kind: ExclusiveBoundKindEnum;
  /**
   *
   * @type {string}
   * @memberof ExclusiveBound
   */
  limit: string;
}

export const ExclusiveBoundKindEnum = {
  Exclusive: "exclusive",
} as const;

export type ExclusiveBoundKindEnum =
  (typeof ExclusiveBoundKindEnum)[keyof typeof ExclusiveBoundKindEnum];

/**
 *
 * @export
 * @interface ExternalOntologyElementMetadata
 */
export interface ExternalOntologyElementMetadata {
  /**
   *
   * @type {string}
   * @memberof ExternalOntologyElementMetadata
   */
  fetchedAt: string;
  /**
   *
   * @type {ProvenanceMetadata}
   * @memberof ExternalOntologyElementMetadata
   */
  provenance: ProvenanceMetadata;
  /**
   *
   * @type {OntologyTypeRecordId}
   * @memberof ExternalOntologyElementMetadata
   */
  recordId: OntologyTypeRecordId;
}
/**
 * @type Filter
 * @export
 */
export type Filter =
  | AllFilter
  | AnyFilter
  | EqualFilter
  | NotEqualFilter
  | NotFilter;

/**
 * @type FilterExpression
 * @export
 */
export type FilterExpression = ParameterExpression | PathExpression;

/**
 * @type GraphElementVertexId
 * @export
 */
export type GraphElementVertexId =
  | DataTypeVertexId
  | EntityTypeVertexId
  | EntityVertexId
  | PropertyTypeVertexId;

/**
 * TODO: DOC - <https://app.asana.com/0/0/1203438518991188/f>
 * @export
 * @interface GraphResolveDepths
 */
export interface GraphResolveDepths {
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsLinkDestinationsOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsLinksOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsPropertiesOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  constrainsValuesOn: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {EdgeResolveDepths}
   * @memberof GraphResolveDepths
   */
  hasLeftEntity: EdgeResolveDepths;
  /**
   *
   * @type {EdgeResolveDepths}
   * @memberof GraphResolveDepths
   */
  hasRightEntity: EdgeResolveDepths;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  inheritsFrom: OutgoingEdgeResolveDepth;
  /**
   *
   * @type {OutgoingEdgeResolveDepth}
   * @memberof GraphResolveDepths
   */
  isOfType: OutgoingEdgeResolveDepth;
}
/**
 *
 * @export
 * @interface InclusiveBound
 */
export interface InclusiveBound {
  /**
   *
   * @type {string}
   * @memberof InclusiveBound
   */
  kind: InclusiveBoundKindEnum;
  /**
   *
   * @type {string}
   * @memberof InclusiveBound
   */
  limit: string;
}

export const InclusiveBoundKindEnum = {
  Inclusive: "inclusive",
} as const;

export type InclusiveBoundKindEnum =
  (typeof InclusiveBoundKindEnum)[keyof typeof InclusiveBoundKindEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const KnowledgeGraphEdgeKind = {
  LeftEntity: "HAS_LEFT_ENTITY",
  RightEntity: "HAS_RIGHT_ENTITY",
} as const;

export type KnowledgeGraphEdgeKind =
  (typeof KnowledgeGraphEdgeKind)[keyof typeof KnowledgeGraphEdgeKind];

/**
 * @type KnowledgeGraphOutwardEdge
 * @export
 */
export type KnowledgeGraphOutwardEdge =
  | KnowledgeGraphToKnowledgeGraphOutwardEdge
  | KnowledgeGraphToOntologyOutwardEdge;

/**
 *
 * @export
 * @interface KnowledgeGraphToKnowledgeGraphOutwardEdge
 */
export interface KnowledgeGraphToKnowledgeGraphOutwardEdge {
  /**
   *
   * @type {KnowledgeGraphEdgeKind}
   * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
   */
  kind: KnowledgeGraphEdgeKind;
  /**
   *
   * @type {boolean}
   * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
   */
  reversed: boolean;
  /**
   *
   * @type {EntityIdWithInterval}
   * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
   */
  rightEndpoint: EntityIdWithInterval;
}
/**
 *
 * @export
 * @interface KnowledgeGraphToOntologyOutwardEdge
 */
export interface KnowledgeGraphToOntologyOutwardEdge {
  /**
   *
   * @type {SharedEdgeKind}
   * @memberof KnowledgeGraphToOntologyOutwardEdge
   */
  kind: SharedEdgeKind;
  /**
   *
   * @type {boolean}
   * @memberof KnowledgeGraphToOntologyOutwardEdge
   */
  reversed: boolean;
  /**
   *
   * @type {OntologyTypeVertexId}
   * @memberof KnowledgeGraphToOntologyOutwardEdge
   */
  rightEndpoint: OntologyTypeVertexId;
}
/**
 * @type KnowledgeGraphVertex
 * @export
 */
export type KnowledgeGraphVertex = EntityVertex;

/**
 *
 * @export
 * @interface KnowledgeGraphVertices
 */
export interface KnowledgeGraphVertices {
  [key: string]: { [key: string]: KnowledgeGraphVertex };
}
/**
 *
 * @export
 * @interface LeftClosedTemporalInterval
 */
export interface LeftClosedTemporalInterval {
  /**
   *
   * @type {OpenTemporalBound}
   * @memberof LeftClosedTemporalInterval
   */
  end: OpenTemporalBound;
  /**
   *
   * @type {ClosedTemporalBound}
   * @memberof LeftClosedTemporalInterval
   */
  start: ClosedTemporalBound;
}
/**
 * @type LimitedTemporalBound
 * @export
 */
export type LimitedTemporalBound = ExclusiveBound | InclusiveBound;

/**
 * The associated information for \'Link\' entities
 * @export
 * @interface LinkData
 */
export interface LinkData {
  /**
   *
   * @type {number}
   * @memberof LinkData
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof LinkData
   */
  rightToLeftOrder?: number;
  /**
   *
   * @type {string}
   * @memberof LinkData
   */
  leftEntityId: string;
  /**
   *
   * @type {string}
   * @memberof LinkData
   */
  rightEntityId: string;
}
/**
 *
 * @export
 * @interface LinkDataAllOf
 */
export interface LinkDataAllOf {
  /**
   *
   * @type {string}
   * @memberof LinkDataAllOf
   */
  leftEntityId: string;
  /**
   *
   * @type {string}
   * @memberof LinkDataAllOf
   */
  rightEntityId: string;
}
/**
 * @type MaybeListOfOntologyElementMetadata
 * @export
 */
export type MaybeListOfOntologyElementMetadata =
  | Array<OntologyElementMetadata>
  | OntologyElementMetadata;

/**
 *
 * @export
 * @interface NotEqualFilter
 */
export interface NotEqualFilter {
  /**
   *
   * @type {Array<FilterExpression>}
   * @memberof NotEqualFilter
   */
  notEqual: Array<FilterExpression>;
}
/**
 *
 * @export
 * @interface NotFilter
 */
export interface NotFilter {
  /**
   *
   * @type {Filter}
   * @memberof NotFilter
   */
  not: Filter;
}
/**
 *
 * @export
 * @enum {string}
 */

export const OntologyEdgeKind = {
  InheritsFrom: "INHERITS_FROM",
  ConstrainsValuesOn: "CONSTRAINS_VALUES_ON",
  ConstrainsPropertiesOn: "CONSTRAINS_PROPERTIES_ON",
  ConstrainsLinksOn: "CONSTRAINS_LINKS_ON",
  ConstrainsLinkDestinationsOn: "CONSTRAINS_LINK_DESTINATIONS_ON",
} as const;

export type OntologyEdgeKind =
  (typeof OntologyEdgeKind)[keyof typeof OntologyEdgeKind];

/**
 * @type OntologyElementMetadata
 * @export
 */
export type OntologyElementMetadata =
  | ExternalOntologyElementMetadata
  | OwnedOntologyElementMetadata;

/**
 * @type OntologyOutwardEdge
 * @export
 */
export type OntologyOutwardEdge =
  | OntologyToKnowledgeGraphOutwardEdge
  | OntologyToOntologyOutwardEdge;

/**
 *
 * @export
 * @interface OntologyToKnowledgeGraphOutwardEdge
 */
export interface OntologyToKnowledgeGraphOutwardEdge {
  /**
   *
   * @type {SharedEdgeKind}
   * @memberof OntologyToKnowledgeGraphOutwardEdge
   */
  kind: SharedEdgeKind;
  /**
   *
   * @type {boolean}
   * @memberof OntologyToKnowledgeGraphOutwardEdge
   */
  reversed: boolean;
  /**
   *
   * @type {EntityIdWithInterval}
   * @memberof OntologyToKnowledgeGraphOutwardEdge
   */
  rightEndpoint: EntityIdWithInterval;
}
/**
 *
 * @export
 * @interface OntologyToOntologyOutwardEdge
 */
export interface OntologyToOntologyOutwardEdge {
  /**
   *
   * @type {OntologyEdgeKind}
   * @memberof OntologyToOntologyOutwardEdge
   */
  kind: OntologyEdgeKind;
  /**
   *
   * @type {boolean}
   * @memberof OntologyToOntologyOutwardEdge
   */
  reversed: boolean;
  /**
   *
   * @type {OntologyTypeVertexId}
   * @memberof OntologyToOntologyOutwardEdge
   */
  rightEndpoint: OntologyTypeVertexId;
}
/**
 *
 * @export
 * @interface OntologyTypeRecordId
 */
export interface OntologyTypeRecordId {
  /**
   *
   * @type {string}
   * @memberof OntologyTypeRecordId
   */
  baseUrl: string;
  /**
   *
   * @type {number}
   * @memberof OntologyTypeRecordId
   */
  version: number;
}
/**
 * @type OntologyTypeVertexId
 * @export
 */
export type OntologyTypeVertexId =
  | DataTypeVertexId
  | EntityTypeVertexId
  | PropertyTypeVertexId;

/**
 * @type OntologyVertex
 * @export
 */
export type OntologyVertex =
  | DataTypeVertex
  | EntityTypeVertex
  | PropertyTypeVertex;

/**
 *
 * @export
 * @interface OntologyVertices
 */
export interface OntologyVertices {
  [key: string]: { [key: string]: OntologyVertex };
}
/**
 * @type OpenTemporalBound
 * @export
 */
export type OpenTemporalBound = ExclusiveBound | UnboundedBound;

/**
 *
 * @export
 * @interface OutgoingEdgeResolveDepth
 */
export interface OutgoingEdgeResolveDepth {
  /**
   *
   * @type {number}
   * @memberof OutgoingEdgeResolveDepth
   */
  outgoing: number;
}
/**
 *
 * @export
 * @interface OwnedOntologyElementMetadata
 */
export interface OwnedOntologyElementMetadata {
  /**
   *
   * @type {string}
   * @memberof OwnedOntologyElementMetadata
   */
  ownedById: string;
  /**
   *
   * @type {ProvenanceMetadata}
   * @memberof OwnedOntologyElementMetadata
   */
  provenance: ProvenanceMetadata;
  /**
   *
   * @type {OntologyTypeRecordId}
   * @memberof OwnedOntologyElementMetadata
   */
  recordId: OntologyTypeRecordId;
}
/**
 *
 * @export
 * @interface ParameterExpression
 */
export interface ParameterExpression {
  /**
   *
   * @type {any}
   * @memberof ParameterExpression
   */
  parameter: any;
}
/**
 *
 * @export
 * @interface PathExpression
 */
export interface PathExpression {
  /**
   *
   * @type {Array<DataTypeQueryToken | PropertyTypeQueryToken | EntityTypeQueryToken | EntityQueryToken | Selector | string>}
   * @memberof PathExpression
   */
  path: Array<
    | DataTypeQueryToken
    | PropertyTypeQueryToken
    | EntityTypeQueryToken
    | EntityQueryToken
    | Selector
    | string
  >;
}
/**
 *
 * @export
 * @interface PropertyArrayValue
 */
export interface PropertyArrayValue {
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValue
   */
  type: PropertyArrayValueTypeEnum;
  /**
   *
   * @type {PropertyArrayValueItems}
   * @memberof PropertyArrayValue
   */
  items: PropertyArrayValueItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  minItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValue
   */
  maxItems?: number;
}

export const PropertyArrayValueTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueTypeEnum =
  (typeof PropertyArrayValueTypeEnum)[keyof typeof PropertyArrayValueTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueItems
 */
export interface PropertyArrayValueItems {
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyArrayValueItems
   */
  oneOf: Array<PropertyValues>;
}
/**
 *
 * @export
 * @interface PropertyArrayValueUpdate
 */
export interface PropertyArrayValueUpdate {
  /**
   *
   * @type {string}
   * @memberof PropertyArrayValueUpdate
   */
  type: PropertyArrayValueUpdateTypeEnum;
  /**
   *
   * @type {PropertyArrayValueUpdateItems}
   * @memberof PropertyArrayValueUpdate
   */
  items: PropertyArrayValueUpdateItems;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  minItems?: number;
  /**
   *
   * @type {number}
   * @memberof PropertyArrayValueUpdate
   */
  maxItems?: number;
}

export const PropertyArrayValueUpdateTypeEnum = {
  Array: "array",
} as const;

export type PropertyArrayValueUpdateTypeEnum =
  (typeof PropertyArrayValueUpdateTypeEnum)[keyof typeof PropertyArrayValueUpdateTypeEnum];

/**
 *
 * @export
 * @interface PropertyArrayValueUpdateItems
 */
export interface PropertyArrayValueUpdateItems {
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof PropertyArrayValueUpdateItems
   */
  oneOf: Array<PropertyValuesUpdate>;
}
/**
 *
 * @export
 * @interface PropertyObjectValue
 */
export interface PropertyObjectValue {
  /**
   *
   * @type {string}
   * @memberof PropertyObjectValue
   */
  type: PropertyObjectValueTypeEnum;
  /**
   *
   * @type {object}
   * @memberof PropertyObjectValue
   */
  properties: object;
}

export const PropertyObjectValueTypeEnum = {
  Object: "object",
} as const;

export type PropertyObjectValueTypeEnum =
  (typeof PropertyObjectValueTypeEnum)[keyof typeof PropertyObjectValueTypeEnum];

/**
 *
 * @export
 * @interface PropertyObjectValue1
 */
export interface PropertyObjectValue1 {
  /**
   *
   * @type {string}
   * @memberof PropertyObjectValue1
   */
  type: PropertyObjectValue1TypeEnum;
}

export const PropertyObjectValue1TypeEnum = {
  Object: "object",
} as const;

export type PropertyObjectValue1TypeEnum =
  (typeof PropertyObjectValue1TypeEnum)[keyof typeof PropertyObjectValue1TypeEnum];

/**
 * Specifies the structure of a Property Type
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  $schema: PropertyTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof PropertyType
   */
  kind: PropertyTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  $id: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof PropertyType
   */
  description?: string;
  /**
   *
   * @type {Array<PropertyValues>}
   * @memberof PropertyType
   */
  oneOf: Array<PropertyValues>;
}

export const PropertyTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaPropertyType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/property-type",
} as const;

export type PropertyTypeSchemaEnum =
  (typeof PropertyTypeSchemaEnum)[keyof typeof PropertyTypeSchemaEnum];
export const PropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type PropertyTypeKindEnum =
  (typeof PropertyTypeKindEnum)[keyof typeof PropertyTypeKindEnum];

/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const PropertyTypeQueryToken = {
  BaseUrl: "baseUrl",
  Version: "version",
  VersionedUrl: "versionedUrl",
  OwnedById: "ownedById",
  RecordCreatedById: "recordCreatedById",
  Title: "title",
  Description: "description",
  DataTypes: "dataTypes",
  PropertyTypes: "propertyTypes",
} as const;

export type PropertyTypeQueryToken =
  (typeof PropertyTypeQueryToken)[keyof typeof PropertyTypeQueryToken];

/**
 *
 * @export
 * @interface PropertyTypeStructuralQuery
 */
export interface PropertyTypeStructuralQuery {
  /**
   *
   * @type {Filter}
   * @memberof PropertyTypeStructuralQuery
   */
  filter: Filter;
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof PropertyTypeStructuralQuery
   */
  graphResolveDepths: GraphResolveDepths;
  /**
   *
   * @type {QueryTemporalAxesUnresolved}
   * @memberof PropertyTypeStructuralQuery
   */
  temporalAxes: QueryTemporalAxesUnresolved;
}
/**
 *
 * @export
 * @interface PropertyTypeVertex
 */
export interface PropertyTypeVertex {
  /**
   *
   * @type {PropertyTypeWithMetadata}
   * @memberof PropertyTypeVertex
   */
  inner: PropertyTypeWithMetadata;
  /**
   *
   * @type {string}
   * @memberof PropertyTypeVertex
   */
  kind: PropertyTypeVertexKindEnum;
}

export const PropertyTypeVertexKindEnum = {
  PropertyType: "propertyType",
} as const;

export type PropertyTypeVertexKindEnum =
  (typeof PropertyTypeVertexKindEnum)[keyof typeof PropertyTypeVertexKindEnum];

/**
 *
 * @export
 * @interface PropertyTypeVertexId
 */
export interface PropertyTypeVertexId {
  /**
   *
   * @type {string}
   * @memberof PropertyTypeVertexId
   */
  baseId: string;
  /**
   *
   * @type {number}
   * @memberof PropertyTypeVertexId
   */
  revisionId: number;
}
/**
 *
 * @export
 * @interface PropertyTypeWithMetadata
 */
export interface PropertyTypeWithMetadata {
  /**
   *
   * @type {OntologyElementMetadata}
   * @memberof PropertyTypeWithMetadata
   */
  metadata: OntologyElementMetadata;
  /**
   *
   * @type {PropertyType}
   * @memberof PropertyTypeWithMetadata
   */
  schema: PropertyType;
}
/**
 * @type PropertyValues
 * @export
 */
export type PropertyValues =
  | DataTypeReference
  | PropertyArrayValue
  | PropertyObjectValue;

/**
 * @type PropertyValuesUpdate
 * @export
 */
export type PropertyValuesUpdate =
  | DataTypeReferenceUpdate
  | PropertyArrayValueUpdate
  | PropertyObjectValue1;

/**
 *
 * @export
 * @interface ProvenanceMetadata
 */
export interface ProvenanceMetadata {
  /**
   *
   * @type {string}
   * @memberof ProvenanceMetadata
   */
  recordCreatedById: string;
}
/**
 * @type QueryTemporalAxes
 * Defines the two possible combinations of pinned/variable temporal axes that are used in responses to queries that return [`Subgraph`]s.  When querying the Graph, temporal data is returned. The Graph is implemented as a bitemporal data store, which means the knowledge data contains information about the time of when the knowledge was inserted into the Graph, the [`TransactionTime`], and when the knowledge was decided to be inserted, the [`DecisionTime`].  In order to query data from the Graph, only one of the two time axes can be used. This is achieved by using a `TemporalAxes`. The `TemporalAxes` pins one axis to a specified [`Timestamp`], while the other axis can be a [`Interval`]. The pinned axis is called the [`PinnedTemporalAxis`] and the other axis is called the [`VariableTemporalAxis`]. The returned data will then only contain temporal data that is contained in the [`Interval`] of the [`VariableTemporalAxis`] for the given [`Timestamp`] of the [`PinnedTemporalAxis`].  [`Subgraph`]: crate::subgraph::Subgraph [`Interval`]: crate::interval::Interval
 * @export
 */
export type QueryTemporalAxes =
  | QueryTemporalAxesDecisionTime
  | QueryTemporalAxesTransactionTime;

/**
 *
 * @export
 * @interface QueryTemporalAxesDecisionTime
 */
export interface QueryTemporalAxesDecisionTime {
  /**
   *
   * @type {QueryTemporalAxesDecisionTimePinned}
   * @memberof QueryTemporalAxesDecisionTime
   */
  pinned: QueryTemporalAxesDecisionTimePinned;
  /**
   *
   * @type {QueryTemporalAxesDecisionTimeVariable}
   * @memberof QueryTemporalAxesDecisionTime
   */
  variable: QueryTemporalAxesDecisionTimeVariable;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesDecisionTimePinned
 */
export interface QueryTemporalAxesDecisionTimePinned {
  /**
   *
   * @type {TransactionTime}
   * @memberof QueryTemporalAxesDecisionTimePinned
   */
  axis: TransactionTime;
  /**
   *
   * @type {string}
   * @memberof QueryTemporalAxesDecisionTimePinned
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesDecisionTimeVariable
 */
export interface QueryTemporalAxesDecisionTimeVariable {
  /**
   *
   * @type {DecisionTime}
   * @memberof QueryTemporalAxesDecisionTimeVariable
   */
  axis: DecisionTime;
  /**
   *
   * @type {RightBoundedTemporalInterval}
   * @memberof QueryTemporalAxesDecisionTimeVariable
   */
  interval: RightBoundedTemporalInterval;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesTransactionTime
 */
export interface QueryTemporalAxesTransactionTime {
  /**
   *
   * @type {QueryTemporalAxesTransactionTimePinned}
   * @memberof QueryTemporalAxesTransactionTime
   */
  pinned: QueryTemporalAxesTransactionTimePinned;
  /**
   *
   * @type {QueryTemporalAxesTransactionTimeVariable}
   * @memberof QueryTemporalAxesTransactionTime
   */
  variable: QueryTemporalAxesTransactionTimeVariable;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesTransactionTimePinned
 */
export interface QueryTemporalAxesTransactionTimePinned {
  /**
   *
   * @type {DecisionTime}
   * @memberof QueryTemporalAxesTransactionTimePinned
   */
  axis: DecisionTime;
  /**
   *
   * @type {string}
   * @memberof QueryTemporalAxesTransactionTimePinned
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesTransactionTimeVariable
 */
export interface QueryTemporalAxesTransactionTimeVariable {
  /**
   *
   * @type {TransactionTime}
   * @memberof QueryTemporalAxesTransactionTimeVariable
   */
  axis: TransactionTime;
  /**
   *
   * @type {RightBoundedTemporalInterval}
   * @memberof QueryTemporalAxesTransactionTimeVariable
   */
  interval: RightBoundedTemporalInterval;
}
/**
 * @type QueryTemporalAxesUnresolved
 * Defines the two possible combinations of pinned/variable temporal axes that are used in queries that return [`Subgraph`]s.  The [`VariableTemporalAxisUnresolved`] is optionally bounded, in the absence of provided bounds an inclusive bound at the timestamp at point of resolving is assumed.  [`Subgraph`]: crate::subgraph::Subgraph
 * @export
 */
export type QueryTemporalAxesUnresolved =
  | QueryTemporalAxesUnresolvedDecisionTime
  | QueryTemporalAxesUnresolvedTransactionTime;

/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedDecisionTime
 */
export interface QueryTemporalAxesUnresolvedDecisionTime {
  /**
   *
   * @type {QueryTemporalAxesUnresolvedDecisionTimePinned}
   * @memberof QueryTemporalAxesUnresolvedDecisionTime
   */
  pinned: QueryTemporalAxesUnresolvedDecisionTimePinned;
  /**
   *
   * @type {QueryTemporalAxesUnresolvedDecisionTimeVariable}
   * @memberof QueryTemporalAxesUnresolvedDecisionTime
   */
  variable: QueryTemporalAxesUnresolvedDecisionTimeVariable;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedDecisionTimePinned
 */
export interface QueryTemporalAxesUnresolvedDecisionTimePinned {
  /**
   *
   * @type {TransactionTime}
   * @memberof QueryTemporalAxesUnresolvedDecisionTimePinned
   */
  axis: TransactionTime;
  /**
   *
   * @type {string}
   * @memberof QueryTemporalAxesUnresolvedDecisionTimePinned
   */
  timestamp: string | null;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedDecisionTimeVariable
 */
export interface QueryTemporalAxesUnresolvedDecisionTimeVariable {
  /**
   *
   * @type {DecisionTime}
   * @memberof QueryTemporalAxesUnresolvedDecisionTimeVariable
   */
  axis: DecisionTime;
  /**
   *
   * @type {UnresolvedRightBoundedTemporalInterval}
   * @memberof QueryTemporalAxesUnresolvedDecisionTimeVariable
   */
  interval: UnresolvedRightBoundedTemporalInterval;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedTransactionTime
 */
export interface QueryTemporalAxesUnresolvedTransactionTime {
  /**
   *
   * @type {QueryTemporalAxesUnresolvedTransactionTimePinned}
   * @memberof QueryTemporalAxesUnresolvedTransactionTime
   */
  pinned: QueryTemporalAxesUnresolvedTransactionTimePinned;
  /**
   *
   * @type {QueryTemporalAxesUnresolvedTransactionTimeVariable}
   * @memberof QueryTemporalAxesUnresolvedTransactionTime
   */
  variable: QueryTemporalAxesUnresolvedTransactionTimeVariable;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedTransactionTimePinned
 */
export interface QueryTemporalAxesUnresolvedTransactionTimePinned {
  /**
   *
   * @type {DecisionTime}
   * @memberof QueryTemporalAxesUnresolvedTransactionTimePinned
   */
  axis: DecisionTime;
  /**
   *
   * @type {string}
   * @memberof QueryTemporalAxesUnresolvedTransactionTimePinned
   */
  timestamp: string | null;
}
/**
 *
 * @export
 * @interface QueryTemporalAxesUnresolvedTransactionTimeVariable
 */
export interface QueryTemporalAxesUnresolvedTransactionTimeVariable {
  /**
   *
   * @type {TransactionTime}
   * @memberof QueryTemporalAxesUnresolvedTransactionTimeVariable
   */
  axis: TransactionTime;
  /**
   *
   * @type {UnresolvedRightBoundedTemporalInterval}
   * @memberof QueryTemporalAxesUnresolvedTransactionTimeVariable
   */
  interval: UnresolvedRightBoundedTemporalInterval;
}
/**
 *
 * @export
 * @interface RequestInfo
 */
export interface RequestInfo {
  /**
   * An opaque string that should only be interpreted by the service generating it. For example, it can be used to identify requests in the service\'s logs.
   * @type {string}
   * @memberof RequestInfo
   */
  requestId: string;
  /**
   * Any data that was used to serve this request. For example, an encrypted stack trace that can be sent back to the service provider for debugging.
   * @type {string}
   * @memberof RequestInfo
   */
  servingData: string;
}
/**
 *
 * @export
 * @interface ResourceInfo
 */
export interface ResourceInfo {
  /**
   * A name for the type of resource being accessed.  For example \"SQL table\", \"Entity\", \"Property Type\", \"Redis\"; or the type URL of the resource: e.g. \"https://blockprotocol.org/type-system/0.3/schema/meta/entity-type\".
   * @type {string}
   * @memberof ResourceInfo
   */
  resourceType: string;
  /**
   * The name of the resource being accessed.  For example, an ontology type ID: `https://hash.ai/@alice/types/entity-type/Person/`, if the current error is [@local/status/StatusCode.PermissionDenied].
   * @type {string}
   * @memberof ResourceInfo
   */
  resourceName: string;
  /**
   * The owner of the resource (optional).  For example, a User\'s entity ID: `2cfa262a-f49a-4a61-a9c5-80a0c5959994%45e528cb-801d-49d1-8f71-d9e2af38a5e7`;
   * @type {string}
   * @memberof ResourceInfo
   */
  owner?: string;
  /**
   * Describes what error is encountered when accessing this resource.  For example, updating a property on a user\'s entity may require write permission on that property.
   * @type {string}
   * @memberof ResourceInfo
   */
  description: string;
}
/**
 *
 * @export
 * @interface RightBoundedTemporalInterval
 */
export interface RightBoundedTemporalInterval {
  /**
   *
   * @type {LimitedTemporalBound}
   * @memberof RightBoundedTemporalInterval
   */
  end: LimitedTemporalBound;
  /**
   *
   * @type {TemporalBound}
   * @memberof RightBoundedTemporalInterval
   */
  start: TemporalBound;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Selector = {
  Star: "*",
} as const;

export type Selector = (typeof Selector)[keyof typeof Selector];

/**
 *
 * @export
 * @enum {string}
 */

export const SharedEdgeKind = {
  IsOfType: "IS_OF_TYPE",
} as const;

export type SharedEdgeKind =
  (typeof SharedEdgeKind)[keyof typeof SharedEdgeKind];

/**
 *
 * @export
 * @interface Status
 */
export interface Status {
  /**
   *
   * @type {StatusCode}
   * @memberof Status
   */
  code: StatusCode;
  /**
   * A developer-facing description of the status.  Where possible, this should provide guiding advice for debugging and/or handling the error.
   * @type {string}
   * @memberof Status
   */
  message?: string;
  /**
   *
   * @type {Array<StatusContentsInner>}
   * @memberof Status
   */
  contents: Array<StatusContentsInner>;
}
/**
 * The canonical status codes for software within the HASH ecosystem. Sometimes multiple status codes may apply. Services should return the most specific status code that applies. For example, prefer `OutOfRange` over `FailedPrecondition` if both codes apply. Similarly prefer `NotFound` or `AlreadyExists` over `FailedPrecondition`.
 * @export
 * @enum {string}
 */

export const StatusCode = {
  Aborted: "ABORTED",
  AlreadyExists: "ALREADY_EXISTS",
  Cancelled: "CANCELLED",
  DataLoss: "DATA_LOSS",
  DeadlineExceeded: "DEADLINE_EXCEEDED",
  FailedPrecondition: "FAILED_PRECONDITION",
  Internal: "INTERNAL",
  InvalidArgument: "INVALID_ARGUMENT",
  NotFound: "NOT_FOUND",
  Ok: "OK",
  OutOfRange: "OUT_OF_RANGE",
  PermissionDenied: "PERMISSION_DENIED",
  ResourceExhausted: "RESOURCE_EXHAUSTED",
  Unauthenticated: "UNAUTHENTICATED",
  Unavailable: "UNAVAILABLE",
  Unimplemented: "UNIMPLEMENTED",
  Unknown: "UNKNOWN",
} as const;

export type StatusCode = (typeof StatusCode)[keyof typeof StatusCode];

/**
 * @type StatusContentsInner
 * @export
 */
export type StatusContentsInner = ErrorInfo | RequestInfo | ResourceInfo;

/**
 *
 * @export
 * @interface Subgraph
 */
export interface Subgraph {
  /**
   *
   * @type {GraphResolveDepths}
   * @memberof Subgraph
   */
  depths: GraphResolveDepths;
  /**
   *
   * @type {Edges}
   * @memberof Subgraph
   */
  edges: Edges;
  /**
   *
   * @type {Array<GraphElementVertexId>}
   * @memberof Subgraph
   */
  roots: Array<GraphElementVertexId>;
  /**
   *
   * @type {SubgraphTemporalAxes}
   * @memberof Subgraph
   */
  temporalAxes: SubgraphTemporalAxes;
  /**
   *
   * @type {Vertices}
   * @memberof Subgraph
   */
  vertices: Vertices;
}
/**
 *
 * @export
 * @interface SubgraphTemporalAxes
 */
export interface SubgraphTemporalAxes {
  /**
   *
   * @type {QueryTemporalAxesUnresolved}
   * @memberof SubgraphTemporalAxes
   */
  initial: QueryTemporalAxesUnresolved;
  /**
   *
   * @type {QueryTemporalAxes}
   * @memberof SubgraphTemporalAxes
   */
  resolved: QueryTemporalAxes;
}
/**
 * @type TemporalBound
 * @export
 */
export type TemporalBound = ExclusiveBound | InclusiveBound | UnboundedBound;

/**
 * Time axis for the transaction time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const TransactionTime = {
  TransactionTime: "transactionTime",
} as const;

export type TransactionTime =
  (typeof TransactionTime)[keyof typeof TransactionTime];

/**
 *
 * @export
 * @interface UnboundedBound
 */
export interface UnboundedBound {
  /**
   *
   * @type {string}
   * @memberof UnboundedBound
   */
  kind: UnboundedBoundKindEnum;
}

export const UnboundedBoundKindEnum = {
  Unbounded: "unbounded",
} as const;

export type UnboundedBoundKindEnum =
  (typeof UnboundedBoundKindEnum)[keyof typeof UnboundedBoundKindEnum];

/**
 *
 * @export
 * @interface UnresolvedRightBoundedTemporalInterval
 */
export interface UnresolvedRightBoundedTemporalInterval {
  /**
   *
   * @type {UnresolvedRightBoundedTemporalIntervalEnd}
   * @memberof UnresolvedRightBoundedTemporalInterval
   */
  end: UnresolvedRightBoundedTemporalIntervalEnd | null;
  /**
   *
   * @type {UnresolvedRightBoundedTemporalIntervalStart}
   * @memberof UnresolvedRightBoundedTemporalInterval
   */
  start: UnresolvedRightBoundedTemporalIntervalStart | null;
}
/**
 * @type UnresolvedRightBoundedTemporalIntervalEnd
 * @export
 */
export type UnresolvedRightBoundedTemporalIntervalEnd = LimitedTemporalBound;

/**
 * @type UnresolvedRightBoundedTemporalIntervalStart
 * @export
 */
export type UnresolvedRightBoundedTemporalIntervalStart = TemporalBound;

/**
 * The contents of a Data Type update request
 * @export
 * @interface UpdateDataType
 */
export interface UpdateDataType {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  $schema: UpdateDataTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof UpdateDataType
   */
  kind: UpdateDataTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateDataType
   */
  type: string;
}

export const UpdateDataTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaDataType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/data-type",
} as const;

export type UpdateDataTypeSchemaEnum =
  (typeof UpdateDataTypeSchemaEnum)[keyof typeof UpdateDataTypeSchemaEnum];
export const UpdateDataTypeKindEnum = {
  DataType: "dataType",
} as const;

export type UpdateDataTypeKindEnum =
  (typeof UpdateDataTypeKindEnum)[keyof typeof UpdateDataTypeKindEnum];

/**
 *
 * @export
 * @interface UpdateDataTypeRequest
 */
export interface UpdateDataTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdateDataType}
   * @memberof UpdateDataTypeRequest
   */
  schema: UpdateDataType;
  /**
   *
   * @type {string}
   * @memberof UpdateDataTypeRequest
   */
  typeToUpdate: string;
}
/**
 *
 * @export
 * @interface UpdateEntityRequest
 */
export interface UpdateEntityRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateEntityRequest
   */
  leftToRightOrder?: number;
  /**
   *
   * @type {number}
   * @memberof UpdateEntityRequest
   */
  rightToLeftOrder?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  actorId: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateEntityRequest
   */
  archived: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequest
   */
  entityTypeId: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityRequest
   */
  properties: object;
}
/**
 *
 * @export
 * @interface UpdateEntityRequestAllOf
 */
export interface UpdateEntityRequestAllOf {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  actorId: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateEntityRequestAllOf
   */
  archived: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  entityId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityRequestAllOf
   */
  entityTypeId: string;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityRequestAllOf
   */
  properties: object;
}
/**
 * The contents of an Entity Type update request
 * @export
 * @interface UpdateEntityType
 */
export interface UpdateEntityType {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  $schema: UpdateEntityTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  kind: UpdateEntityTypeKindEnum;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  type: UpdateEntityTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityType
   */
  description?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof UpdateEntityType
   */
  examples?: Array<object>;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  properties: object;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateEntityType
   */
  required?: Array<string>;
  /**
   *
   * @type {object}
   * @memberof UpdateEntityType
   */
  links?: object;
}

export const UpdateEntityTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaEntityType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type",
} as const;

export type UpdateEntityTypeSchemaEnum =
  (typeof UpdateEntityTypeSchemaEnum)[keyof typeof UpdateEntityTypeSchemaEnum];
export const UpdateEntityTypeKindEnum = {
  EntityType: "entityType",
} as const;

export type UpdateEntityTypeKindEnum =
  (typeof UpdateEntityTypeKindEnum)[keyof typeof UpdateEntityTypeKindEnum];
export const UpdateEntityTypeTypeEnum = {
  Object: "object",
} as const;

export type UpdateEntityTypeTypeEnum =
  (typeof UpdateEntityTypeTypeEnum)[keyof typeof UpdateEntityTypeTypeEnum];

/**
 *
 * @export
 * @interface UpdateEntityTypeRequest
 */
export interface UpdateEntityTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdateEntityType}
   * @memberof UpdateEntityTypeRequest
   */
  schema: UpdateEntityType;
  /**
   *
   * @type {string}
   * @memberof UpdateEntityTypeRequest
   */
  typeToUpdate: string;
}
/**
 * The contents of a Property Type update request
 * @export
 * @interface UpdatePropertyType
 */
export interface UpdatePropertyType {
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  $schema: UpdatePropertyTypeSchemaEnum;
  /**
   *
   * @type {object}
   * @memberof UpdatePropertyType
   */
  kind: UpdatePropertyTypeKindEnum;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyType
   */
  description?: string;
  /**
   *
   * @type {Array<PropertyValuesUpdate>}
   * @memberof UpdatePropertyType
   */
  oneOf: Array<PropertyValuesUpdate>;
}

export const UpdatePropertyTypeSchemaEnum = {
  HttpsBlockprotocolOrgTypesModulesGraph03SchemaPropertyType:
    "https://blockprotocol.org/types/modules/graph/0.3/schema/property-type",
} as const;

export type UpdatePropertyTypeSchemaEnum =
  (typeof UpdatePropertyTypeSchemaEnum)[keyof typeof UpdatePropertyTypeSchemaEnum];
export const UpdatePropertyTypeKindEnum = {
  PropertyType: "propertyType",
} as const;

export type UpdatePropertyTypeKindEnum =
  (typeof UpdatePropertyTypeKindEnum)[keyof typeof UpdatePropertyTypeKindEnum];

/**
 *
 * @export
 * @interface UpdatePropertyTypeRequest
 */
export interface UpdatePropertyTypeRequest {
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  actorId: string;
  /**
   *
   * @type {UpdatePropertyType}
   * @memberof UpdatePropertyTypeRequest
   */
  schema: UpdatePropertyType;
  /**
   *
   * @type {string}
   * @memberof UpdatePropertyTypeRequest
   */
  typeToUpdate: string;
}
/**
 * @type Vertex
 * @export
 */
export type Vertex = KnowledgeGraphVertex | OntologyVertex;

/**
 *
 * @export
 * @interface Vertices
 */
export interface Vertices {
  [key: string]: { [key: string]: VerticesValueValue };
}
/**
 * @type VerticesValueValue
 * @export
 */
export type VerticesValueValue = KnowledgeGraphVertex | OntologyVertex;

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataTypeApi - axios parameter creator
 * @export
 */
export const DataTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "dataTypeStructuralQuery",
        dataTypeStructuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataTypeApi - functional programming interface
 * @export
 */
export const DataTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          dataTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DataTypeApi - factory interface
 * @export
 */
export const DataTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DataTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(dataTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataTypeApi - interface
 * @export
 * @interface DataTypeApi
 */
export interface DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * DataTypeApi - object-oriented interface
 * @export
 * @class DataTypeApi
 * @extends {BaseAPI}
 */
export class DataTypeApi extends BaseAPI implements DataTypeApiInterface {
  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .getDataTypesByQuery(dataTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataTypeApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return DataTypeApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      entityStructuralQuery: EntityStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "entityStructuralQuery",
        entityStructuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          entityStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntitiesByQuery(entityStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityApi - interface
 * @export
 * @interface EntityApi
 */
export interface EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;
}

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI implements EntityApiInterface {
  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .getEntitiesByQuery(entityStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EntityTypeApi - axios parameter creator
 * @export
 */
export const EntityTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "entityTypeStructuralQuery",
        entityTypeStructuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntityTypeApi - functional programming interface
 * @export
 */
export const EntityTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EntityTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          entityTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * EntityTypeApi - factory interface
 * @export
 */
export const EntityTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EntityTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntityTypesByQuery(entityTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EntityTypeApi - interface
 * @export
 * @interface EntityTypeApi
 */
export interface EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * EntityTypeApi - object-oriented interface
 * @export
 * @class EntityTypeApi
 * @extends {BaseAPI}
 */
export class EntityTypeApi extends BaseAPI implements EntityTypeApiInterface {
  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .getEntityTypesByQuery(entityTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntityTypeApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return EntityTypeApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType: async (
      createDataTypeRequest: CreateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDataTypeRequest' is not null or undefined
      assertParamExists(
        "createDataType",
        "createDataTypeRequest",
        createDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (
      createEntityRequest: CreateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityRequest' is not null or undefined
      assertParamExists(
        "createEntity",
        "createEntityRequest",
        createEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType: async (
      createEntityTypeRequest: CreateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createEntityTypeRequest' is not null or undefined
      assertParamExists(
        "createEntityType",
        "createEntityTypeRequest",
        createEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery: async (
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getDataTypesByQuery",
        "dataTypeStructuralQuery",
        dataTypeStructuralQuery,
      );
      const localVarPath = `/data-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery: async (
      entityStructuralQuery: EntityStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntitiesByQuery",
        "entityStructuralQuery",
        entityStructuralQuery,
      );
      const localVarPath = `/entities/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery: async (
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'entityTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getEntityTypesByQuery",
        "entityTypeStructuralQuery",
        entityTypeStructuralQuery,
      );
      const localVarPath = `/entity-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        entityTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'propertyTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "propertyTypeStructuralQuery",
        propertyTypeStructuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType: async (
      updateDataTypeRequest: UpdateDataTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateDataTypeRequest' is not null or undefined
      assertParamExists(
        "updateDataType",
        "updateDataTypeRequest",
        updateDataTypeRequest,
      );
      const localVarPath = `/data-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDataTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (
      updateEntityRequest: UpdateEntityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityRequest' is not null or undefined
      assertParamExists(
        "updateEntity",
        "updateEntityRequest",
        updateEntityRequest,
      );
      const localVarPath = `/entities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType: async (
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateEntityTypeRequest' is not null or undefined
      assertParamExists(
        "updateEntityType",
        "updateEntityTypeRequest",
        updateEntityTypeRequest,
      );
      const localVarPath = `/entity-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEntityTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccountId(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountId(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(
        createDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(
        createEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createEntityType(
          createEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataTypesByQuery(
          dataTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntitiesByQuery(
          entityStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEntityTypesByQuery(
          entityTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          propertyTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(
        updateDataTypeRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(
        updateEntityRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateEntityType(
          updateEntityTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GraphApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccountId(options?: any): AxiosPromise<string> {
      return localVarFp
        .createAccountId(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateDataTypeRequest} createDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDataType(
      createDataTypeRequest: CreateDataTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createDataType(createDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityRequest} createEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(
      createEntityRequest: CreateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .createEntity(createEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateEntityTypeRequest} createEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntityType(
      createEntityTypeRequest: CreateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createEntityType(createEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataTypesByQuery(
      dataTypeStructuralQuery: DataTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getDataTypesByQuery(dataTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityStructuralQuery} entityStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntitiesByQuery(
      entityStructuralQuery: EntityStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntitiesByQuery(entityStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityTypesByQuery(
      entityTypeStructuralQuery: EntityTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getEntityTypesByQuery(entityTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateDataTypeRequest} updateDataTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDataType(
      updateDataTypeRequest: UpdateDataTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateDataType(updateDataTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityRequest} updateEntityRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(
      updateEntityRequest: UpdateEntityRequest,
      options?: any,
    ): AxiosPromise<EntityMetadata> {
      return localVarFp
        .updateEntity(updateEntityRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntityType(
      updateEntityTypeRequest: UpdateEntityTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updateEntityType(updateEntityTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GraphApi - interface
 * @export
 * @interface GraphApi
 */
export interface GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createAccountId(options?: AxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<EntityMetadata>;

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI implements GraphApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createAccountId(options?: AxiosRequestConfig) {
    return GraphApiFp(this.configuration)
      .createAccountId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateDataTypeRequest} createDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createDataType(
    createDataTypeRequest: CreateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createDataType(createDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityRequest} createEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntity(
    createEntityRequest: CreateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntity(createEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateEntityTypeRequest} createEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createEntityType(
    createEntityTypeRequest: CreateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createEntityType(createEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DataTypeStructuralQuery} dataTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getDataTypesByQuery(
    dataTypeStructuralQuery: DataTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getDataTypesByQuery(dataTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityStructuralQuery} entityStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntitiesByQuery(
    entityStructuralQuery: EntityStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntitiesByQuery(entityStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {EntityTypeStructuralQuery} entityTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getEntityTypesByQuery(
    entityTypeStructuralQuery: EntityTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getEntityTypesByQuery(entityTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateDataTypeRequest} updateDataTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateDataType(
    updateDataTypeRequest: UpdateDataTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateDataType(updateDataTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityRequest} updateEntityRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntity(
    updateEntityRequest: UpdateEntityRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntity(updateEntityRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateEntityTypeRequest} updateEntityTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updateEntityType(
    updateEntityTypeRequest: UpdateEntityTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updateEntityType(updateEntityTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return GraphApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyTypeApi - axios parameter creator
 * @export
 */
export const PropertyTypeApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType: async (
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPropertyTypeRequest' is not null or undefined
      assertParamExists(
        "createPropertyType",
        "createPropertyTypeRequest",
        createPropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery: async (
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'propertyTypeStructuralQuery' is not null or undefined
      assertParamExists(
        "getPropertyTypesByQuery",
        "propertyTypeStructuralQuery",
        propertyTypeStructuralQuery,
      );
      const localVarPath = `/property-types/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        propertyTypeStructuralQuery,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType: async (
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
      assertParamExists(
        "updatePropertyType",
        "updatePropertyTypeRequest",
        updatePropertyTypeRequest,
      );
      const localVarPath = `/property-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePropertyTypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyTypeApi - functional programming interface
 * @export
 */
export const PropertyTypeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PropertyTypeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MaybeListOfOntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPropertyType(
          createPropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subgraph>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyTypesByQuery(
          propertyTypeStructuralQuery,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<OntologyElementMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePropertyType(
          updatePropertyTypeRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PropertyTypeApi - factory interface
 * @export
 */
export const PropertyTypeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PropertyTypeApiFp(configuration);
  return {
    /**
     *
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPropertyType(
      createPropertyTypeRequest: CreatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<MaybeListOfOntologyElementMetadata> {
      return localVarFp
        .createPropertyType(createPropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyTypesByQuery(
      propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
      options?: any,
    ): AxiosPromise<Subgraph> {
      return localVarFp
        .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePropertyType(
      updatePropertyTypeRequest: UpdatePropertyTypeRequest,
      options?: any,
    ): AxiosPromise<OntologyElementMetadata> {
      return localVarFp
        .updatePropertyType(updatePropertyTypeRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PropertyTypeApi - interface
 * @export
 * @interface PropertyTypeApi
 */
export interface PropertyTypeApiInterface {
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<MaybeListOfOntologyElementMetadata>;

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Subgraph>;

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApiInterface
   */
  updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<OntologyElementMetadata>;
}

/**
 * PropertyTypeApi - object-oriented interface
 * @export
 * @class PropertyTypeApi
 * @extends {BaseAPI}
 */
export class PropertyTypeApi
  extends BaseAPI
  implements PropertyTypeApiInterface
{
  /**
   *
   * @param {CreatePropertyTypeRequest} createPropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public createPropertyType(
    createPropertyTypeRequest: CreatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .createPropertyType(createPropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PropertyTypeStructuralQuery} propertyTypeStructuralQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public getPropertyTypesByQuery(
    propertyTypeStructuralQuery: PropertyTypeStructuralQuery,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .getPropertyTypesByQuery(propertyTypeStructuralQuery, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyTypeApi
   */
  public updatePropertyType(
    updatePropertyTypeRequest: UpdatePropertyTypeRequest,
    options?: AxiosRequestConfig,
  ) {
    return PropertyTypeApiFp(this.configuration)
      .updatePropertyType(updatePropertyTypeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
