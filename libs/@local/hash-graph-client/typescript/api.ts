/* tslint:disable */
/* eslint-disable */
/**
 * graph
 * HASH Graph API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration.js';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
import type { RequestArgs } from './base.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base.js';

/**
 * 
 * @export
 * @enum {string}
 */

export const AccountGroupPermission = {
    AddMember: 'add_member',
    RemoveMember: 'remove_member'
} as const;

export type AccountGroupPermission = typeof AccountGroupPermission[keyof typeof AccountGroupPermission];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActorType = {
    Human: 'human',
    Ai: 'ai',
    Machine: 'machine'
} as const;

export type ActorType = typeof ActorType[keyof typeof ActorType];


/**
 * 
 * @export
 * @interface AllFilter
 */
export interface AllFilter {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof AllFilter
     */
    'all': Array<Filter>;
}
/**
 * 
 * @export
 * @interface AnyFilter
 */
export interface AnyFilter {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof AnyFilter
     */
    'any': Array<Filter>;
}
/**
 * 
 * @export
 * @interface ArchiveDataTypeParams
 */
export interface ArchiveDataTypeParams {
    /**
     * 
     * @type {string}
     * @memberof ArchiveDataTypeParams
     */
    'dataTypeId': string;
}
/**
 * 
 * @export
 * @interface ArchiveEntityTypeParams
 */
export interface ArchiveEntityTypeParams {
    /**
     * 
     * @type {string}
     * @memberof ArchiveEntityTypeParams
     */
    'entityTypeId': string;
}
/**
 * 
 * @export
 * @interface ArchivePropertyTypeParams
 */
export interface ArchivePropertyTypeParams {
    /**
     * 
     * @type {string}
     * @memberof ArchivePropertyTypeParams
     */
    'propertyTypeId': string;
}
/**
 * 
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * 
     * @type {number}
     * @memberof ArrayMetadata
     */
    'confidence'?: number;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof ArrayMetadata
     */
    'provenance'?: PropertyProvenance;
}
/**
 * Specifies the closed structure of a Block Protocol entity type
 * @export
 * @interface ClosedEntityType
 */
export interface ClosedEntityType {
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof ClosedEntityType
     */
    '$id': string;
    /**
     * 
     * @type {string}
     * @memberof ClosedEntityType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ClosedEntityType
     */
    'titlePlural'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClosedEntityType
     */
    'description': string;
    /**
     * 
     * @type {Array<EntityTypeDisplayMetadata>}
     * @memberof ClosedEntityType
     */
    'allOf'?: Array<EntityTypeDisplayMetadata>;
    /**
     * A JSON object where each entry is constrained by a property type.
     * @type {object}
     * @memberof ClosedEntityType
     */
    'properties': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClosedEntityType
     */
    'required'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ClosedEntityType
     */
    'links'?: object;
}
/**
 * Specifies the closed structure which combines multiple entity types
 * @export
 * @interface ClosedMultiEntityType
 */
export interface ClosedMultiEntityType {
    /**
     * 
     * @type {Array<ClosedMultiEntityTypeAllOfInner>}
     * @memberof ClosedMultiEntityType
     */
    'allOf'?: Array<ClosedMultiEntityTypeAllOfInner>;
    /**
     * A JSON object where each entry is constrained by a property type.
     * @type {object}
     * @memberof ClosedMultiEntityType
     */
    'properties': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClosedMultiEntityType
     */
    'required'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ClosedMultiEntityType
     */
    'links'?: object;
}
/**
 * 
 * @export
 * @interface ClosedMultiEntityTypeAllOfInner
 */
export interface ClosedMultiEntityTypeAllOfInner {
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof ClosedMultiEntityTypeAllOfInner
     */
    '$id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClosedMultiEntityTypeAllOfInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClosedMultiEntityTypeAllOfInner
     */
    'titlePlural'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClosedMultiEntityTypeAllOfInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<EntityTypeDisplayMetadata>}
     * @memberof ClosedMultiEntityTypeAllOfInner
     */
    'allOf'?: Array<EntityTypeDisplayMetadata>;
}
/**
 * @type ClosedTemporalBound
 * @export
 */
export type ClosedTemporalBound = InclusiveBound;

/**
 * 
 * @export
 * @interface ContainsSegmentFilter
 */
export interface ContainsSegmentFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof ContainsSegmentFilter
     */
    'containsSegment': Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface ConversionDefinition
 */
export interface ConversionDefinition {
    /**
     * 
     * @type {ConversionExpression}
     * @memberof ConversionDefinition
     */
    'expression': ConversionExpression;
}
/**
 * 
 * @export
 * @interface ConversionExpression
 */
export interface ConversionExpression extends Array<ConversionExpressionInner> {
}
/**
 * @type ConversionExpressionInner
 * @export
 */
export type ConversionExpressionInner = ConversionValue | Operator;

/**
 * @type ConversionValue
 * @export
 */
export type ConversionValue = ConversionExpression | ConversionValueOneOf | Variable;

/**
 * 
 * @export
 * @interface ConversionValueOneOf
 */
export interface ConversionValueOneOf {
    /**
     * 
     * @type {number}
     * @memberof ConversionValueOneOf
     */
    'const': number;
    /**
     * 
     * @type {string}
     * @memberof ConversionValueOneOf
     */
    'type': ConversionValueOneOfTypeEnum;
}

export const ConversionValueOneOfTypeEnum = {
    Number: 'number'
} as const;

export type ConversionValueOneOfTypeEnum = typeof ConversionValueOneOfTypeEnum[keyof typeof ConversionValueOneOfTypeEnum];

/**
 * 
 * @export
 * @interface Conversions
 */
export interface Conversions {
    /**
     * 
     * @type {ConversionDefinition}
     * @memberof Conversions
     */
    'from': ConversionDefinition;
    /**
     * 
     * @type {ConversionDefinition}
     * @memberof Conversions
     */
    'to': ConversionDefinition;
}
/**
 * 
 * @export
 * @interface CosineDistanceFilter
 */
export interface CosineDistanceFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof CosineDistanceFilter
     */
    'cosineDistance': Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface CountEntitiesParams
 */
export interface CountEntitiesParams {
    /**
     * 
     * @type {Filter}
     * @memberof CountEntitiesParams
     */
    'filter': Filter;
    /**
     * 
     * @type {boolean}
     * @memberof CountEntitiesParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof CountEntitiesParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface CreateDataTypeRequest
 */
export interface CreateDataTypeRequest {
    /**
     * 
     * @type {{ [key: string]: Conversions; }}
     * @memberof CreateDataTypeRequest
     */
    'conversions': { [key: string]: Conversions; };
    /**
     * 
     * @type {string}
     * @memberof CreateDataTypeRequest
     */
    'ownedById': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof CreateDataTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<DataTypeRelationAndSubject>}
     * @memberof CreateDataTypeRequest
     */
    'relationships': Array<DataTypeRelationAndSubject>;
    /**
     * 
     * @type {CreateDataTypeRequestSchema}
     * @memberof CreateDataTypeRequest
     */
    'schema': CreateDataTypeRequestSchema;
}
/**
 * @type CreateDataTypeRequestSchema
 * @export
 */
export type CreateDataTypeRequestSchema = Array<DataType> | DataType;

/**
 * 
 * @export
 * @interface CreateEntityRequest
 */
export interface CreateEntityRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateEntityRequest
     */
    'confidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequest
     */
    'decisionTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateEntityRequest
     */
    'draft': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEntityRequest
     */
    'entityTypeIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequest
     */
    'entityUuid'?: string;
    /**
     * 
     * @type {CreateEntityRequestLinkData}
     * @memberof CreateEntityRequest
     */
    'linkData'?: CreateEntityRequestLinkData;
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequest
     */
    'ownedById': string;
    /**
     * 
     * @type {PropertyWithMetadataObject}
     * @memberof CreateEntityRequest
     */
    'properties': PropertyWithMetadataObject;
    /**
     * 
     * @type {ProvidedEntityEditionProvenance}
     * @memberof CreateEntityRequest
     */
    'provenance'?: ProvidedEntityEditionProvenance;
    /**
     * 
     * @type {Array<EntityRelationAndSubject>}
     * @memberof CreateEntityRequest
     */
    'relationships': Array<EntityRelationAndSubject>;
}
/**
 * 
 * @export
 * @interface CreateEntityRequestLinkData
 */
export interface CreateEntityRequestLinkData {
    /**
     * 
     * @type {number}
     * @memberof CreateEntityRequestLinkData
     */
    'leftEntityConfidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequestLinkData
     */
    'leftEntityId': string;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof CreateEntityRequestLinkData
     */
    'leftEntityProvenance'?: PropertyProvenance;
    /**
     * 
     * @type {number}
     * @memberof CreateEntityRequestLinkData
     */
    'rightEntityConfidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequestLinkData
     */
    'rightEntityId': string;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof CreateEntityRequestLinkData
     */
    'rightEntityProvenance'?: PropertyProvenance;
}
/**
 * 
 * @export
 * @interface CreateEntityTypeRequest
 */
export interface CreateEntityTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateEntityTypeRequest
     */
    'ownedById': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof CreateEntityTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<EntityTypeRelationAndSubject>}
     * @memberof CreateEntityTypeRequest
     */
    'relationships': Array<EntityTypeRelationAndSubject>;
    /**
     * 
     * @type {CreateEntityTypeRequestSchema}
     * @memberof CreateEntityTypeRequest
     */
    'schema': CreateEntityTypeRequestSchema;
}
/**
 * @type CreateEntityTypeRequestSchema
 * @export
 */
export type CreateEntityTypeRequestSchema = Array<EntityType> | EntityType;

/**
 * 
 * @export
 * @interface CreatePropertyTypeRequest
 */
export interface CreatePropertyTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePropertyTypeRequest
     */
    'ownedById': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof CreatePropertyTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<PropertyTypeRelationAndSubject>}
     * @memberof CreatePropertyTypeRequest
     */
    'relationships': Array<PropertyTypeRelationAndSubject>;
    /**
     * 
     * @type {CreatePropertyTypeRequestSchema}
     * @memberof CreatePropertyTypeRequest
     */
    'schema': CreatePropertyTypeRequestSchema;
}
/**
 * @type CreatePropertyTypeRequestSchema
 * @export
 */
export type CreatePropertyTypeRequestSchema = Array<PropertyType> | PropertyType;

/**
 * Specifies the structure of a Data Type
 * @export
 * @interface DataType
 */
export interface DataType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    '$schema': DataTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'kind': DataTypeKindEnum;
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof DataType
     */
    '$id': string;
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'description': string;
    /**
     * 
     * @type {UpdateDataTypeType}
     * @memberof DataType
     */
    'type'?: UpdateDataTypeType;
}

export const DataTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaDataType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/data-type'
} as const;

export type DataTypeSchemaEnum = typeof DataTypeSchemaEnum[keyof typeof DataTypeSchemaEnum];
export const DataTypeKindEnum = {
    DataType: 'dataType'
} as const;

export type DataTypeKindEnum = typeof DataTypeKindEnum[keyof typeof DataTypeKindEnum];

/**
 * @type DataTypeMetadata
 * @export
 */
export type DataTypeMetadata = ExternalDataTypeMetadata | OwnedDataTypeMetadata;

/**
 * @type DataTypeOwnerSubject
 * @export
 */
export type DataTypeOwnerSubject = DataTypeOwnerSubjectOneOf;

/**
 * 
 * @export
 * @interface DataTypeOwnerSubjectOneOf
 */
export interface DataTypeOwnerSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof DataTypeOwnerSubjectOneOf
     */
    'kind': DataTypeOwnerSubjectOneOfKindEnum;
    /**
     * 
     * @type {string}
     * @memberof DataTypeOwnerSubjectOneOf
     */
    'subjectId': string;
}

export const DataTypeOwnerSubjectOneOfKindEnum = {
    Web: 'web'
} as const;

export type DataTypeOwnerSubjectOneOfKindEnum = typeof DataTypeOwnerSubjectOneOfKindEnum[keyof typeof DataTypeOwnerSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DataTypePermission = {
    Update: 'update',
    View: 'view'
} as const;

export type DataTypePermission = typeof DataTypePermission[keyof typeof DataTypePermission];


/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const DataTypeQueryToken = {
    BaseUrl: 'baseUrl',
    Version: 'version',
    VersionedUrl: 'versionedUrl',
    OwnedById: 'ownedById',
    Title: 'title',
    Description: 'description',
    Type: 'type',
    InheritsFrom: 'inheritsFrom',
    Children: 'children',
    EditionProvenance: 'editionProvenance',
    Embedding: 'embedding'
} as const;

export type DataTypeQueryToken = typeof DataTypeQueryToken[keyof typeof DataTypeQueryToken];


/**
 * 
 * @export
 * @interface DataTypeReference
 */
export interface DataTypeReference {
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof DataTypeReference
     */
    '$ref': string;
}
/**
 * @type DataTypeRelationAndSubject
 * @export
 */
export type DataTypeRelationAndSubject = DataTypeRelationAndSubjectOneOf | DataTypeRelationAndSubjectOneOf1;

/**
 * 
 * @export
 * @interface DataTypeRelationAndSubjectOneOf
 */
export interface DataTypeRelationAndSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof DataTypeRelationAndSubjectOneOf
     */
    'relation': DataTypeRelationAndSubjectOneOfRelationEnum;
    /**
     * 
     * @type {DataTypeOwnerSubject}
     * @memberof DataTypeRelationAndSubjectOneOf
     */
    'subject': DataTypeOwnerSubject;
}

export const DataTypeRelationAndSubjectOneOfRelationEnum = {
    Owner: 'owner'
} as const;

export type DataTypeRelationAndSubjectOneOfRelationEnum = typeof DataTypeRelationAndSubjectOneOfRelationEnum[keyof typeof DataTypeRelationAndSubjectOneOfRelationEnum];

/**
 * 
 * @export
 * @interface DataTypeRelationAndSubjectOneOf1
 */
export interface DataTypeRelationAndSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof DataTypeRelationAndSubjectOneOf1
     */
    'relation': DataTypeRelationAndSubjectOneOf1RelationEnum;
    /**
     * 
     * @type {DataTypeViewerSubject}
     * @memberof DataTypeRelationAndSubjectOneOf1
     */
    'subject': DataTypeViewerSubject;
}

export const DataTypeRelationAndSubjectOneOf1RelationEnum = {
    Viewer: 'viewer'
} as const;

export type DataTypeRelationAndSubjectOneOf1RelationEnum = typeof DataTypeRelationAndSubjectOneOf1RelationEnum[keyof typeof DataTypeRelationAndSubjectOneOf1RelationEnum];

/**
 * 
 * @export
 * @interface DataTypeVertex
 */
export interface DataTypeVertex {
    /**
     * 
     * @type {DataTypeWithMetadata}
     * @memberof DataTypeVertex
     */
    'inner': DataTypeWithMetadata;
    /**
     * 
     * @type {string}
     * @memberof DataTypeVertex
     */
    'kind': DataTypeVertexKindEnum;
}

export const DataTypeVertexKindEnum = {
    DataType: 'dataType'
} as const;

export type DataTypeVertexKindEnum = typeof DataTypeVertexKindEnum[keyof typeof DataTypeVertexKindEnum];

/**
 * 
 * @export
 * @interface DataTypeVertexId
 */
export interface DataTypeVertexId {
    /**
     * 
     * @type {string}
     * @memberof DataTypeVertexId
     */
    'baseId': string;
    /**
     * 
     * @type {number}
     * @memberof DataTypeVertexId
     */
    'revisionId': number;
}
/**
 * @type DataTypeViewerSubject
 * @export
 */
export type DataTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * 
 * @export
 * @interface DataTypeViewerSubjectOneOf
 */
export interface DataTypeViewerSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof DataTypeViewerSubjectOneOf
     */
    'kind': DataTypeViewerSubjectOneOfKindEnum;
}

export const DataTypeViewerSubjectOneOfKindEnum = {
    Public: 'public'
} as const;

export type DataTypeViewerSubjectOneOfKindEnum = typeof DataTypeViewerSubjectOneOfKindEnum[keyof typeof DataTypeViewerSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @interface DataTypeWithMetadata
 */
export interface DataTypeWithMetadata {
    /**
     * 
     * @type {DataTypeMetadata}
     * @memberof DataTypeWithMetadata
     */
    'metadata': DataTypeMetadata;
    /**
     * 
     * @type {DataType}
     * @memberof DataTypeWithMetadata
     */
    'schema': DataType;
}
/**
 * Time axis for the decision time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const DecisionTime = {
    DecisionTime: 'decisionTime'
} as const;

export type DecisionTime = typeof DecisionTime[keyof typeof DecisionTime];


/**
 * 
 * @export
 * @interface DiffEntityParams
 */
export interface DiffEntityParams {
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'firstDecisionTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'firstEntityId': string;
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'firstTransactionTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'secondDecisionTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'secondEntityId': string;
    /**
     * 
     * @type {string}
     * @memberof DiffEntityParams
     */
    'secondTransactionTime': string | null;
}
/**
 * 
 * @export
 * @interface DiffEntityResult
 */
export interface DiffEntityResult {
    /**
     * 
     * @type {boolean}
     * @memberof DiffEntityResult
     */
    'draftState'?: boolean;
    /**
     * 
     * @type {Array<EntityTypeIdDiff>}
     * @memberof DiffEntityResult
     */
    'entityTypeIds'?: Array<EntityTypeIdDiff>;
    /**
     * 
     * @type {Array<PropertyDiff>}
     * @memberof DiffEntityResult
     */
    'properties'?: Array<PropertyDiff>;
}
/**
 * 
 * @export
 * @interface EdgeResolveDepths
 */
export interface EdgeResolveDepths {
    /**
     * 
     * @type {number}
     * @memberof EdgeResolveDepths
     */
    'incoming': number;
    /**
     * 
     * @type {number}
     * @memberof EdgeResolveDepths
     */
    'outgoing': number;
}
/**
 * 
 * @export
 * @interface Edges
 */
export interface Edges {
    [key: string]: { [key: string]: Array<EdgesValueValueInner>; };

}
/**
 * @type EdgesValueValueInner
 * @export
 */
export type EdgesValueValueInner = KnowledgeGraphOutwardEdge | OntologyOutwardEdge;

/**
 * 
 * @export
 * @interface Embedding
 */
export interface Embedding extends Array<number> {
}
/**
 * 
 * @export
 * @interface EndsWithFilter
 */
export interface EndsWithFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof EndsWithFilter
     */
    'endsWith': Array<FilterExpression>;
}
/**
 * A record of an [`Entity`] that has been persisted in the datastore, with its associated metadata.
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {CreateEntityRequestLinkData}
     * @memberof Entity
     */
    'linkData'?: CreateEntityRequestLinkData;
    /**
     * 
     * @type {EntityMetadata}
     * @memberof Entity
     */
    'metadata': EntityMetadata;
    /**
     * 
     * @type {PropertyObject}
     * @memberof Entity
     */
    'properties': PropertyObject;
}
/**
 * @type EntityAdministratorSubject
 * @export
 */
export type EntityAdministratorSubject = EntityAdministratorSubjectOneOf | EntityAdministratorSubjectOneOf1;

/**
 * 
 * @export
 * @interface EntityAdministratorSubjectOneOf
 */
export interface EntityAdministratorSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityAdministratorSubjectOneOf
     */
    'kind': EntityAdministratorSubjectOneOfKindEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityAdministratorSubjectOneOf
     */
    'subjectId': string;
}

export const EntityAdministratorSubjectOneOfKindEnum = {
    Account: 'account'
} as const;

export type EntityAdministratorSubjectOneOfKindEnum = typeof EntityAdministratorSubjectOneOfKindEnum[keyof typeof EntityAdministratorSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @interface EntityAdministratorSubjectOneOf1
 */
export interface EntityAdministratorSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof EntityAdministratorSubjectOneOf1
     */
    'kind': EntityAdministratorSubjectOneOf1KindEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityAdministratorSubjectOneOf1
     */
    'subjectId': string;
    /**
     * 
     * @type {EntitySubjectSet}
     * @memberof EntityAdministratorSubjectOneOf1
     */
    'subjectSet': EntitySubjectSet;
}

export const EntityAdministratorSubjectOneOf1KindEnum = {
    AccountGroup: 'accountGroup'
} as const;

export type EntityAdministratorSubjectOneOf1KindEnum = typeof EntityAdministratorSubjectOneOf1KindEnum[keyof typeof EntityAdministratorSubjectOneOf1KindEnum];

/**
 * 
 * @export
 * @interface EntityEditionProvenance
 */
export interface EntityEditionProvenance {
    /**
     * 
     * @type {ActorType}
     * @memberof EntityEditionProvenance
     */
    'actorType'?: ActorType;
    /**
     * 
     * @type {ProvidedEntityEditionProvenanceOrigin}
     * @memberof EntityEditionProvenance
     */
    'origin'?: ProvidedEntityEditionProvenanceOrigin;
    /**
     * 
     * @type {Array<SourceProvenance>}
     * @memberof EntityEditionProvenance
     */
    'sources'?: Array<SourceProvenance>;
    /**
     * 
     * @type {string}
     * @memberof EntityEditionProvenance
     */
    'archivedById'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityEditionProvenance
     */
    'createdById': string;
}


/**
 * 
 * @export
 * @interface EntityEditionProvenanceAllOf
 */
export interface EntityEditionProvenanceAllOf {
    /**
     * 
     * @type {string}
     * @memberof EntityEditionProvenanceAllOf
     */
    'archivedById'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityEditionProvenanceAllOf
     */
    'createdById': string;
}
/**
 * @type EntityEditorSubject
 * @export
 */
export type EntityEditorSubject = EntityAdministratorSubjectOneOf | EntityAdministratorSubjectOneOf1;

/**
 * 
 * @export
 * @interface EntityEmbedding
 */
export interface EntityEmbedding {
    /**
     * 
     * @type {Embedding}
     * @memberof EntityEmbedding
     */
    'embedding': Embedding;
    /**
     * 
     * @type {string}
     * @memberof EntityEmbedding
     */
    'property'?: string | null;
}
/**
 * 
 * @export
 * @interface EntityIdWithInterval
 */
export interface EntityIdWithInterval {
    /**
     * 
     * @type {string}
     * @memberof EntityIdWithInterval
     */
    'entityId': string;
    /**
     * 
     * @type {LeftClosedTemporalInterval}
     * @memberof EntityIdWithInterval
     */
    'interval': LeftClosedTemporalInterval;
}
/**
 * The metadata of an [`Entity`] record.
 * @export
 * @interface EntityMetadata
 */
export interface EntityMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof EntityMetadata
     */
    'archived': boolean;
    /**
     * 
     * @type {number}
     * @memberof EntityMetadata
     */
    'confidence'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityMetadata
     */
    'entityTypeIds': Array<string>;
    /**
     * 
     * @type {PropertyMetadataObject}
     * @memberof EntityMetadata
     */
    'properties'?: PropertyMetadataObject;
    /**
     * 
     * @type {EntityProvenance}
     * @memberof EntityMetadata
     */
    'provenance': EntityProvenance;
    /**
     * 
     * @type {EntityRecordId}
     * @memberof EntityMetadata
     */
    'recordId': EntityRecordId;
    /**
     * 
     * @type {EntityTemporalMetadata}
     * @memberof EntityMetadata
     */
    'temporalVersioning': EntityTemporalMetadata;
}
/**
 * @type EntityOwnerSubject
 * @export
 */
export type EntityOwnerSubject = DataTypeOwnerSubjectOneOf;

/**
 * 
 * @export
 * @enum {string}
 */

export const EntityPermission = {
    FullAccess: 'full_access',
    Update: 'update',
    View: 'view'
} as const;

export type EntityPermission = typeof EntityPermission[keyof typeof EntityPermission];


/**
 * 
 * @export
 * @interface EntityProvenance
 */
export interface EntityProvenance {
    /**
     * 
     * @type {string}
     * @memberof EntityProvenance
     */
    'createdAtDecisionTime': string;
    /**
     * 
     * @type {string}
     * @memberof EntityProvenance
     */
    'createdAtTransactionTime': string;
    /**
     * 
     * @type {string}
     * @memberof EntityProvenance
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof EntityProvenance
     */
    'firstNonDraftCreatedAtDecisionTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityProvenance
     */
    'firstNonDraftCreatedAtTransactionTime'?: string;
    /**
     * 
     * @type {EntityEditionProvenance}
     * @memberof EntityProvenance
     */
    'edition': EntityEditionProvenance;
}
/**
 * 
 * @export
 * @interface EntityProvenanceAllOf
 */
export interface EntityProvenanceAllOf {
    /**
     * 
     * @type {EntityEditionProvenance}
     * @memberof EntityProvenanceAllOf
     */
    'edition': EntityEditionProvenance;
}
/**
 * 
 * @export
 * @interface EntityQueryCursor
 */
export interface EntityQueryCursor extends Array<object> {
}
/**
 * 
 * @export
 * @interface EntityQuerySortingPath
 */
export interface EntityQuerySortingPath extends Array<EntityQuerySortingPathInner> {
}
/**
 * @type EntityQuerySortingPathInner
 * @export
 */
export type EntityQuerySortingPathInner = EntityQuerySortingToken | number | string;

/**
 * 
 * @export
 * @interface EntityQuerySortingRecord
 */
export interface EntityQuerySortingRecord {
    /**
     * 
     * @type {NullOrdering}
     * @memberof EntityQuerySortingRecord
     */
    'nulls': NullOrdering;
    /**
     * 
     * @type {Ordering}
     * @memberof EntityQuerySortingRecord
     */
    'ordering': Ordering;
    /**
     * 
     * @type {EntityQuerySortingPath}
     * @memberof EntityQuerySortingRecord
     */
    'path': EntityQuerySortingPath;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityQuerySortingToken = {
    Uuid: 'uuid',
    Archived: 'archived',
    Properties: 'properties',
    Label: 'label',
    RecordCreatedAtTransactionTime: 'recordCreatedAtTransactionTime',
    RecordCreatedAtDecisionTime: 'recordCreatedAtDecisionTime',
    CreatedAtTransactionTime: 'createdAtTransactionTime',
    CreatedAtDecisionTime: 'createdAtDecisionTime',
    TypeTitle: 'typeTitle'
} as const;

export type EntityQuerySortingToken = typeof EntityQuerySortingToken[keyof typeof EntityQuerySortingToken];


/**
 * A single token in an [`EntityQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityQueryToken = {
    Uuid: 'uuid',
    EditionId: 'editionId',
    DraftId: 'draftId',
    Archived: 'archived',
    OwnedById: 'ownedById',
    Type: 'type',
    Properties: 'properties',
    Label: 'label',
    Provenance: 'provenance',
    EditionProvenance: 'editionProvenance',
    Embedding: 'embedding',
    IncomingLinks: 'incomingLinks',
    OutgoingLinks: 'outgoingLinks',
    LeftEntity: 'leftEntity',
    RightEntity: 'rightEntity'
} as const;

export type EntityQueryToken = typeof EntityQueryToken[keyof typeof EntityQueryToken];


/**
 * 
 * @export
 * @interface EntityRecordId
 */
export interface EntityRecordId {
    /**
     * 
     * @type {string}
     * @memberof EntityRecordId
     */
    'editionId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityRecordId
     */
    'entityId': string;
}
/**
 * @type EntityRelationAndSubject
 * @export
 */
export type EntityRelationAndSubject = EntityRelationAndSubjectOneOf | EntityRelationAndSubjectOneOf1 | EntityRelationAndSubjectOneOf2 | EntityRelationAndSubjectOneOf3 | EntityRelationAndSubjectOneOf4;

/**
 * 
 * @export
 * @interface EntityRelationAndSubjectOneOf
 */
export interface EntityRelationAndSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationAndSubjectOneOf
     */
    'relation': EntityRelationAndSubjectOneOfRelationEnum;
    /**
     * 
     * @type {EntitySettingSubject}
     * @memberof EntityRelationAndSubjectOneOf
     */
    'subject': EntitySettingSubject;
}

export const EntityRelationAndSubjectOneOfRelationEnum = {
    Setting: 'setting'
} as const;

export type EntityRelationAndSubjectOneOfRelationEnum = typeof EntityRelationAndSubjectOneOfRelationEnum[keyof typeof EntityRelationAndSubjectOneOfRelationEnum];

/**
 * 
 * @export
 * @interface EntityRelationAndSubjectOneOf1
 */
export interface EntityRelationAndSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationAndSubjectOneOf1
     */
    'relation': EntityRelationAndSubjectOneOf1RelationEnum;
    /**
     * 
     * @type {EntityOwnerSubject}
     * @memberof EntityRelationAndSubjectOneOf1
     */
    'subject': EntityOwnerSubject;
}

export const EntityRelationAndSubjectOneOf1RelationEnum = {
    Owner: 'owner'
} as const;

export type EntityRelationAndSubjectOneOf1RelationEnum = typeof EntityRelationAndSubjectOneOf1RelationEnum[keyof typeof EntityRelationAndSubjectOneOf1RelationEnum];

/**
 * 
 * @export
 * @interface EntityRelationAndSubjectOneOf2
 */
export interface EntityRelationAndSubjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationAndSubjectOneOf2
     */
    'relation': EntityRelationAndSubjectOneOf2RelationEnum;
    /**
     * 
     * @type {EntityAdministratorSubject}
     * @memberof EntityRelationAndSubjectOneOf2
     */
    'subject': EntityAdministratorSubject;
}

export const EntityRelationAndSubjectOneOf2RelationEnum = {
    Administrator: 'administrator'
} as const;

export type EntityRelationAndSubjectOneOf2RelationEnum = typeof EntityRelationAndSubjectOneOf2RelationEnum[keyof typeof EntityRelationAndSubjectOneOf2RelationEnum];

/**
 * 
 * @export
 * @interface EntityRelationAndSubjectOneOf3
 */
export interface EntityRelationAndSubjectOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationAndSubjectOneOf3
     */
    'relation': EntityRelationAndSubjectOneOf3RelationEnum;
    /**
     * 
     * @type {EntityEditorSubject}
     * @memberof EntityRelationAndSubjectOneOf3
     */
    'subject': EntityEditorSubject;
}

export const EntityRelationAndSubjectOneOf3RelationEnum = {
    Editor: 'editor'
} as const;

export type EntityRelationAndSubjectOneOf3RelationEnum = typeof EntityRelationAndSubjectOneOf3RelationEnum[keyof typeof EntityRelationAndSubjectOneOf3RelationEnum];

/**
 * 
 * @export
 * @interface EntityRelationAndSubjectOneOf4
 */
export interface EntityRelationAndSubjectOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof EntityRelationAndSubjectOneOf4
     */
    'relation': EntityRelationAndSubjectOneOf4RelationEnum;
    /**
     * 
     * @type {EntityViewerSubject}
     * @memberof EntityRelationAndSubjectOneOf4
     */
    'subject': EntityViewerSubject;
}

export const EntityRelationAndSubjectOneOf4RelationEnum = {
    Viewer: 'viewer'
} as const;

export type EntityRelationAndSubjectOneOf4RelationEnum = typeof EntityRelationAndSubjectOneOf4RelationEnum[keyof typeof EntityRelationAndSubjectOneOf4RelationEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EntitySetting = {
    AdministratorFromWeb: 'administratorFromWeb',
    UpdateFromWeb: 'updateFromWeb',
    ViewFromWeb: 'viewFromWeb'
} as const;

export type EntitySetting = typeof EntitySetting[keyof typeof EntitySetting];


/**
 * @type EntitySettingSubject
 * @export
 */
export type EntitySettingSubject = EntitySettingSubjectOneOf;

/**
 * 
 * @export
 * @interface EntitySettingSubjectOneOf
 */
export interface EntitySettingSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntitySettingSubjectOneOf
     */
    'kind': EntitySettingSubjectOneOfKindEnum;
    /**
     * 
     * @type {EntitySetting}
     * @memberof EntitySettingSubjectOneOf
     */
    'subjectId': EntitySetting;
}

export const EntitySettingSubjectOneOfKindEnum = {
    Setting: 'setting'
} as const;

export type EntitySettingSubjectOneOfKindEnum = typeof EntitySettingSubjectOneOfKindEnum[keyof typeof EntitySettingSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EntitySubjectSet = {
    Administrator: 'administrator',
    Member: 'member'
} as const;

export type EntitySubjectSet = typeof EntitySubjectSet[keyof typeof EntitySubjectSet];


/**
 * 
 * @export
 * @interface EntityTemporalMetadata
 */
export interface EntityTemporalMetadata {
    /**
     * 
     * @type {LeftClosedTemporalInterval}
     * @memberof EntityTemporalMetadata
     */
    'decisionTime': LeftClosedTemporalInterval;
    /**
     * 
     * @type {LeftClosedTemporalInterval}
     * @memberof EntityTemporalMetadata
     */
    'transactionTime': LeftClosedTemporalInterval;
}
/**
 * Specifies the structure of a Block Protocol entity type
 * @export
 * @interface EntityType
 */
export interface EntityType {
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    '$schema': EntityTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'kind': EntityTypeKindEnum;
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof EntityType
     */
    '$id': string;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'type': EntityTypeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'description': string;
    /**
     * 
     * @type {Array<EntityTypeReference>}
     * @memberof EntityType
     */
    'allOf'?: Array<EntityTypeReference>;
    /**
     * A JSON object where each entry is constrained by a property type.
     * @type {object}
     * @memberof EntityType
     */
    'properties': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityType
     */
    'required'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof EntityType
     */
    'links'?: object;
}

export const EntityTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaEntityType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type'
} as const;

export type EntityTypeSchemaEnum = typeof EntityTypeSchemaEnum[keyof typeof EntityTypeSchemaEnum];
export const EntityTypeKindEnum = {
    EntityType: 'entityType'
} as const;

export type EntityTypeKindEnum = typeof EntityTypeKindEnum[keyof typeof EntityTypeKindEnum];
export const EntityTypeTypeEnum = {
    Object: 'object'
} as const;

export type EntityTypeTypeEnum = typeof EntityTypeTypeEnum[keyof typeof EntityTypeTypeEnum];

/**
 * 
 * @export
 * @interface EntityTypeDisplayMetadata
 */
export interface EntityTypeDisplayMetadata {
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof EntityTypeDisplayMetadata
     */
    '$id': string;
    /**
     * The base URL of a Block Protocol ontology type (the $id of the schema, without the versioned suffix). It should a valid URL, with a trailing slash.
     * @type {string}
     * @memberof EntityTypeDisplayMetadata
     */
    'labelProperty'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeDisplayMetadata
     */
    'icon'?: string;
}
/**
 * @type EntityTypeEditorSubject
 * @export
 */
export type EntityTypeEditorSubject = EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * 
 * @export
 * @interface EntityTypeEditorSubjectOneOf
 */
export interface EntityTypeEditorSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeEditorSubjectOneOf
     */
    'kind': EntityTypeEditorSubjectOneOfKindEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeEditorSubjectOneOf
     */
    'subjectId': string;
}

export const EntityTypeEditorSubjectOneOfKindEnum = {
    AccountGroup: 'accountGroup'
} as const;

export type EntityTypeEditorSubjectOneOfKindEnum = typeof EntityTypeEditorSubjectOneOfKindEnum[keyof typeof EntityTypeEditorSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @interface EntityTypeEmbedding
 */
export interface EntityTypeEmbedding {
    /**
     * 
     * @type {Embedding}
     * @memberof EntityTypeEmbedding
     */
    'embedding': Embedding;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeEmbedding
     */
    'entityTypeId': string;
}
/**
 * @type EntityTypeIdDiff
 * @export
 */
export type EntityTypeIdDiff = EntityTypeIdDiffOneOf | EntityTypeIdDiffOneOf1;

/**
 * 
 * @export
 * @interface EntityTypeIdDiffOneOf
 */
export interface EntityTypeIdDiffOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeIdDiffOneOf
     */
    'added': string;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeIdDiffOneOf
     */
    'op': EntityTypeIdDiffOneOfOpEnum;
}

export const EntityTypeIdDiffOneOfOpEnum = {
    Added: 'added'
} as const;

export type EntityTypeIdDiffOneOfOpEnum = typeof EntityTypeIdDiffOneOfOpEnum[keyof typeof EntityTypeIdDiffOneOfOpEnum];

/**
 * 
 * @export
 * @interface EntityTypeIdDiffOneOf1
 */
export interface EntityTypeIdDiffOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeIdDiffOneOf1
     */
    'op': EntityTypeIdDiffOneOf1OpEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeIdDiffOneOf1
     */
    'removed': string;
}

export const EntityTypeIdDiffOneOf1OpEnum = {
    Removed: 'removed'
} as const;

export type EntityTypeIdDiffOneOf1OpEnum = typeof EntityTypeIdDiffOneOf1OpEnum[keyof typeof EntityTypeIdDiffOneOf1OpEnum];

/**
 * @type EntityTypeInstantiatorSubject
 * @export
 */
export type EntityTypeInstantiatorSubject = DataTypeViewerSubjectOneOf | EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * @type EntityTypeMetadata
 * @export
 */
export type EntityTypeMetadata = ExternalEntityTypeMetadata | OwnedEntityTypeMetadata;

/**
 * @type EntityTypeOwnerSubject
 * @export
 */
export type EntityTypeOwnerSubject = DataTypeOwnerSubjectOneOf;

/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePermission = {
    Update: 'update',
    View: 'view',
    Instantiate: 'instantiate'
} as const;

export type EntityTypePermission = typeof EntityTypePermission[keyof typeof EntityTypePermission];


/**
 * A single token in a [`EntityTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const EntityTypeQueryToken = {
    BaseUrl: 'baseUrl',
    Version: 'version',
    VersionedUrl: 'versionedUrl',
    OwnedById: 'ownedById',
    Title: 'title',
    Description: 'description',
    Properties: 'properties',
    Required: 'required',
    LabelProperty: 'labelProperty',
    Icon: 'icon',
    EditionProvenance: 'editionProvenance',
    Links: 'links',
    InheritsFrom: 'inheritsFrom',
    Children: 'children',
    Embedding: 'embedding'
} as const;

export type EntityTypeQueryToken = typeof EntityTypeQueryToken[keyof typeof EntityTypeQueryToken];


/**
 * 
 * @export
 * @interface EntityTypeReference
 */
export interface EntityTypeReference {
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof EntityTypeReference
     */
    '$ref': string;
}
/**
 * @type EntityTypeRelationAndSubject
 * @export
 */
export type EntityTypeRelationAndSubject = EntityTypeRelationAndSubjectOneOf | EntityTypeRelationAndSubjectOneOf1 | EntityTypeRelationAndSubjectOneOf2 | EntityTypeRelationAndSubjectOneOf3 | EntityTypeRelationAndSubjectOneOf4;

/**
 * 
 * @export
 * @interface EntityTypeRelationAndSubjectOneOf
 */
export interface EntityTypeRelationAndSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeRelationAndSubjectOneOf
     */
    'relation': EntityTypeRelationAndSubjectOneOfRelationEnum;
    /**
     * 
     * @type {EntityTypeOwnerSubject}
     * @memberof EntityTypeRelationAndSubjectOneOf
     */
    'subject': EntityTypeOwnerSubject;
}

export const EntityTypeRelationAndSubjectOneOfRelationEnum = {
    Owner: 'owner'
} as const;

export type EntityTypeRelationAndSubjectOneOfRelationEnum = typeof EntityTypeRelationAndSubjectOneOfRelationEnum[keyof typeof EntityTypeRelationAndSubjectOneOfRelationEnum];

/**
 * 
 * @export
 * @interface EntityTypeRelationAndSubjectOneOf1
 */
export interface EntityTypeRelationAndSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeRelationAndSubjectOneOf1
     */
    'relation': EntityTypeRelationAndSubjectOneOf1RelationEnum;
    /**
     * 
     * @type {EntityTypeSettingSubject}
     * @memberof EntityTypeRelationAndSubjectOneOf1
     */
    'subject': EntityTypeSettingSubject;
}

export const EntityTypeRelationAndSubjectOneOf1RelationEnum = {
    Setting: 'setting'
} as const;

export type EntityTypeRelationAndSubjectOneOf1RelationEnum = typeof EntityTypeRelationAndSubjectOneOf1RelationEnum[keyof typeof EntityTypeRelationAndSubjectOneOf1RelationEnum];

/**
 * 
 * @export
 * @interface EntityTypeRelationAndSubjectOneOf2
 */
export interface EntityTypeRelationAndSubjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeRelationAndSubjectOneOf2
     */
    'relation': EntityTypeRelationAndSubjectOneOf2RelationEnum;
    /**
     * 
     * @type {EntityTypeEditorSubject}
     * @memberof EntityTypeRelationAndSubjectOneOf2
     */
    'subject': EntityTypeEditorSubject;
}

export const EntityTypeRelationAndSubjectOneOf2RelationEnum = {
    Editor: 'editor'
} as const;

export type EntityTypeRelationAndSubjectOneOf2RelationEnum = typeof EntityTypeRelationAndSubjectOneOf2RelationEnum[keyof typeof EntityTypeRelationAndSubjectOneOf2RelationEnum];

/**
 * 
 * @export
 * @interface EntityTypeRelationAndSubjectOneOf3
 */
export interface EntityTypeRelationAndSubjectOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeRelationAndSubjectOneOf3
     */
    'relation': EntityTypeRelationAndSubjectOneOf3RelationEnum;
    /**
     * 
     * @type {EntityTypeViewerSubject}
     * @memberof EntityTypeRelationAndSubjectOneOf3
     */
    'subject': EntityTypeViewerSubject;
}

export const EntityTypeRelationAndSubjectOneOf3RelationEnum = {
    Viewer: 'viewer'
} as const;

export type EntityTypeRelationAndSubjectOneOf3RelationEnum = typeof EntityTypeRelationAndSubjectOneOf3RelationEnum[keyof typeof EntityTypeRelationAndSubjectOneOf3RelationEnum];

/**
 * 
 * @export
 * @interface EntityTypeRelationAndSubjectOneOf4
 */
export interface EntityTypeRelationAndSubjectOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeRelationAndSubjectOneOf4
     */
    'relation': EntityTypeRelationAndSubjectOneOf4RelationEnum;
    /**
     * 
     * @type {EntityTypeInstantiatorSubject}
     * @memberof EntityTypeRelationAndSubjectOneOf4
     */
    'subject': EntityTypeInstantiatorSubject;
}

export const EntityTypeRelationAndSubjectOneOf4RelationEnum = {
    Instantiator: 'instantiator'
} as const;

export type EntityTypeRelationAndSubjectOneOf4RelationEnum = typeof EntityTypeRelationAndSubjectOneOf4RelationEnum[keyof typeof EntityTypeRelationAndSubjectOneOf4RelationEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSetting = {
    UpdateFromWeb: 'updateFromWeb'
} as const;

export type EntityTypeSetting = typeof EntityTypeSetting[keyof typeof EntityTypeSetting];


/**
 * @type EntityTypeSettingSubject
 * @export
 */
export type EntityTypeSettingSubject = EntityTypeSettingSubjectOneOf;

/**
 * 
 * @export
 * @interface EntityTypeSettingSubjectOneOf
 */
export interface EntityTypeSettingSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeSettingSubjectOneOf
     */
    'kind': EntityTypeSettingSubjectOneOfKindEnum;
    /**
     * 
     * @type {EntityTypeSetting}
     * @memberof EntityTypeSettingSubjectOneOf
     */
    'subjectId': EntityTypeSetting;
}

export const EntityTypeSettingSubjectOneOfKindEnum = {
    Setting: 'setting'
} as const;

export type EntityTypeSettingSubjectOneOfKindEnum = typeof EntityTypeSettingSubjectOneOfKindEnum[keyof typeof EntityTypeSettingSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @interface EntityTypeVertex
 */
export interface EntityTypeVertex {
    /**
     * 
     * @type {EntityTypeWithMetadata}
     * @memberof EntityTypeVertex
     */
    'inner': EntityTypeWithMetadata;
    /**
     * 
     * @type {string}
     * @memberof EntityTypeVertex
     */
    'kind': EntityTypeVertexKindEnum;
}

export const EntityTypeVertexKindEnum = {
    EntityType: 'entityType'
} as const;

export type EntityTypeVertexKindEnum = typeof EntityTypeVertexKindEnum[keyof typeof EntityTypeVertexKindEnum];

/**
 * 
 * @export
 * @interface EntityTypeVertexId
 */
export interface EntityTypeVertexId {
    /**
     * 
     * @type {string}
     * @memberof EntityTypeVertexId
     */
    'baseId': string;
    /**
     * 
     * @type {number}
     * @memberof EntityTypeVertexId
     */
    'revisionId': number;
}
/**
 * @type EntityTypeViewerSubject
 * @export
 */
export type EntityTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * 
 * @export
 * @interface EntityTypeWithMetadata
 */
export interface EntityTypeWithMetadata {
    /**
     * 
     * @type {EntityTypeMetadata}
     * @memberof EntityTypeWithMetadata
     */
    'metadata': EntityTypeMetadata;
    /**
     * 
     * @type {EntityType}
     * @memberof EntityTypeWithMetadata
     */
    'schema': EntityType;
}
/**
 * 
 * @export
 * @interface EntityValidationType
 */
export interface EntityValidationType extends Array<string> {
}
/**
 * 
 * @export
 * @interface EntityVertex
 */
export interface EntityVertex {
    /**
     * 
     * @type {Entity}
     * @memberof EntityVertex
     */
    'inner': Entity;
    /**
     * 
     * @type {string}
     * @memberof EntityVertex
     */
    'kind': EntityVertexKindEnum;
}

export const EntityVertexKindEnum = {
    Entity: 'entity'
} as const;

export type EntityVertexKindEnum = typeof EntityVertexKindEnum[keyof typeof EntityVertexKindEnum];

/**
 * 
 * @export
 * @interface EntityVertexId
 */
export interface EntityVertexId {
    /**
     * 
     * @type {string}
     * @memberof EntityVertexId
     */
    'baseId': string;
    /**
     * 
     * @type {string}
     * @memberof EntityVertexId
     */
    'revisionId': string;
}
/**
 * @type EntityViewerSubject
 * @export
 */
export type EntityViewerSubject = DataTypeViewerSubjectOneOf | EntityAdministratorSubjectOneOf | EntityAdministratorSubjectOneOf1;

/**
 * 
 * @export
 * @interface EqualFilter
 */
export interface EqualFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof EqualFilter
     */
    'equal': Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
    /**
     * The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
     * @type {string}
     * @memberof ErrorInfo
     */
    'reason': string;
    /**
     * The logical grouping to which the \"reason\" belongs. The error domain is typically the registered service name of the tool or product that generates the error.
     * @type {string}
     * @memberof ErrorInfo
     */
    'domain': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof ErrorInfo
     */
    'metadata': object;
}
/**
 * 
 * @export
 * @interface ExclusiveBound
 */
export interface ExclusiveBound {
    /**
     * 
     * @type {string}
     * @memberof ExclusiveBound
     */
    'kind': ExclusiveBoundKindEnum;
    /**
     * 
     * @type {string}
     * @memberof ExclusiveBound
     */
    'limit': string;
}

export const ExclusiveBoundKindEnum = {
    Exclusive: 'exclusive'
} as const;

export type ExclusiveBoundKindEnum = typeof ExclusiveBoundKindEnum[keyof typeof ExclusiveBoundKindEnum];

/**
 * 
 * @export
 * @interface ExternalDataTypeMetadata
 */
export interface ExternalDataTypeMetadata {
    /**
     * 
     * @type {{ [key: string]: Conversions; }}
     * @memberof ExternalDataTypeMetadata
     */
    'conversions'?: { [key: string]: Conversions; };
    /**
     * 
     * @type {string}
     * @memberof ExternalDataTypeMetadata
     */
    'fetchedAt': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof ExternalDataTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof ExternalDataTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof ExternalDataTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * 
 * @export
 * @interface ExternalEntityTypeMetadata
 */
export interface ExternalEntityTypeMetadata {
    /**
     * 
     * @type {string}
     * @memberof ExternalEntityTypeMetadata
     */
    'fetchedAt': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof ExternalEntityTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof ExternalEntityTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof ExternalEntityTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * 
 * @export
 * @interface ExternalPropertyTypeMetadata
 */
export interface ExternalPropertyTypeMetadata {
    /**
     * 
     * @type {string}
     * @memberof ExternalPropertyTypeMetadata
     */
    'fetchedAt': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof ExternalPropertyTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof ExternalPropertyTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof ExternalPropertyTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * @type Filter
 * @export
 */
export type Filter = AllFilter | AnyFilter | ContainsSegmentFilter | CosineDistanceFilter | EndsWithFilter | EqualFilter | GreaterFilter | GreaterOrEqualFilter | LessFilter | LessOrEqualFilter | NotEqualFilter | NotFilter | StartsWithFilter;

/**
 * @type FilterExpression
 * @export
 */
export type FilterExpression = ParameterExpression | PathExpression;

/**
 * 
 * @export
 * @interface GetClosedMultiEntityTypeParams
 */
export interface GetClosedMultiEntityTypeParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetClosedMultiEntityTypeParams
     */
    'entityTypeIds': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GetClosedMultiEntityTypeParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetClosedMultiEntityTypeParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetClosedMultiEntityTypeResponse
 */
export interface GetClosedMultiEntityTypeResponse {
    /**
     * 
     * @type {ClosedMultiEntityType}
     * @memberof GetClosedMultiEntityTypeResponse
     */
    'entityType': ClosedMultiEntityType;
}
/**
 * 
 * @export
 * @interface GetDataTypeSubgraphParams
 */
export interface GetDataTypeSubgraphParams {
    /**
     * 
     * @type {string}
     * @memberof GetDataTypeSubgraphParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetDataTypeSubgraphParams
     */
    'filter': Filter;
    /**
     * 
     * @type {GraphResolveDepths}
     * @memberof GetDataTypeSubgraphParams
     */
    'graphResolveDepths': GraphResolveDepths;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataTypeSubgraphParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataTypeSubgraphParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetDataTypeSubgraphParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetDataTypeSubgraphParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetDataTypeSubgraphResponse
 */
export interface GetDataTypeSubgraphResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDataTypeSubgraphResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {Subgraph}
     * @memberof GetDataTypeSubgraphResponse
     */
    'subgraph': Subgraph;
}
/**
 * 
 * @export
 * @interface GetDataTypesParams
 */
export interface GetDataTypesParams {
    /**
     * 
     * @type {string}
     * @memberof GetDataTypesParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetDataTypesParams
     */
    'filter': Filter;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataTypesParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataTypesParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetDataTypesParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetDataTypesParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetDataTypesResponse
 */
export interface GetDataTypesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDataTypesResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetDataTypesResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {Array<DataTypeWithMetadata>}
     * @memberof GetDataTypesResponse
     */
    'dataTypes': Array<DataTypeWithMetadata>;
}
/**
 * 
 * @export
 * @interface GetEntitiesRequest
 */
export interface GetEntitiesRequest {
    /**
     * 
     * @type {Array<QueryConversion>}
     * @memberof GetEntitiesRequest
     */
    'conversions'?: Array<QueryConversion>;
    /**
     * 
     * @type {EntityQueryCursor}
     * @memberof GetEntitiesRequest
     */
    'cursor'?: EntityQueryCursor | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetEntitiesRequest
     */
    'filter': Filter;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeEditionCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeTypeIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitiesRequest
     */
    'includeWebIds'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetEntitiesRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Array<EntityQuerySortingRecord>}
     * @memberof GetEntitiesRequest
     */
    'sortingPaths'?: Array<EntityQuerySortingRecord> | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetEntitiesRequest
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetEntitiesResponse
 */
export interface GetEntitiesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEntitiesResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitiesResponse
     */
    'createdByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {EntityQueryCursor}
     * @memberof GetEntitiesResponse
     */
    'cursor'?: EntityQueryCursor | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitiesResponse
     */
    'editionCreatedByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<Entity>}
     * @memberof GetEntitiesResponse
     */
    'entities': Array<Entity>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitiesResponse
     */
    'typeIds'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitiesResponse
     */
    'webIds'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface GetEntitySubgraphRequest
 */
export interface GetEntitySubgraphRequest {
    /**
     * 
     * @type {Array<QueryConversion>}
     * @memberof GetEntitySubgraphRequest
     */
    'conversions'?: Array<QueryConversion>;
    /**
     * 
     * @type {EntityQueryCursor}
     * @memberof GetEntitySubgraphRequest
     */
    'cursor'?: EntityQueryCursor | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetEntitySubgraphRequest
     */
    'filter': Filter;
    /**
     * 
     * @type {GraphResolveDepths}
     * @memberof GetEntitySubgraphRequest
     */
    'graphResolveDepths': GraphResolveDepths;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeEditionCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeTypeIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntitySubgraphRequest
     */
    'includeWebIds'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetEntitySubgraphRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Array<EntityQuerySortingRecord>}
     * @memberof GetEntitySubgraphRequest
     */
    'sortingPaths'?: Array<EntityQuerySortingRecord> | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetEntitySubgraphRequest
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetEntitySubgraphResponse
 */
export interface GetEntitySubgraphResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEntitySubgraphResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitySubgraphResponse
     */
    'createdByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {EntityQueryCursor}
     * @memberof GetEntitySubgraphResponse
     */
    'cursor'?: EntityQueryCursor | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitySubgraphResponse
     */
    'editionCreatedByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {Subgraph}
     * @memberof GetEntitySubgraphResponse
     */
    'subgraph': Subgraph;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitySubgraphResponse
     */
    'typeIds'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntitySubgraphResponse
     */
    'webIds'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface GetEntityTypeSubgraphParams
 */
export interface GetEntityTypeSubgraphParams {
    /**
     * 
     * @type {string}
     * @memberof GetEntityTypeSubgraphParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetEntityTypeSubgraphParams
     */
    'filter': Filter;
    /**
     * 
     * @type {GraphResolveDepths}
     * @memberof GetEntityTypeSubgraphParams
     */
    'graphResolveDepths': GraphResolveDepths;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypeSubgraphParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypeSubgraphParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypeSubgraphParams
     */
    'includeEditionCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypeSubgraphParams
     */
    'includeWebIds'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetEntityTypeSubgraphParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetEntityTypeSubgraphParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetEntityTypeSubgraphResponse
 */
export interface GetEntityTypeSubgraphResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEntityTypeSubgraphResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetEntityTypeSubgraphResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntityTypeSubgraphResponse
     */
    'editionCreatedByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {Subgraph}
     * @memberof GetEntityTypeSubgraphResponse
     */
    'subgraph': Subgraph;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntityTypeSubgraphResponse
     */
    'webIds'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface GetEntityTypesParams
 */
export interface GetEntityTypesParams {
    /**
     * 
     * @type {string}
     * @memberof GetEntityTypesParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetEntityTypesParams
     */
    'filter': Filter;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypesParams
     */
    'includeClosed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypesParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypesParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypesParams
     */
    'includeEditionCreatedByIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetEntityTypesParams
     */
    'includeWebIds'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetEntityTypesParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetEntityTypesParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetEntityTypesResponse
 */
export interface GetEntityTypesResponse {
    /**
     * 
     * @type {Array<ClosedEntityType>}
     * @memberof GetEntityTypesResponse
     */
    'closedEntityTypes'?: Array<ClosedEntityType>;
    /**
     * 
     * @type {number}
     * @memberof GetEntityTypesResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetEntityTypesResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntityTypesResponse
     */
    'editionCreatedByIds'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<EntityTypeWithMetadata>}
     * @memberof GetEntityTypesResponse
     */
    'entityTypes': Array<EntityTypeWithMetadata>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetEntityTypesResponse
     */
    'webIds'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface GetPropertyTypeSubgraphParams
 */
export interface GetPropertyTypeSubgraphParams {
    /**
     * 
     * @type {string}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'filter': Filter;
    /**
     * 
     * @type {GraphResolveDepths}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'graphResolveDepths': GraphResolveDepths;
    /**
     * 
     * @type {boolean}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetPropertyTypeSubgraphParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetPropertyTypeSubgraphResponse
 */
export interface GetPropertyTypeSubgraphResponse {
    /**
     * 
     * @type {string}
     * @memberof GetPropertyTypeSubgraphResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {Subgraph}
     * @memberof GetPropertyTypeSubgraphResponse
     */
    'subgraph': Subgraph;
}
/**
 * 
 * @export
 * @interface GetPropertyTypesParams
 */
export interface GetPropertyTypesParams {
    /**
     * 
     * @type {string}
     * @memberof GetPropertyTypesParams
     */
    'after'?: string | null;
    /**
     * 
     * @type {Filter}
     * @memberof GetPropertyTypesParams
     */
    'filter': Filter;
    /**
     * 
     * @type {boolean}
     * @memberof GetPropertyTypesParams
     */
    'includeCount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetPropertyTypesParams
     */
    'includeDrafts': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPropertyTypesParams
     */
    'limit'?: number | null;
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof GetPropertyTypesParams
     */
    'temporalAxes': QueryTemporalAxesUnresolved;
}
/**
 * 
 * @export
 * @interface GetPropertyTypesResponse
 */
export interface GetPropertyTypesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetPropertyTypesResponse
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetPropertyTypesResponse
     */
    'cursor'?: string | null;
    /**
     * 
     * @type {Array<PropertyTypeWithMetadata>}
     * @memberof GetPropertyTypesResponse
     */
    'propertyTypes': Array<PropertyTypeWithMetadata>;
}
/**
 * @type GraphElementVertexId
 * @export
 */
export type GraphElementVertexId = DataTypeVertexId | EntityTypeVertexId | EntityVertexId | PropertyTypeVertexId;

/**
 * 
 * @export
 * @interface GraphResolveDepths
 */
export interface GraphResolveDepths {
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'constrainsLinkDestinationsOn': OutgoingEdgeResolveDepth;
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'constrainsLinksOn': OutgoingEdgeResolveDepth;
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'constrainsPropertiesOn': OutgoingEdgeResolveDepth;
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'constrainsValuesOn': OutgoingEdgeResolveDepth;
    /**
     * 
     * @type {EdgeResolveDepths}
     * @memberof GraphResolveDepths
     */
    'hasLeftEntity': EdgeResolveDepths;
    /**
     * 
     * @type {EdgeResolveDepths}
     * @memberof GraphResolveDepths
     */
    'hasRightEntity': EdgeResolveDepths;
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'inheritsFrom': OutgoingEdgeResolveDepth;
    /**
     * 
     * @type {OutgoingEdgeResolveDepth}
     * @memberof GraphResolveDepths
     */
    'isOfType': OutgoingEdgeResolveDepth;
}
/**
 * 
 * @export
 * @interface GreaterFilter
 */
export interface GreaterFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof GreaterFilter
     */
    'greater'?: Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface GreaterOrEqualFilter
 */
export interface GreaterOrEqualFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof GreaterOrEqualFilter
     */
    'greaterOrEqual'?: Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface InclusiveBound
 */
export interface InclusiveBound {
    /**
     * 
     * @type {string}
     * @memberof InclusiveBound
     */
    'kind': InclusiveBoundKindEnum;
    /**
     * 
     * @type {string}
     * @memberof InclusiveBound
     */
    'limit': string;
}

export const InclusiveBoundKindEnum = {
    Inclusive: 'inclusive'
} as const;

export type InclusiveBoundKindEnum = typeof InclusiveBoundKindEnum[keyof typeof InclusiveBoundKindEnum];

/**
 * 
 * @export
 * @interface InferredEntityProvenance
 */
export interface InferredEntityProvenance {
    /**
     * 
     * @type {string}
     * @memberof InferredEntityProvenance
     */
    'createdAtDecisionTime': string;
    /**
     * 
     * @type {string}
     * @memberof InferredEntityProvenance
     */
    'createdAtTransactionTime': string;
    /**
     * 
     * @type {string}
     * @memberof InferredEntityProvenance
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof InferredEntityProvenance
     */
    'firstNonDraftCreatedAtDecisionTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof InferredEntityProvenance
     */
    'firstNonDraftCreatedAtTransactionTime'?: string;
}
/**
 * 
 * @export
 * @interface InsertAccountGroupIdParams
 */
export interface InsertAccountGroupIdParams {
    /**
     * 
     * @type {string}
     * @memberof InsertAccountGroupIdParams
     */
    'accountGroupId'?: string;
}
/**
 * 
 * @export
 * @interface InsertAccountIdParams
 */
export interface InsertAccountIdParams {
    /**
     * 
     * @type {string}
     * @memberof InsertAccountIdParams
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface InsertWebIdParams
 */
export interface InsertWebIdParams {
    /**
     * 
     * @type {string}
     * @memberof InsertWebIdParams
     */
    'ownedById': string;
    /**
     * 
     * @type {WebOwnerSubject}
     * @memberof InsertWebIdParams
     */
    'owner': WebOwnerSubject;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KnowledgeGraphEdgeKind = {
    LeftEntity: 'HAS_LEFT_ENTITY',
    RightEntity: 'HAS_RIGHT_ENTITY'
} as const;

export type KnowledgeGraphEdgeKind = typeof KnowledgeGraphEdgeKind[keyof typeof KnowledgeGraphEdgeKind];


/**
 * @type KnowledgeGraphOutwardEdge
 * @export
 */
export type KnowledgeGraphOutwardEdge = KnowledgeGraphToKnowledgeGraphOutwardEdge | KnowledgeGraphToOntologyOutwardEdge;

/**
 * 
 * @export
 * @interface KnowledgeGraphToKnowledgeGraphOutwardEdge
 */
export interface KnowledgeGraphToKnowledgeGraphOutwardEdge {
    /**
     * 
     * @type {KnowledgeGraphEdgeKind}
     * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
     */
    'kind': KnowledgeGraphEdgeKind;
    /**
     * 
     * @type {boolean}
     * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
     */
    'reversed': boolean;
    /**
     * 
     * @type {EntityIdWithInterval}
     * @memberof KnowledgeGraphToKnowledgeGraphOutwardEdge
     */
    'rightEndpoint': EntityIdWithInterval;
}


/**
 * 
 * @export
 * @interface KnowledgeGraphToOntologyOutwardEdge
 */
export interface KnowledgeGraphToOntologyOutwardEdge {
    /**
     * 
     * @type {SharedEdgeKind}
     * @memberof KnowledgeGraphToOntologyOutwardEdge
     */
    'kind': SharedEdgeKind;
    /**
     * 
     * @type {boolean}
     * @memberof KnowledgeGraphToOntologyOutwardEdge
     */
    'reversed': boolean;
    /**
     * 
     * @type {OntologyTypeVertexId}
     * @memberof KnowledgeGraphToOntologyOutwardEdge
     */
    'rightEndpoint': OntologyTypeVertexId;
}


/**
 * @type KnowledgeGraphVertex
 * @export
 */
export type KnowledgeGraphVertex = EntityVertex;

/**
 * 
 * @export
 * @interface KnowledgeGraphVertices
 */
export interface KnowledgeGraphVertices {
    [key: string]: { [key: string]: KnowledgeGraphVertex; };

}
/**
 * 
 * @export
 * @interface LeftClosedTemporalInterval
 */
export interface LeftClosedTemporalInterval {
    /**
     * 
     * @type {OpenTemporalBound}
     * @memberof LeftClosedTemporalInterval
     */
    'end': OpenTemporalBound;
    /**
     * 
     * @type {ClosedTemporalBound}
     * @memberof LeftClosedTemporalInterval
     */
    'start': ClosedTemporalBound;
}
/**
 * 
 * @export
 * @interface LessFilter
 */
export interface LessFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof LessFilter
     */
    'less'?: Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface LessOrEqualFilter
 */
export interface LessOrEqualFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof LessOrEqualFilter
     */
    'lessOrEqual'?: Array<FilterExpression>;
}
/**
 * @type LimitedTemporalBound
 * @export
 */
export type LimitedTemporalBound = ExclusiveBound | InclusiveBound;

/**
 * The associated information for \'Link\' entities
 * @export
 * @interface LinkData
 */
export interface LinkData {
    /**
     * 
     * @type {number}
     * @memberof LinkData
     */
    'leftEntityConfidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof LinkData
     */
    'leftEntityId': string;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof LinkData
     */
    'leftEntityProvenance'?: PropertyProvenance;
    /**
     * 
     * @type {number}
     * @memberof LinkData
     */
    'rightEntityConfidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof LinkData
     */
    'rightEntityId': string;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof LinkData
     */
    'rightEntityProvenance'?: PropertyProvenance;
}
/**
 * @type LoadExternalDataTypeRequest
 * @export
 */
export type LoadExternalDataTypeRequest = LoadExternalDataTypeRequestOneOf | LoadExternalDataTypeRequestOneOf1;

/**
 * 
 * @export
 * @interface LoadExternalDataTypeRequestOneOf
 */
export interface LoadExternalDataTypeRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof LoadExternalDataTypeRequestOneOf
     */
    'dataTypeId': string;
}
/**
 * 
 * @export
 * @interface LoadExternalDataTypeRequestOneOf1
 */
export interface LoadExternalDataTypeRequestOneOf1 {
    /**
     * 
     * @type {{ [key: string]: Conversions; }}
     * @memberof LoadExternalDataTypeRequestOneOf1
     */
    'conversions': { [key: string]: Conversions; };
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof LoadExternalDataTypeRequestOneOf1
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<DataTypeRelationAndSubject>}
     * @memberof LoadExternalDataTypeRequestOneOf1
     */
    'relationships': Array<DataTypeRelationAndSubject>;
    /**
     * 
     * @type {DataType}
     * @memberof LoadExternalDataTypeRequestOneOf1
     */
    'schema': DataType;
}
/**
 * @type LoadExternalEntityTypeRequest
 * @export
 */
export type LoadExternalEntityTypeRequest = LoadExternalEntityTypeRequestOneOf | LoadExternalEntityTypeRequestOneOf1;

/**
 * 
 * @export
 * @interface LoadExternalEntityTypeRequestOneOf
 */
export interface LoadExternalEntityTypeRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof LoadExternalEntityTypeRequestOneOf
     */
    'entityTypeId': string;
}
/**
 * 
 * @export
 * @interface LoadExternalEntityTypeRequestOneOf1
 */
export interface LoadExternalEntityTypeRequestOneOf1 {
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof LoadExternalEntityTypeRequestOneOf1
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<EntityTypeRelationAndSubject>}
     * @memberof LoadExternalEntityTypeRequestOneOf1
     */
    'relationships': Array<EntityTypeRelationAndSubject>;
    /**
     * 
     * @type {EntityType}
     * @memberof LoadExternalEntityTypeRequestOneOf1
     */
    'schema': EntityType;
}
/**
 * @type LoadExternalPropertyTypeRequest
 * @export
 */
export type LoadExternalPropertyTypeRequest = LoadExternalPropertyTypeRequestOneOf | LoadExternalPropertyTypeRequestOneOf1;

/**
 * 
 * @export
 * @interface LoadExternalPropertyTypeRequestOneOf
 */
export interface LoadExternalPropertyTypeRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof LoadExternalPropertyTypeRequestOneOf
     */
    'propertyTypeId': string;
}
/**
 * 
 * @export
 * @interface LoadExternalPropertyTypeRequestOneOf1
 */
export interface LoadExternalPropertyTypeRequestOneOf1 {
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof LoadExternalPropertyTypeRequestOneOf1
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<PropertyTypeRelationAndSubject>}
     * @memberof LoadExternalPropertyTypeRequestOneOf1
     */
    'relationships': Array<PropertyTypeRelationAndSubject>;
    /**
     * 
     * @type {PropertyType}
     * @memberof LoadExternalPropertyTypeRequestOneOf1
     */
    'schema': PropertyType;
}
/**
 * A location where the source material can be found.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * Encapsulates a message intended to be read by the end user.
     * @type {string}
     * @memberof Location
     */
    'description'?: string;
    /**
     * A string containing the name of the location.
     * @type {string}
     * @memberof Location
     */
    'name'?: string;
    /**
     * A string containing a valid relative or absolute URI.
     * @type {string}
     * @memberof Location
     */
    'uri'?: string;
}
/**
 * @type MaybeListOfDataTypeMetadata
 * @export
 */
export type MaybeListOfDataTypeMetadata = Array<DataTypeMetadata> | DataTypeMetadata;

/**
 * @type MaybeListOfEntityTypeMetadata
 * @export
 */
export type MaybeListOfEntityTypeMetadata = Array<EntityTypeMetadata> | EntityTypeMetadata;

/**
 * @type MaybeListOfPropertyTypeMetadata
 * @export
 */
export type MaybeListOfPropertyTypeMetadata = Array<PropertyTypeMetadata> | PropertyTypeMetadata;

/**
 * 
 * @export
 * @interface ModifyDataTypeAuthorizationRelationship
 */
export interface ModifyDataTypeAuthorizationRelationship {
    /**
     * 
     * @type {ModifyRelationshipOperation}
     * @memberof ModifyDataTypeAuthorizationRelationship
     */
    'operation': ModifyRelationshipOperation;
    /**
     * 
     * @type {DataTypeRelationAndSubject}
     * @memberof ModifyDataTypeAuthorizationRelationship
     */
    'relationAndSubject': DataTypeRelationAndSubject;
    /**
     * 
     * @type {string}
     * @memberof ModifyDataTypeAuthorizationRelationship
     */
    'resource': string;
}


/**
 * 
 * @export
 * @interface ModifyEntityAuthorizationRelationship
 */
export interface ModifyEntityAuthorizationRelationship {
    /**
     * 
     * @type {ModifyRelationshipOperation}
     * @memberof ModifyEntityAuthorizationRelationship
     */
    'operation': ModifyRelationshipOperation;
    /**
     * 
     * @type {EntityRelationAndSubject}
     * @memberof ModifyEntityAuthorizationRelationship
     */
    'relationSubject': EntityRelationAndSubject;
    /**
     * 
     * @type {string}
     * @memberof ModifyEntityAuthorizationRelationship
     */
    'resource': string;
}


/**
 * 
 * @export
 * @interface ModifyEntityTypeAuthorizationRelationship
 */
export interface ModifyEntityTypeAuthorizationRelationship {
    /**
     * 
     * @type {ModifyRelationshipOperation}
     * @memberof ModifyEntityTypeAuthorizationRelationship
     */
    'operation': ModifyRelationshipOperation;
    /**
     * 
     * @type {EntityTypeRelationAndSubject}
     * @memberof ModifyEntityTypeAuthorizationRelationship
     */
    'relationAndSubject': EntityTypeRelationAndSubject;
    /**
     * 
     * @type {string}
     * @memberof ModifyEntityTypeAuthorizationRelationship
     */
    'resource': string;
}


/**
 * 
 * @export
 * @interface ModifyPropertyTypeAuthorizationRelationship
 */
export interface ModifyPropertyTypeAuthorizationRelationship {
    /**
     * 
     * @type {ModifyRelationshipOperation}
     * @memberof ModifyPropertyTypeAuthorizationRelationship
     */
    'operation': ModifyRelationshipOperation;
    /**
     * 
     * @type {PropertyTypeRelationAndSubject}
     * @memberof ModifyPropertyTypeAuthorizationRelationship
     */
    'relationAndSubject': PropertyTypeRelationAndSubject;
    /**
     * 
     * @type {string}
     * @memberof ModifyPropertyTypeAuthorizationRelationship
     */
    'resource': string;
}


/**
 * Used for mutating a single relationship within the service.
 * @export
 * @enum {string}
 */

export const ModifyRelationshipOperation = {
    Touch: 'touch',
    Create: 'create',
    Delete: 'delete'
} as const;

export type ModifyRelationshipOperation = typeof ModifyRelationshipOperation[keyof typeof ModifyRelationshipOperation];


/**
 * 
 * @export
 * @interface ModifyWebAuthorizationRelationship
 */
export interface ModifyWebAuthorizationRelationship {
    /**
     * 
     * @type {ModifyRelationshipOperation}
     * @memberof ModifyWebAuthorizationRelationship
     */
    'operation': ModifyRelationshipOperation;
    /**
     * 
     * @type {WebRelationAndSubject}
     * @memberof ModifyWebAuthorizationRelationship
     */
    'relationAndSubject': WebRelationAndSubject;
    /**
     * 
     * @type {string}
     * @memberof ModifyWebAuthorizationRelationship
     */
    'resource': string;
}


/**
 * 
 * @export
 * @interface NotEqualFilter
 */
export interface NotEqualFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof NotEqualFilter
     */
    'notEqual': Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface NotFilter
 */
export interface NotFilter {
    /**
     * 
     * @type {Filter}
     * @memberof NotFilter
     */
    'not': Filter;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NullOrdering = {
    First: 'first',
    Last: 'last'
} as const;

export type NullOrdering = typeof NullOrdering[keyof typeof NullOrdering];


/**
 * 
 * @export
 * @interface ObjectMetadata
 */
export interface ObjectMetadata {
    /**
     * 
     * @type {number}
     * @memberof ObjectMetadata
     */
    'confidence'?: number;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof ObjectMetadata
     */
    'provenance'?: PropertyProvenance;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OntologyEdgeKind = {
    InheritsFrom: 'INHERITS_FROM',
    ConstrainsValuesOn: 'CONSTRAINS_VALUES_ON',
    ConstrainsPropertiesOn: 'CONSTRAINS_PROPERTIES_ON',
    ConstrainsLinksOn: 'CONSTRAINS_LINKS_ON',
    ConstrainsLinkDestinationsOn: 'CONSTRAINS_LINK_DESTINATIONS_ON'
} as const;

export type OntologyEdgeKind = typeof OntologyEdgeKind[keyof typeof OntologyEdgeKind];


/**
 * 
 * @export
 * @interface OntologyEditionProvenance
 */
export interface OntologyEditionProvenance {
    /**
     * 
     * @type {ActorType}
     * @memberof OntologyEditionProvenance
     */
    'actorType'?: ActorType;
    /**
     * 
     * @type {ProvidedEntityEditionProvenanceOrigin}
     * @memberof OntologyEditionProvenance
     */
    'origin'?: ProvidedEntityEditionProvenanceOrigin;
    /**
     * 
     * @type {Array<SourceProvenance>}
     * @memberof OntologyEditionProvenance
     */
    'sources'?: Array<SourceProvenance>;
    /**
     * 
     * @type {string}
     * @memberof OntologyEditionProvenance
     */
    'archivedById'?: string;
    /**
     * 
     * @type {string}
     * @memberof OntologyEditionProvenance
     */
    'createdById': string;
}


/**
 * @type OntologyOutwardEdge
 * @export
 */
export type OntologyOutwardEdge = OntologyToKnowledgeGraphOutwardEdge | OntologyToOntologyOutwardEdge;

/**
 * 
 * @export
 * @interface OntologyProvenance
 */
export interface OntologyProvenance {
    /**
     * 
     * @type {OntologyEditionProvenance}
     * @memberof OntologyProvenance
     */
    'edition': OntologyEditionProvenance;
}
/**
 * 
 * @export
 * @interface OntologyTemporalMetadata
 */
export interface OntologyTemporalMetadata {
    /**
     * 
     * @type {LeftClosedTemporalInterval}
     * @memberof OntologyTemporalMetadata
     */
    'transactionTime': LeftClosedTemporalInterval;
}
/**
 * 
 * @export
 * @interface OntologyToKnowledgeGraphOutwardEdge
 */
export interface OntologyToKnowledgeGraphOutwardEdge {
    /**
     * 
     * @type {SharedEdgeKind}
     * @memberof OntologyToKnowledgeGraphOutwardEdge
     */
    'kind': SharedEdgeKind;
    /**
     * 
     * @type {boolean}
     * @memberof OntologyToKnowledgeGraphOutwardEdge
     */
    'reversed': boolean;
    /**
     * 
     * @type {EntityIdWithInterval}
     * @memberof OntologyToKnowledgeGraphOutwardEdge
     */
    'rightEndpoint': EntityIdWithInterval;
}


/**
 * 
 * @export
 * @interface OntologyToOntologyOutwardEdge
 */
export interface OntologyToOntologyOutwardEdge {
    /**
     * 
     * @type {OntologyEdgeKind}
     * @memberof OntologyToOntologyOutwardEdge
     */
    'kind': OntologyEdgeKind;
    /**
     * 
     * @type {boolean}
     * @memberof OntologyToOntologyOutwardEdge
     */
    'reversed': boolean;
    /**
     * 
     * @type {OntologyTypeVertexId}
     * @memberof OntologyToOntologyOutwardEdge
     */
    'rightEndpoint': OntologyTypeVertexId;
}


/**
 * 
 * @export
 * @interface OntologyTypeRecordId
 */
export interface OntologyTypeRecordId {
    /**
     * 
     * @type {string}
     * @memberof OntologyTypeRecordId
     */
    'baseUrl': string;
    /**
     * 
     * @type {number}
     * @memberof OntologyTypeRecordId
     */
    'version': number;
}
/**
 * @type OntologyTypeVertexId
 * @export
 */
export type OntologyTypeVertexId = DataTypeVertexId | EntityTypeVertexId | PropertyTypeVertexId;

/**
 * @type OntologyVertex
 * @export
 */
export type OntologyVertex = DataTypeVertex | EntityTypeVertex | PropertyTypeVertex;

/**
 * 
 * @export
 * @interface OntologyVertices
 */
export interface OntologyVertices {
    [key: string]: { [key: string]: OntologyVertex; };

}
/**
 * @type OpenTemporalBound
 * @export
 */
export type OpenTemporalBound = ExclusiveBound | UnboundedBound;

/**
 * 
 * @export
 * @enum {string}
 */

export const Operator = {
    Plus: '+',
    Minus: '-',
    Star: '*',
    Slash: '/'
} as const;

export type Operator = typeof Operator[keyof typeof Operator];


/**
 * 
 * @export
 * @enum {string}
 */

export const Ordering = {
    Ascending: 'ascending',
    Descending: 'descending'
} as const;

export type Ordering = typeof Ordering[keyof typeof Ordering];


/**
 * @type OriginProvenance
 * @export
 */
export type OriginProvenance = OriginProvenanceOneOf | OriginProvenanceOneOf1 | OriginProvenanceOneOf2 | OriginProvenanceOneOf3 | OriginProvenanceOneOf4 | OriginProvenanceOneOf5;

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf
 */
export interface OriginProvenanceOneOf {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'type': OriginProvenanceOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf
     */
    'version'?: string;
}

export const OriginProvenanceOneOfTypeEnum = {
    WebApp: 'web-app'
} as const;

export type OriginProvenanceOneOfTypeEnum = typeof OriginProvenanceOneOfTypeEnum[keyof typeof OriginProvenanceOneOfTypeEnum];

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf1
 */
export interface OriginProvenanceOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'type': OriginProvenanceOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf1
     */
    'version'?: string;
}

export const OriginProvenanceOneOf1TypeEnum = {
    MobileApp: 'mobile-app'
} as const;

export type OriginProvenanceOneOf1TypeEnum = typeof OriginProvenanceOneOf1TypeEnum[keyof typeof OriginProvenanceOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf2
 */
export interface OriginProvenanceOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'type': OriginProvenanceOneOf2TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf2
     */
    'version'?: string;
}

export const OriginProvenanceOneOf2TypeEnum = {
    BrowserExtension: 'browser-extension'
} as const;

export type OriginProvenanceOneOf2TypeEnum = typeof OriginProvenanceOneOf2TypeEnum[keyof typeof OriginProvenanceOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf3
 */
export interface OriginProvenanceOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'type': OriginProvenanceOneOf3TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf3
     */
    'version'?: string;
}

export const OriginProvenanceOneOf3TypeEnum = {
    Api: 'api'
} as const;

export type OriginProvenanceOneOf3TypeEnum = typeof OriginProvenanceOneOf3TypeEnum[keyof typeof OriginProvenanceOneOf3TypeEnum];

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf4
 */
export interface OriginProvenanceOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'sessionId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OriginProvenanceOneOf4
     */
    'stepIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'type': OriginProvenanceOneOf4TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf4
     */
    'version'?: string;
}

export const OriginProvenanceOneOf4TypeEnum = {
    Flow: 'flow'
} as const;

export type OriginProvenanceOneOf4TypeEnum = typeof OriginProvenanceOneOf4TypeEnum[keyof typeof OriginProvenanceOneOf4TypeEnum];

/**
 * 
 * @export
 * @interface OriginProvenanceOneOf5
 */
export interface OriginProvenanceOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'type': OriginProvenanceOneOf5TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof OriginProvenanceOneOf5
     */
    'version'?: string;
}

export const OriginProvenanceOneOf5TypeEnum = {
    Migration: 'migration'
} as const;

export type OriginProvenanceOneOf5TypeEnum = typeof OriginProvenanceOneOf5TypeEnum[keyof typeof OriginProvenanceOneOf5TypeEnum];

/**
 * 
 * @export
 * @interface OutgoingEdgeResolveDepth
 */
export interface OutgoingEdgeResolveDepth {
    /**
     * 
     * @type {number}
     * @memberof OutgoingEdgeResolveDepth
     */
    'outgoing': number;
}
/**
 * 
 * @export
 * @interface OwnedDataTypeMetadata
 */
export interface OwnedDataTypeMetadata {
    /**
     * 
     * @type {{ [key: string]: Conversions; }}
     * @memberof OwnedDataTypeMetadata
     */
    'conversions'?: { [key: string]: Conversions; };
    /**
     * 
     * @type {string}
     * @memberof OwnedDataTypeMetadata
     */
    'ownedById': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof OwnedDataTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof OwnedDataTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof OwnedDataTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * 
 * @export
 * @interface OwnedEntityTypeMetadata
 */
export interface OwnedEntityTypeMetadata {
    /**
     * 
     * @type {string}
     * @memberof OwnedEntityTypeMetadata
     */
    'ownedById': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof OwnedEntityTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof OwnedEntityTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof OwnedEntityTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * 
 * @export
 * @interface OwnedPropertyTypeMetadata
 */
export interface OwnedPropertyTypeMetadata {
    /**
     * 
     * @type {string}
     * @memberof OwnedPropertyTypeMetadata
     */
    'ownedById': string;
    /**
     * 
     * @type {OntologyProvenance}
     * @memberof OwnedPropertyTypeMetadata
     */
    'provenance': OntologyProvenance;
    /**
     * 
     * @type {OntologyTypeRecordId}
     * @memberof OwnedPropertyTypeMetadata
     */
    'recordId': OntologyTypeRecordId;
    /**
     * 
     * @type {OntologyTemporalMetadata}
     * @memberof OwnedPropertyTypeMetadata
     */
    'temporalVersioning': OntologyTemporalMetadata;
}
/**
 * 
 * @export
 * @interface ParameterExpression
 */
export interface ParameterExpression {
    /**
     * 
     * @type {ParameterExpressionConvert}
     * @memberof ParameterExpression
     */
    'convert'?: ParameterExpressionConvert;
    /**
     * 
     * @type {any}
     * @memberof ParameterExpression
     */
    'parameter': any;
}
/**
 * 
 * @export
 * @interface ParameterExpressionConvert
 */
export interface ParameterExpressionConvert {
    /**
     * 
     * @type {string}
     * @memberof ParameterExpressionConvert
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof ParameterExpressionConvert
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface PatchEntityParams
 */
export interface PatchEntityParams {
    /**
     * 
     * @type {boolean}
     * @memberof PatchEntityParams
     */
    'archived'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchEntityParams
     */
    'confidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchEntityParams
     */
    'decisionTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchEntityParams
     */
    'draft'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchEntityParams
     */
    'entityId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchEntityParams
     */
    'entityTypeIds'?: Array<string>;
    /**
     * 
     * @type {Array<PropertyPatchOperation>}
     * @memberof PatchEntityParams
     */
    'properties'?: Array<PropertyPatchOperation>;
    /**
     * 
     * @type {ProvidedEntityEditionProvenance}
     * @memberof PatchEntityParams
     */
    'provenance'?: ProvidedEntityEditionProvenance;
}
/**
 * 
 * @export
 * @interface PathExpression
 */
export interface PathExpression {
    /**
     * 
     * @type {Array<PathExpressionPathInner>}
     * @memberof PathExpression
     */
    'path': Array<PathExpressionPathInner>;
}
/**
 * @type PathExpressionPathInner
 * @export
 */
export type PathExpressionPathInner = DataTypeQueryToken | EntityQueryToken | EntityTypeQueryToken | PropertyTypeQueryToken | Selector | number | string;

/**
 * 
 * @export
 * @interface PermissionResponse
 */
export interface PermissionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PermissionResponse
     */
    'has_permission': boolean;
}
/**
 * 
 * @export
 * @interface PinnedDecisionAxis
 */
export interface PinnedDecisionAxis {
    /**
     * 
     * @type {DecisionTime}
     * @memberof PinnedDecisionAxis
     */
    'axis': DecisionTime;
    /**
     * 
     * @type {string}
     * @memberof PinnedDecisionAxis
     */
    'timestamp': string;
}


/**
 * 
 * @export
 * @interface PinnedTransactionAxis
 */
export interface PinnedTransactionAxis {
    /**
     * 
     * @type {TransactionTime}
     * @memberof PinnedTransactionAxis
     */
    'axis': TransactionTime;
    /**
     * 
     * @type {string}
     * @memberof PinnedTransactionAxis
     */
    'timestamp': string;
}


/**
 * @type Property
 * @export
 */
export type Property = Array<Property> | PropertyObject | any;

/**
 * 
 * @export
 * @interface PropertyArrayValue
 */
export interface PropertyArrayValue {
    /**
     * 
     * @type {string}
     * @memberof PropertyArrayValue
     */
    'type': PropertyArrayValueTypeEnum;
    /**
     * 
     * @type {PropertyArrayValueItems}
     * @memberof PropertyArrayValue
     */
    'items': PropertyArrayValueItems;
    /**
     * 
     * @type {number}
     * @memberof PropertyArrayValue
     */
    'minItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyArrayValue
     */
    'maxItems'?: number;
}

export const PropertyArrayValueTypeEnum = {
    Array: 'array'
} as const;

export type PropertyArrayValueTypeEnum = typeof PropertyArrayValueTypeEnum[keyof typeof PropertyArrayValueTypeEnum];

/**
 * 
 * @export
 * @interface PropertyArrayValueItems
 */
export interface PropertyArrayValueItems {
    /**
     * 
     * @type {Array<PropertyValues>}
     * @memberof PropertyArrayValueItems
     */
    'oneOf': Array<PropertyValues>;
}
/**
 * @type PropertyDiff
 * @export
 */
export type PropertyDiff = PropertyDiffOneOf | PropertyDiffOneOf1 | PropertyDiffOneOf2;

/**
 * 
 * @export
 * @interface PropertyDiffOneOf
 */
export interface PropertyDiffOneOf {
    /**
     * 
     * @type {Property}
     * @memberof PropertyDiffOneOf
     */
    'added': Property;
    /**
     * 
     * @type {string}
     * @memberof PropertyDiffOneOf
     */
    'op': PropertyDiffOneOfOpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyDiffOneOf
     */
    'path': PropertyPath;
}

export const PropertyDiffOneOfOpEnum = {
    Added: 'added'
} as const;

export type PropertyDiffOneOfOpEnum = typeof PropertyDiffOneOfOpEnum[keyof typeof PropertyDiffOneOfOpEnum];

/**
 * 
 * @export
 * @interface PropertyDiffOneOf1
 */
export interface PropertyDiffOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PropertyDiffOneOf1
     */
    'op': PropertyDiffOneOf1OpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyDiffOneOf1
     */
    'path': PropertyPath;
    /**
     * 
     * @type {Property}
     * @memberof PropertyDiffOneOf1
     */
    'removed': Property;
}

export const PropertyDiffOneOf1OpEnum = {
    Removed: 'removed'
} as const;

export type PropertyDiffOneOf1OpEnum = typeof PropertyDiffOneOf1OpEnum[keyof typeof PropertyDiffOneOf1OpEnum];

/**
 * 
 * @export
 * @interface PropertyDiffOneOf2
 */
export interface PropertyDiffOneOf2 {
    /**
     * 
     * @type {Property}
     * @memberof PropertyDiffOneOf2
     */
    'new': Property;
    /**
     * 
     * @type {Property}
     * @memberof PropertyDiffOneOf2
     */
    'old': Property;
    /**
     * 
     * @type {string}
     * @memberof PropertyDiffOneOf2
     */
    'op': PropertyDiffOneOf2OpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyDiffOneOf2
     */
    'path': PropertyPath;
}

export const PropertyDiffOneOf2OpEnum = {
    Changed: 'changed'
} as const;

export type PropertyDiffOneOf2OpEnum = typeof PropertyDiffOneOf2OpEnum[keyof typeof PropertyDiffOneOf2OpEnum];

/**
 * @type PropertyMetadata
 * @export
 */
export type PropertyMetadata = PropertyMetadataArray | PropertyMetadataObject1 | PropertyMetadataValue;

/**
 * 
 * @export
 * @interface PropertyMetadataArray
 */
export interface PropertyMetadataArray {
    /**
     * 
     * @type {ArrayMetadata}
     * @memberof PropertyMetadataArray
     */
    'metadata'?: ArrayMetadata;
    /**
     * 
     * @type {Array<PropertyMetadata>}
     * @memberof PropertyMetadataArray
     */
    'value'?: Array<PropertyMetadata>;
}
/**
 * 
 * @export
 * @interface PropertyMetadataObject
 */
export interface PropertyMetadataObject {
    /**
     * 
     * @type {ObjectMetadata}
     * @memberof PropertyMetadataObject
     */
    'metadata'?: ObjectMetadata;
    /**
     * 
     * @type {{ [key: string]: PropertyMetadata; }}
     * @memberof PropertyMetadataObject
     */
    'value'?: { [key: string]: PropertyMetadata; };
}
/**
 * 
 * @export
 * @interface PropertyMetadataObject1
 */
export interface PropertyMetadataObject1 {
    /**
     * 
     * @type {ObjectMetadata}
     * @memberof PropertyMetadataObject1
     */
    'metadata'?: ObjectMetadata;
    /**
     * 
     * @type {{ [key: string]: PropertyMetadata; }}
     * @memberof PropertyMetadataObject1
     */
    'value'?: { [key: string]: PropertyMetadata; };
}
/**
 * 
 * @export
 * @interface PropertyMetadataValue
 */
export interface PropertyMetadataValue {
    /**
     * 
     * @type {ValueMetadata}
     * @memberof PropertyMetadataValue
     */
    'metadata': ValueMetadata;
}
/**
 * 
 * @export
 * @interface PropertyObject
 */
export interface PropertyObject {
    [key: string]: Property;

}
/**
 * 
 * @export
 * @interface PropertyObjectValue
 */
export interface PropertyObjectValue {
    /**
     * 
     * @type {string}
     * @memberof PropertyObjectValue
     */
    'type': PropertyObjectValueTypeEnum;
    /**
     * A JSON object where each entry is constrained by a property type.
     * @type {object}
     * @memberof PropertyObjectValue
     */
    'properties': object;
}

export const PropertyObjectValueTypeEnum = {
    Object: 'object'
} as const;

export type PropertyObjectValueTypeEnum = typeof PropertyObjectValueTypeEnum[keyof typeof PropertyObjectValueTypeEnum];

/**
 * @type PropertyPatchOperation
 * @export
 */
export type PropertyPatchOperation = PropertyPatchOperationOneOf | PropertyPatchOperationOneOf1 | PropertyPatchOperationOneOf2;

/**
 * 
 * @export
 * @interface PropertyPatchOperationOneOf
 */
export interface PropertyPatchOperationOneOf {
    /**
     * 
     * @type {string}
     * @memberof PropertyPatchOperationOneOf
     */
    'op': PropertyPatchOperationOneOfOpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyPatchOperationOneOf
     */
    'path': PropertyPath;
    /**
     * 
     * @type {PropertyWithMetadata}
     * @memberof PropertyPatchOperationOneOf
     */
    'property': PropertyWithMetadata;
}

export const PropertyPatchOperationOneOfOpEnum = {
    Add: 'add'
} as const;

export type PropertyPatchOperationOneOfOpEnum = typeof PropertyPatchOperationOneOfOpEnum[keyof typeof PropertyPatchOperationOneOfOpEnum];

/**
 * 
 * @export
 * @interface PropertyPatchOperationOneOf1
 */
export interface PropertyPatchOperationOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PropertyPatchOperationOneOf1
     */
    'op': PropertyPatchOperationOneOf1OpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyPatchOperationOneOf1
     */
    'path': PropertyPath;
}

export const PropertyPatchOperationOneOf1OpEnum = {
    Remove: 'remove'
} as const;

export type PropertyPatchOperationOneOf1OpEnum = typeof PropertyPatchOperationOneOf1OpEnum[keyof typeof PropertyPatchOperationOneOf1OpEnum];

/**
 * 
 * @export
 * @interface PropertyPatchOperationOneOf2
 */
export interface PropertyPatchOperationOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof PropertyPatchOperationOneOf2
     */
    'op': PropertyPatchOperationOneOf2OpEnum;
    /**
     * 
     * @type {PropertyPath}
     * @memberof PropertyPatchOperationOneOf2
     */
    'path': PropertyPath;
    /**
     * 
     * @type {PropertyWithMetadata}
     * @memberof PropertyPatchOperationOneOf2
     */
    'property': PropertyWithMetadata;
}

export const PropertyPatchOperationOneOf2OpEnum = {
    Replace: 'replace'
} as const;

export type PropertyPatchOperationOneOf2OpEnum = typeof PropertyPatchOperationOneOf2OpEnum[keyof typeof PropertyPatchOperationOneOf2OpEnum];

/**
 * 
 * @export
 * @interface PropertyPath
 */
export interface PropertyPath extends Array<PropertyPathElement> {
}
/**
 * @type PropertyPathElement
 * @export
 */
export type PropertyPathElement = number | string;

/**
 * 
 * @export
 * @interface PropertyProvenance
 */
export interface PropertyProvenance {
    /**
     * 
     * @type {Array<SourceProvenance>}
     * @memberof PropertyProvenance
     */
    'sources'?: Array<SourceProvenance>;
}
/**
 * Specifies the structure of a Block Protocol property type
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    '$schema': PropertyTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    'kind': PropertyTypeKindEnum;
    /**
     * The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`
     * @type {string}
     * @memberof PropertyType
     */
    '$id': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    'description': string;
    /**
     * 
     * @type {Array<PropertyValues>}
     * @memberof PropertyType
     */
    'oneOf': Array<PropertyValues>;
}

export const PropertyTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaPropertyType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/property-type'
} as const;

export type PropertyTypeSchemaEnum = typeof PropertyTypeSchemaEnum[keyof typeof PropertyTypeSchemaEnum];
export const PropertyTypeKindEnum = {
    PropertyType: 'propertyType'
} as const;

export type PropertyTypeKindEnum = typeof PropertyTypeKindEnum[keyof typeof PropertyTypeKindEnum];

/**
 * @type PropertyTypeEditorSubject
 * @export
 */
export type PropertyTypeEditorSubject = EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * 
 * @export
 * @interface PropertyTypeEmbedding
 */
export interface PropertyTypeEmbedding {
    /**
     * 
     * @type {Embedding}
     * @memberof PropertyTypeEmbedding
     */
    'embedding': Embedding;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeEmbedding
     */
    'propertyTypeId': string;
}
/**
 * @type PropertyTypeMetadata
 * @export
 */
export type PropertyTypeMetadata = ExternalPropertyTypeMetadata | OwnedPropertyTypeMetadata;

/**
 * @type PropertyTypeOwnerSubject
 * @export
 */
export type PropertyTypeOwnerSubject = DataTypeOwnerSubjectOneOf;

/**
 * 
 * @export
 * @enum {string}
 */

export const PropertyTypePermission = {
    Update: 'update',
    View: 'view'
} as const;

export type PropertyTypePermission = typeof PropertyTypePermission[keyof typeof PropertyTypePermission];


/**
 * A single token in a [`DataTypeQueryPath`].
 * @export
 * @enum {string}
 */

export const PropertyTypeQueryToken = {
    BaseUrl: 'baseUrl',
    Version: 'version',
    VersionedUrl: 'versionedUrl',
    OwnedById: 'ownedById',
    Title: 'title',
    Description: 'description',
    EditionProvenance: 'editionProvenance',
    DataTypes: 'dataTypes',
    PropertyTypes: 'propertyTypes',
    Embedding: 'embedding'
} as const;

export type PropertyTypeQueryToken = typeof PropertyTypeQueryToken[keyof typeof PropertyTypeQueryToken];


/**
 * @type PropertyTypeRelationAndSubject
 * @export
 */
export type PropertyTypeRelationAndSubject = PropertyTypeRelationAndSubjectOneOf | PropertyTypeRelationAndSubjectOneOf1 | PropertyTypeRelationAndSubjectOneOf2 | PropertyTypeRelationAndSubjectOneOf3;

/**
 * 
 * @export
 * @interface PropertyTypeRelationAndSubjectOneOf
 */
export interface PropertyTypeRelationAndSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRelationAndSubjectOneOf
     */
    'relation': PropertyTypeRelationAndSubjectOneOfRelationEnum;
    /**
     * 
     * @type {PropertyTypeOwnerSubject}
     * @memberof PropertyTypeRelationAndSubjectOneOf
     */
    'subject': PropertyTypeOwnerSubject;
}

export const PropertyTypeRelationAndSubjectOneOfRelationEnum = {
    Owner: 'owner'
} as const;

export type PropertyTypeRelationAndSubjectOneOfRelationEnum = typeof PropertyTypeRelationAndSubjectOneOfRelationEnum[keyof typeof PropertyTypeRelationAndSubjectOneOfRelationEnum];

/**
 * 
 * @export
 * @interface PropertyTypeRelationAndSubjectOneOf1
 */
export interface PropertyTypeRelationAndSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRelationAndSubjectOneOf1
     */
    'relation': PropertyTypeRelationAndSubjectOneOf1RelationEnum;
    /**
     * 
     * @type {PropertyTypeSettingSubject}
     * @memberof PropertyTypeRelationAndSubjectOneOf1
     */
    'subject': PropertyTypeSettingSubject;
}

export const PropertyTypeRelationAndSubjectOneOf1RelationEnum = {
    Setting: 'setting'
} as const;

export type PropertyTypeRelationAndSubjectOneOf1RelationEnum = typeof PropertyTypeRelationAndSubjectOneOf1RelationEnum[keyof typeof PropertyTypeRelationAndSubjectOneOf1RelationEnum];

/**
 * 
 * @export
 * @interface PropertyTypeRelationAndSubjectOneOf2
 */
export interface PropertyTypeRelationAndSubjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRelationAndSubjectOneOf2
     */
    'relation': PropertyTypeRelationAndSubjectOneOf2RelationEnum;
    /**
     * 
     * @type {PropertyTypeEditorSubject}
     * @memberof PropertyTypeRelationAndSubjectOneOf2
     */
    'subject': PropertyTypeEditorSubject;
}

export const PropertyTypeRelationAndSubjectOneOf2RelationEnum = {
    Editor: 'editor'
} as const;

export type PropertyTypeRelationAndSubjectOneOf2RelationEnum = typeof PropertyTypeRelationAndSubjectOneOf2RelationEnum[keyof typeof PropertyTypeRelationAndSubjectOneOf2RelationEnum];

/**
 * 
 * @export
 * @interface PropertyTypeRelationAndSubjectOneOf3
 */
export interface PropertyTypeRelationAndSubjectOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRelationAndSubjectOneOf3
     */
    'relation': PropertyTypeRelationAndSubjectOneOf3RelationEnum;
    /**
     * 
     * @type {PropertyTypeViewerSubject}
     * @memberof PropertyTypeRelationAndSubjectOneOf3
     */
    'subject': PropertyTypeViewerSubject;
}

export const PropertyTypeRelationAndSubjectOneOf3RelationEnum = {
    Viewer: 'viewer'
} as const;

export type PropertyTypeRelationAndSubjectOneOf3RelationEnum = typeof PropertyTypeRelationAndSubjectOneOf3RelationEnum[keyof typeof PropertyTypeRelationAndSubjectOneOf3RelationEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const PropertyTypeSetting = {
    UpdateFromWeb: 'updateFromWeb'
} as const;

export type PropertyTypeSetting = typeof PropertyTypeSetting[keyof typeof PropertyTypeSetting];


/**
 * @type PropertyTypeSettingSubject
 * @export
 */
export type PropertyTypeSettingSubject = PropertyTypeSettingSubjectOneOf;

/**
 * 
 * @export
 * @interface PropertyTypeSettingSubjectOneOf
 */
export interface PropertyTypeSettingSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeSettingSubjectOneOf
     */
    'kind': PropertyTypeSettingSubjectOneOfKindEnum;
    /**
     * 
     * @type {PropertyTypeSetting}
     * @memberof PropertyTypeSettingSubjectOneOf
     */
    'subjectId': PropertyTypeSetting;
}

export const PropertyTypeSettingSubjectOneOfKindEnum = {
    Setting: 'setting'
} as const;

export type PropertyTypeSettingSubjectOneOfKindEnum = typeof PropertyTypeSettingSubjectOneOfKindEnum[keyof typeof PropertyTypeSettingSubjectOneOfKindEnum];

/**
 * 
 * @export
 * @interface PropertyTypeVertex
 */
export interface PropertyTypeVertex {
    /**
     * 
     * @type {PropertyTypeWithMetadata}
     * @memberof PropertyTypeVertex
     */
    'inner': PropertyTypeWithMetadata;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeVertex
     */
    'kind': PropertyTypeVertexKindEnum;
}

export const PropertyTypeVertexKindEnum = {
    PropertyType: 'propertyType'
} as const;

export type PropertyTypeVertexKindEnum = typeof PropertyTypeVertexKindEnum[keyof typeof PropertyTypeVertexKindEnum];

/**
 * 
 * @export
 * @interface PropertyTypeVertexId
 */
export interface PropertyTypeVertexId {
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeVertexId
     */
    'baseId': string;
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeVertexId
     */
    'revisionId': number;
}
/**
 * @type PropertyTypeViewerSubject
 * @export
 */
export type PropertyTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * 
 * @export
 * @interface PropertyTypeWithMetadata
 */
export interface PropertyTypeWithMetadata {
    /**
     * 
     * @type {PropertyTypeMetadata}
     * @memberof PropertyTypeWithMetadata
     */
    'metadata': PropertyTypeMetadata;
    /**
     * 
     * @type {PropertyType}
     * @memberof PropertyTypeWithMetadata
     */
    'schema': PropertyType;
}
/**
 * @type PropertyValues
 * The definition of potential property values, either references to data types, objects made up of more property types, or an array where the items are defined from a set of other property values definitions.
 * @export
 */
export type PropertyValues = DataTypeReference | PropertyArrayValue | PropertyObjectValue;

/**
 * @type PropertyWithMetadata
 * @export
 */
export type PropertyWithMetadata = PropertyWithMetadataArray | PropertyWithMetadataObject | PropertyWithMetadataValue;

/**
 * 
 * @export
 * @interface PropertyWithMetadataArray
 */
export interface PropertyWithMetadataArray {
    /**
     * 
     * @type {ArrayMetadata}
     * @memberof PropertyWithMetadataArray
     */
    'metadata'?: ArrayMetadata;
    /**
     * 
     * @type {Array<PropertyWithMetadata>}
     * @memberof PropertyWithMetadataArray
     */
    'value'?: Array<PropertyWithMetadata>;
}
/**
 * 
 * @export
 * @interface PropertyWithMetadataObject
 */
export interface PropertyWithMetadataObject {
    /**
     * 
     * @type {ObjectMetadata}
     * @memberof PropertyWithMetadataObject
     */
    'metadata'?: ObjectMetadata;
    /**
     * 
     * @type {{ [key: string]: PropertyWithMetadata; }}
     * @memberof PropertyWithMetadataObject
     */
    'value'?: { [key: string]: PropertyWithMetadata; };
}
/**
 * 
 * @export
 * @interface PropertyWithMetadataValue
 */
export interface PropertyWithMetadataValue {
    /**
     * 
     * @type {ValueMetadata}
     * @memberof PropertyWithMetadataValue
     */
    'metadata': ValueMetadata;
    /**
     * 
     * @type {any}
     * @memberof PropertyWithMetadataValue
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface ProvidedEntityEditionProvenance
 */
export interface ProvidedEntityEditionProvenance {
    /**
     * 
     * @type {ActorType}
     * @memberof ProvidedEntityEditionProvenance
     */
    'actorType'?: ActorType;
    /**
     * 
     * @type {ProvidedEntityEditionProvenanceOrigin}
     * @memberof ProvidedEntityEditionProvenance
     */
    'origin'?: ProvidedEntityEditionProvenanceOrigin;
    /**
     * 
     * @type {Array<SourceProvenance>}
     * @memberof ProvidedEntityEditionProvenance
     */
    'sources'?: Array<SourceProvenance>;
}


/**
 * 
 * @export
 * @interface ProvidedEntityEditionProvenanceOrigin
 */
export interface ProvidedEntityEditionProvenanceOrigin {
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'apiKeyPublicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'environment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'semanticVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'type': ProvidedEntityEditionProvenanceOriginTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'userAgent'?: string;
    /**
     * The origin version, in whatever format the origin natively provides.
     * @type {string}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'version'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProvidedEntityEditionProvenanceOrigin
     */
    'stepIds'?: Array<string>;
}

export const ProvidedEntityEditionProvenanceOriginTypeEnum = {
    Migration: 'migration'
} as const;

export type ProvidedEntityEditionProvenanceOriginTypeEnum = typeof ProvidedEntityEditionProvenanceOriginTypeEnum[keyof typeof ProvidedEntityEditionProvenanceOriginTypeEnum];

/**
 * 
 * @export
 * @interface ProvidedOntologyEditionProvenance
 */
export interface ProvidedOntologyEditionProvenance {
    /**
     * 
     * @type {ActorType}
     * @memberof ProvidedOntologyEditionProvenance
     */
    'actorType'?: ActorType;
    /**
     * 
     * @type {ProvidedEntityEditionProvenanceOrigin}
     * @memberof ProvidedOntologyEditionProvenance
     */
    'origin'?: ProvidedEntityEditionProvenanceOrigin;
    /**
     * 
     * @type {Array<SourceProvenance>}
     * @memberof ProvidedOntologyEditionProvenance
     */
    'sources'?: Array<SourceProvenance>;
}


/**
 * 
 * @export
 * @interface QueryConversion
 */
export interface QueryConversion {
    /**
     * 
     * @type {string}
     * @memberof QueryConversion
     */
    'dataTypeId': string;
    /**
     * 
     * @type {PropertyPath}
     * @memberof QueryConversion
     */
    'path': PropertyPath;
}
/**
 * @type QueryTemporalAxes
 * Defines the two possible combinations of pinned/variable temporal axes that are used in responses to queries that return [`Subgraph`]s.  When querying the Graph, temporal data is returned. The Graph is implemented as a bitemporal data store, which means the knowledge data contains information about the time of when the knowledge was inserted into the Graph, the [`TransactionTime`], and when the knowledge was decided to be inserted, the [`DecisionTime`].  In order to query data from the Graph, only one of the two time axes can be used. This is achieved by using a `TemporalAxes`. The `TemporalAxes` pins one axis to a specified [`Timestamp`], while the other axis can be a [`Interval`]. The pinned axis is called the [`PinnedTemporalAxis`] and the other axis is called the [`VariableTemporalAxis`]. The returned data will then only contain temporal data that is contained in the [`Interval`] of the [`VariableTemporalAxis`] for the given [`Timestamp`] of the [`PinnedTemporalAxis`].  [`Subgraph`]: crate::subgraph::Subgraph [`Interval`]: temporal_versioning::Interval
 * @export
 */
export type QueryTemporalAxes = QueryTemporalAxesDecisionTime | QueryTemporalAxesTransactionTime;

/**
 * 
 * @export
 * @interface QueryTemporalAxesDecisionTime
 */
export interface QueryTemporalAxesDecisionTime {
    /**
     * 
     * @type {PinnedTransactionAxis}
     * @memberof QueryTemporalAxesDecisionTime
     */
    'pinned': PinnedTransactionAxis;
    /**
     * 
     * @type {VariableDecisionAxis}
     * @memberof QueryTemporalAxesDecisionTime
     */
    'variable': VariableDecisionAxis;
}
/**
 * 
 * @export
 * @interface QueryTemporalAxesTransactionTime
 */
export interface QueryTemporalAxesTransactionTime {
    /**
     * 
     * @type {PinnedDecisionAxis}
     * @memberof QueryTemporalAxesTransactionTime
     */
    'pinned': PinnedDecisionAxis;
    /**
     * 
     * @type {VariableTransactionAxis}
     * @memberof QueryTemporalAxesTransactionTime
     */
    'variable': VariableTransactionAxis;
}
/**
 * @type QueryTemporalAxesUnresolved
 * Defines the two possible combinations of pinned/variable temporal axes that are used in queries that return [`Subgraph`]s.  The [`VariableTemporalAxisUnresolved`] is optionally bounded, in the absence of provided bounds an inclusive bound at the timestamp at point of resolving is assumed.  [`Subgraph`]: crate::subgraph::Subgraph
 * @export
 */
export type QueryTemporalAxesUnresolved = QueryTemporalAxesUnresolvedDecisionTime | QueryTemporalAxesUnresolvedTransactionTime;

/**
 * 
 * @export
 * @interface QueryTemporalAxesUnresolvedDecisionTime
 */
export interface QueryTemporalAxesUnresolvedDecisionTime {
    /**
     * 
     * @type {UnresolvedPinnedTransactionAxis}
     * @memberof QueryTemporalAxesUnresolvedDecisionTime
     */
    'pinned': UnresolvedPinnedTransactionAxis;
    /**
     * 
     * @type {UnresolvedVariableDecisionAxis}
     * @memberof QueryTemporalAxesUnresolvedDecisionTime
     */
    'variable': UnresolvedVariableDecisionAxis;
}
/**
 * 
 * @export
 * @interface QueryTemporalAxesUnresolvedTransactionTime
 */
export interface QueryTemporalAxesUnresolvedTransactionTime {
    /**
     * 
     * @type {UnresolvedPinnedDecisionAxis}
     * @memberof QueryTemporalAxesUnresolvedTransactionTime
     */
    'pinned': UnresolvedPinnedDecisionAxis;
    /**
     * 
     * @type {UnresolvedVariableTransactionAxis}
     * @memberof QueryTemporalAxesUnresolvedTransactionTime
     */
    'variable': UnresolvedVariableTransactionAxis;
}
/**
 * 
 * @export
 * @interface RequestInfo
 */
export interface RequestInfo {
    /**
     * An opaque string that should only be interpreted by the service generating it. For example, it can be used to identify requests in the service\'s logs.
     * @type {string}
     * @memberof RequestInfo
     */
    'requestId': string;
    /**
     * Any data that was used to serve this request. For example, an encrypted stack trace that can be sent back to the service provider for debugging.
     * @type {string}
     * @memberof RequestInfo
     */
    'servingData': string;
}
/**
 * 
 * @export
 * @interface ResourceInfo
 */
export interface ResourceInfo {
    /**
     * A name for the type of resource being accessed.  For example \"SQL table\", \"Entity\", \"Property Type\", \"Redis\"; or the type URL of the resource: e.g. \"https://blockprotocol.org/type-system/0.3/schema/meta/entity-type\".
     * @type {string}
     * @memberof ResourceInfo
     */
    'resourceType': string;
    /**
     * The name of the resource being accessed.  For example, an ontology type ID: `https://hash.ai/@alice/types/entity-type/Person/`, if the current error is [@local/status/StatusCode.PermissionDenied].
     * @type {string}
     * @memberof ResourceInfo
     */
    'resourceName': string;
    /**
     * The owner of the resource (optional).  For example, a User\'s entity ID: `2cfa262a-f49a-4a61-a9c5-80a0c5959994%45e528cb-801d-49d1-8f71-d9e2af38a5e7`;
     * @type {string}
     * @memberof ResourceInfo
     */
    'owner'?: string;
    /**
     * Describes what error is encountered when accessing this resource.  For example, updating a property on a user\'s entity may require write permission on that property.
     * @type {string}
     * @memberof ResourceInfo
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface RightBoundedTemporalInterval
 */
export interface RightBoundedTemporalInterval {
    /**
     * 
     * @type {LimitedTemporalBound}
     * @memberof RightBoundedTemporalInterval
     */
    'end': LimitedTemporalBound;
    /**
     * 
     * @type {TemporalBound}
     * @memberof RightBoundedTemporalInterval
     */
    'start': TemporalBound;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Selector = {
    Star: '*'
} as const;

export type Selector = typeof Selector[keyof typeof Selector];


/**
 * 
 * @export
 * @enum {string}
 */

export const SharedEdgeKind = {
    IsOfType: 'IS_OF_TYPE'
} as const;

export type SharedEdgeKind = typeof SharedEdgeKind[keyof typeof SharedEdgeKind];


/**
 * The source material used in producing a value.
 * @export
 * @interface SourceProvenance
 */
export interface SourceProvenance {
    /**
     * The people or organizations that authored the material.
     * @type {Array<string>}
     * @memberof SourceProvenance
     */
    'authors'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SourceProvenance
     */
    'entityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceProvenance
     */
    'firstPublished'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceProvenance
     */
    'lastUpdated'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceProvenance
     */
    'loadedAt'?: string;
    /**
     * 
     * @type {SourceProvenanceLocation}
     * @memberof SourceProvenance
     */
    'location'?: SourceProvenanceLocation;
    /**
     * 
     * @type {SourceType}
     * @memberof SourceProvenance
     */
    'type': SourceType;
}


/**
 * 
 * @export
 * @interface SourceProvenanceLocation
 */
export interface SourceProvenanceLocation {
    /**
     * Encapsulates a message intended to be read by the end user.
     * @type {string}
     * @memberof SourceProvenanceLocation
     */
    'description'?: string;
    /**
     * A string containing the name of the location.
     * @type {string}
     * @memberof SourceProvenanceLocation
     */
    'name'?: string;
    /**
     * A string containing a valid relative or absolute URI.
     * @type {string}
     * @memberof SourceProvenanceLocation
     */
    'uri'?: string;
}
/**
 * The type of source material which was used to produce a value.
 * @export
 * @enum {string}
 */

export const SourceType = {
    Webpage: 'webpage',
    Document: 'document'
} as const;

export type SourceType = typeof SourceType[keyof typeof SourceType];


/**
 * 
 * @export
 * @interface StartsWithFilter
 */
export interface StartsWithFilter {
    /**
     * 
     * @type {Array<FilterExpression>}
     * @memberof StartsWithFilter
     */
    'startsWith': Array<FilterExpression>;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {StatusCode}
     * @memberof Status
     */
    'code': StatusCode;
    /**
     * A developer-facing description of the status.  Where possible, this should provide guiding advice for debugging and/or handling the error.
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
    /**
     * 
     * @type {Array<StatusContentsInner>}
     * @memberof Status
     */
    'contents': Array<StatusContentsInner>;
}


/**
 * The canonical status codes for software within the HASH ecosystem. Sometimes multiple status codes may apply. Services should return the most specific status code that applies. For example, prefer `OutOfRange` over `FailedPrecondition` if both codes apply. Similarly prefer `NotFound` or `AlreadyExists` over `FailedPrecondition`.
 * @export
 * @enum {string}
 */

export const StatusCode = {
    Aborted: 'ABORTED',
    AlreadyExists: 'ALREADY_EXISTS',
    Cancelled: 'CANCELLED',
    DataLoss: 'DATA_LOSS',
    DeadlineExceeded: 'DEADLINE_EXCEEDED',
    FailedPrecondition: 'FAILED_PRECONDITION',
    Internal: 'INTERNAL',
    InvalidArgument: 'INVALID_ARGUMENT',
    NotFound: 'NOT_FOUND',
    Ok: 'OK',
    OutOfRange: 'OUT_OF_RANGE',
    PermissionDenied: 'PERMISSION_DENIED',
    ResourceExhausted: 'RESOURCE_EXHAUSTED',
    Unauthenticated: 'UNAUTHENTICATED',
    Unavailable: 'UNAVAILABLE',
    Unimplemented: 'UNIMPLEMENTED',
    Unknown: 'UNKNOWN'
} as const;

export type StatusCode = typeof StatusCode[keyof typeof StatusCode];


/**
 * @type StatusContentsInner
 * @export
 */
export type StatusContentsInner = ErrorInfo | RequestInfo | ResourceInfo;

/**
 * 
 * @export
 * @interface Subgraph
 */
export interface Subgraph {
    /**
     * 
     * @type {GraphResolveDepths}
     * @memberof Subgraph
     */
    'depths': GraphResolveDepths;
    /**
     * 
     * @type {Edges}
     * @memberof Subgraph
     */
    'edges': Edges;
    /**
     * 
     * @type {Array<GraphElementVertexId>}
     * @memberof Subgraph
     */
    'roots': Array<GraphElementVertexId>;
    /**
     * 
     * @type {SubgraphTemporalAxes}
     * @memberof Subgraph
     */
    'temporalAxes': SubgraphTemporalAxes;
    /**
     * 
     * @type {Vertices}
     * @memberof Subgraph
     */
    'vertices': Vertices;
}
/**
 * 
 * @export
 * @interface SubgraphTemporalAxes
 */
export interface SubgraphTemporalAxes {
    /**
     * 
     * @type {QueryTemporalAxesUnresolved}
     * @memberof SubgraphTemporalAxes
     */
    'initial': QueryTemporalAxesUnresolved;
    /**
     * 
     * @type {QueryTemporalAxes}
     * @memberof SubgraphTemporalAxes
     */
    'resolved': QueryTemporalAxes;
}
/**
 * @type TemporalBound
 * @export
 */
export type TemporalBound = ExclusiveBound | InclusiveBound | UnboundedBound;

/**
 * Time axis for the transaction time.  This is used as the generic argument to time-related structs and can be used as tag value.
 * @export
 * @enum {string}
 */

export const TransactionTime = {
    TransactionTime: 'transactionTime'
} as const;

export type TransactionTime = typeof TransactionTime[keyof typeof TransactionTime];


/**
 * 
 * @export
 * @interface UnarchiveDataTypeParams
 */
export interface UnarchiveDataTypeParams {
    /**
     * 
     * @type {string}
     * @memberof UnarchiveDataTypeParams
     */
    'dataTypeId': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UnarchiveDataTypeParams
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
}
/**
 * 
 * @export
 * @interface UnarchiveEntityTypeParams
 */
export interface UnarchiveEntityTypeParams {
    /**
     * 
     * @type {string}
     * @memberof UnarchiveEntityTypeParams
     */
    'entityTypeId': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UnarchiveEntityTypeParams
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
}
/**
 * 
 * @export
 * @interface UnarchivePropertyTypeParams
 */
export interface UnarchivePropertyTypeParams {
    /**
     * 
     * @type {string}
     * @memberof UnarchivePropertyTypeParams
     */
    'propertyTypeId': string;
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UnarchivePropertyTypeParams
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
}
/**
 * 
 * @export
 * @interface UnboundedBound
 */
export interface UnboundedBound {
    /**
     * 
     * @type {string}
     * @memberof UnboundedBound
     */
    'kind': UnboundedBoundKindEnum;
}

export const UnboundedBoundKindEnum = {
    Unbounded: 'unbounded'
} as const;

export type UnboundedBoundKindEnum = typeof UnboundedBoundKindEnum[keyof typeof UnboundedBoundKindEnum];

/**
 * 
 * @export
 * @interface UnresolvedPinnedDecisionAxis
 */
export interface UnresolvedPinnedDecisionAxis {
    /**
     * 
     * @type {DecisionTime}
     * @memberof UnresolvedPinnedDecisionAxis
     */
    'axis': DecisionTime;
    /**
     * 
     * @type {string}
     * @memberof UnresolvedPinnedDecisionAxis
     */
    'timestamp': string | null;
}


/**
 * 
 * @export
 * @interface UnresolvedPinnedTransactionAxis
 */
export interface UnresolvedPinnedTransactionAxis {
    /**
     * 
     * @type {TransactionTime}
     * @memberof UnresolvedPinnedTransactionAxis
     */
    'axis': TransactionTime;
    /**
     * 
     * @type {string}
     * @memberof UnresolvedPinnedTransactionAxis
     */
    'timestamp': string | null;
}


/**
 * 
 * @export
 * @interface UnresolvedRightBoundedTemporalInterval
 */
export interface UnresolvedRightBoundedTemporalInterval {
    /**
     * 
     * @type {UnresolvedRightBoundedTemporalIntervalEnd}
     * @memberof UnresolvedRightBoundedTemporalInterval
     */
    'end': UnresolvedRightBoundedTemporalIntervalEnd | null;
    /**
     * 
     * @type {UnresolvedRightBoundedTemporalIntervalStart}
     * @memberof UnresolvedRightBoundedTemporalInterval
     */
    'start': UnresolvedRightBoundedTemporalIntervalStart | null;
}
/**
 * @type UnresolvedRightBoundedTemporalIntervalEnd
 * @export
 */
export type UnresolvedRightBoundedTemporalIntervalEnd = LimitedTemporalBound;

/**
 * @type UnresolvedRightBoundedTemporalIntervalStart
 * @export
 */
export type UnresolvedRightBoundedTemporalIntervalStart = TemporalBound;

/**
 * 
 * @export
 * @interface UnresolvedVariableDecisionAxis
 */
export interface UnresolvedVariableDecisionAxis {
    /**
     * 
     * @type {DecisionTime}
     * @memberof UnresolvedVariableDecisionAxis
     */
    'axis': DecisionTime;
    /**
     * 
     * @type {UnresolvedRightBoundedTemporalInterval}
     * @memberof UnresolvedVariableDecisionAxis
     */
    'interval': UnresolvedRightBoundedTemporalInterval;
}


/**
 * 
 * @export
 * @interface UnresolvedVariableTransactionAxis
 */
export interface UnresolvedVariableTransactionAxis {
    /**
     * 
     * @type {TransactionTime}
     * @memberof UnresolvedVariableTransactionAxis
     */
    'axis': TransactionTime;
    /**
     * 
     * @type {UnresolvedRightBoundedTemporalInterval}
     * @memberof UnresolvedVariableTransactionAxis
     */
    'interval': UnresolvedRightBoundedTemporalInterval;
}


/**
 * The contents of a Data Type update request
 * @export
 * @interface UpdateDataType
 */
export interface UpdateDataType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UpdateDataType
     */
    '$schema': UpdateDataTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataType
     */
    'kind': UpdateDataTypeKindEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataType
     */
    'description': string;
    /**
     * 
     * @type {UpdateDataTypeType}
     * @memberof UpdateDataType
     */
    'type'?: UpdateDataTypeType;
}

export const UpdateDataTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaDataType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/data-type'
} as const;

export type UpdateDataTypeSchemaEnum = typeof UpdateDataTypeSchemaEnum[keyof typeof UpdateDataTypeSchemaEnum];
export const UpdateDataTypeKindEnum = {
    DataType: 'dataType'
} as const;

export type UpdateDataTypeKindEnum = typeof UpdateDataTypeKindEnum[keyof typeof UpdateDataTypeKindEnum];

/**
 * 
 * @export
 * @interface UpdateDataTypeEmbeddingParams
 */
export interface UpdateDataTypeEmbeddingParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateDataTypeEmbeddingParams
     */
    'dataTypeId': string;
    /**
     * 
     * @type {Embedding}
     * @memberof UpdateDataTypeEmbeddingParams
     */
    'embedding': Embedding;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDataTypeEmbeddingParams
     */
    'reset': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataTypeEmbeddingParams
     */
    'updatedAtTransactionTime': string;
}
/**
 * 
 * @export
 * @interface UpdateDataTypeRequest
 */
export interface UpdateDataTypeRequest {
    /**
     * 
     * @type {{ [key: string]: Conversions; }}
     * @memberof UpdateDataTypeRequest
     */
    'conversions': { [key: string]: Conversions; };
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UpdateDataTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<DataTypeRelationAndSubject>}
     * @memberof UpdateDataTypeRequest
     */
    'relationships': Array<DataTypeRelationAndSubject>;
    /**
     * 
     * @type {UpdateDataType}
     * @memberof UpdateDataTypeRequest
     */
    'schema': UpdateDataType;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataTypeRequest
     */
    'typeToUpdate': string;
}
/**
 * @type UpdateDataTypeType
 * @export
 */
export type UpdateDataTypeType = Array<string> | string;

/**
 * 
 * @export
 * @interface UpdateEntityEmbeddingsParams
 */
export interface UpdateEntityEmbeddingsParams {
    /**
     * 
     * @type {Array<EntityEmbedding>}
     * @memberof UpdateEntityEmbeddingsParams
     */
    'embeddings': Array<EntityEmbedding>;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityEmbeddingsParams
     */
    'entityId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEntityEmbeddingsParams
     */
    'reset': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityEmbeddingsParams
     */
    'updatedAtDecisionTime': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityEmbeddingsParams
     */
    'updatedAtTransactionTime': string;
}
/**
 * The contents of an Entity Type update request
 * @export
 * @interface UpdateEntityType
 */
export interface UpdateEntityType {
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityType
     */
    '$schema': UpdateEntityTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityType
     */
    'kind': UpdateEntityTypeKindEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityType
     */
    'type': UpdateEntityTypeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityType
     */
    'description': string;
    /**
     * A JSON object where each entry is constrained by a property type.
     * @type {object}
     * @memberof UpdateEntityType
     */
    'properties': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateEntityType
     */
    'required'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof UpdateEntityType
     */
    'links'?: object;
}

export const UpdateEntityTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaEntityType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type'
} as const;

export type UpdateEntityTypeSchemaEnum = typeof UpdateEntityTypeSchemaEnum[keyof typeof UpdateEntityTypeSchemaEnum];
export const UpdateEntityTypeKindEnum = {
    EntityType: 'entityType'
} as const;

export type UpdateEntityTypeKindEnum = typeof UpdateEntityTypeKindEnum[keyof typeof UpdateEntityTypeKindEnum];
export const UpdateEntityTypeTypeEnum = {
    Object: 'object'
} as const;

export type UpdateEntityTypeTypeEnum = typeof UpdateEntityTypeTypeEnum[keyof typeof UpdateEntityTypeTypeEnum];

/**
 * 
 * @export
 * @interface UpdateEntityTypeEmbeddingParams
 */
export interface UpdateEntityTypeEmbeddingParams {
    /**
     * 
     * @type {Embedding}
     * @memberof UpdateEntityTypeEmbeddingParams
     */
    'embedding': Embedding;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityTypeEmbeddingParams
     */
    'entityTypeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEntityTypeEmbeddingParams
     */
    'reset': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityTypeEmbeddingParams
     */
    'updatedAtTransactionTime': string;
}
/**
 * 
 * @export
 * @interface UpdateEntityTypeRequest
 */
export interface UpdateEntityTypeRequest {
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UpdateEntityTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<EntityTypeRelationAndSubject>}
     * @memberof UpdateEntityTypeRequest
     */
    'relationships': Array<EntityTypeRelationAndSubject>;
    /**
     * 
     * @type {UpdateEntityType}
     * @memberof UpdateEntityTypeRequest
     */
    'schema': UpdateEntityType;
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityTypeRequest
     */
    'typeToUpdate': string;
}
/**
 * The contents of a Property Type update request
 * @export
 * @interface UpdatePropertyType
 */
export interface UpdatePropertyType {
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyType
     */
    '$schema': UpdatePropertyTypeSchemaEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyType
     */
    'kind': UpdatePropertyTypeKindEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyType
     */
    'description': string;
    /**
     * 
     * @type {Array<PropertyValues>}
     * @memberof UpdatePropertyType
     */
    'oneOf': Array<PropertyValues>;
}

export const UpdatePropertyTypeSchemaEnum = {
    HttpsBlockprotocolOrgTypesModulesGraph03SchemaPropertyType: 'https://blockprotocol.org/types/modules/graph/0.3/schema/property-type'
} as const;

export type UpdatePropertyTypeSchemaEnum = typeof UpdatePropertyTypeSchemaEnum[keyof typeof UpdatePropertyTypeSchemaEnum];
export const UpdatePropertyTypeKindEnum = {
    PropertyType: 'propertyType'
} as const;

export type UpdatePropertyTypeKindEnum = typeof UpdatePropertyTypeKindEnum[keyof typeof UpdatePropertyTypeKindEnum];

/**
 * 
 * @export
 * @interface UpdatePropertyTypeEmbeddingParams
 */
export interface UpdatePropertyTypeEmbeddingParams {
    /**
     * 
     * @type {Embedding}
     * @memberof UpdatePropertyTypeEmbeddingParams
     */
    'embedding': Embedding;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyTypeEmbeddingParams
     */
    'propertyTypeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePropertyTypeEmbeddingParams
     */
    'reset': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyTypeEmbeddingParams
     */
    'updatedAtTransactionTime': string;
}
/**
 * 
 * @export
 * @interface UpdatePropertyTypeRequest
 */
export interface UpdatePropertyTypeRequest {
    /**
     * 
     * @type {ProvidedOntologyEditionProvenance}
     * @memberof UpdatePropertyTypeRequest
     */
    'provenance'?: ProvidedOntologyEditionProvenance;
    /**
     * 
     * @type {Array<PropertyTypeRelationAndSubject>}
     * @memberof UpdatePropertyTypeRequest
     */
    'relationships': Array<PropertyTypeRelationAndSubject>;
    /**
     * 
     * @type {UpdatePropertyType}
     * @memberof UpdatePropertyTypeRequest
     */
    'schema': UpdatePropertyType;
    /**
     * 
     * @type {string}
     * @memberof UpdatePropertyTypeRequest
     */
    'typeToUpdate': string;
}
/**
 * 
 * @export
 * @interface ValidateEntityComponents
 */
export interface ValidateEntityComponents {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityComponents
     */
    'linkData'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityComponents
     */
    'numItems'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityComponents
     */
    'requiredProperties'?: boolean;
}
/**
 * 
 * @export
 * @interface ValidateEntityParams
 */
export interface ValidateEntityParams {
    /**
     * 
     * @type {ValidateEntityParamsComponents}
     * @memberof ValidateEntityParams
     */
    'components'?: ValidateEntityParamsComponents;
    /**
     * 
     * @type {EntityValidationType}
     * @memberof ValidateEntityParams
     */
    'entityTypes': EntityValidationType;
    /**
     * 
     * @type {CreateEntityRequestLinkData}
     * @memberof ValidateEntityParams
     */
    'linkData'?: CreateEntityRequestLinkData;
    /**
     * 
     * @type {PropertyWithMetadataObject}
     * @memberof ValidateEntityParams
     */
    'properties': PropertyWithMetadataObject;
}
/**
 * 
 * @export
 * @interface ValidateEntityParamsComponents
 */
export interface ValidateEntityParamsComponents {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityParamsComponents
     */
    'linkData'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityParamsComponents
     */
    'numItems'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateEntityParamsComponents
     */
    'requiredProperties'?: boolean;
}
/**
 * 
 * @export
 * @interface ValueMetadata
 */
export interface ValueMetadata {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ValueMetadata
     */
    'canonical'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ValueMetadata
     */
    'confidence'?: number;
    /**
     * 
     * @type {string}
     * @memberof ValueMetadata
     */
    'dataTypeId': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueMetadata
     */
    'originalDataTypeId'?: string;
    /**
     * 
     * @type {PropertyProvenance}
     * @memberof ValueMetadata
     */
    'provenance'?: PropertyProvenance;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Variable = {
    Self: 'self'
} as const;

export type Variable = typeof Variable[keyof typeof Variable];


/**
 * 
 * @export
 * @interface VariableDecisionAxis
 */
export interface VariableDecisionAxis {
    /**
     * 
     * @type {DecisionTime}
     * @memberof VariableDecisionAxis
     */
    'axis': DecisionTime;
    /**
     * 
     * @type {RightBoundedTemporalInterval}
     * @memberof VariableDecisionAxis
     */
    'interval': RightBoundedTemporalInterval;
}


/**
 * 
 * @export
 * @interface VariableTransactionAxis
 */
export interface VariableTransactionAxis {
    /**
     * 
     * @type {TransactionTime}
     * @memberof VariableTransactionAxis
     */
    'axis': TransactionTime;
    /**
     * 
     * @type {RightBoundedTemporalInterval}
     * @memberof VariableTransactionAxis
     */
    'interval': RightBoundedTemporalInterval;
}


/**
 * @type Vertex
 * @export
 */
export type Vertex = KnowledgeGraphVertex | OntologyVertex;

/**
 * 
 * @export
 * @interface Vertices
 */
export interface Vertices {
    [key: string]: { [key: string]: VerticesValueValue; };

}
/**
 * @type VerticesValueValue
 * @export
 */
export type VerticesValueValue = KnowledgeGraphVertex | OntologyVertex;

/**
 * @type WebDataTypeViewerSubject
 * @export
 */
export type WebDataTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * @type WebEntityCreatorSubject
 * @export
 */
export type WebEntityCreatorSubject = EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * @type WebEntityEditorSubject
 * @export
 */
export type WebEntityEditorSubject = EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * @type WebEntityTypeViewerSubject
 * @export
 */
export type WebEntityTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * @type WebEntityViewerSubject
 * @export
 */
export type WebEntityViewerSubject = DataTypeViewerSubjectOneOf | EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * @type WebOwnerSubject
 * @export
 */
export type WebOwnerSubject = EntityAdministratorSubjectOneOf | EntityTypeEditorSubjectOneOf;

/**
 * 
 * @export
 * @enum {string}
 */

export const WebPermission = {
    ChangePermission: 'change_permission',
    CreateEntity: 'create_entity',
    UpdateEntity: 'update_entity',
    ViewEntity: 'view_entity',
    CreateEntityType: 'create_entity_type',
    CreatePropertyType: 'create_property_type',
    CreateDataType: 'create_data_type'
} as const;

export type WebPermission = typeof WebPermission[keyof typeof WebPermission];


/**
 * @type WebPropertyTypeViewerSubject
 * @export
 */
export type WebPropertyTypeViewerSubject = DataTypeViewerSubjectOneOf;

/**
 * @type WebRelationAndSubject
 * @export
 */
export type WebRelationAndSubject = WebRelationAndSubjectOneOf | WebRelationAndSubjectOneOf1 | WebRelationAndSubjectOneOf2 | WebRelationAndSubjectOneOf3 | WebRelationAndSubjectOneOf4 | WebRelationAndSubjectOneOf5 | WebRelationAndSubjectOneOf6;

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf
 */
export interface WebRelationAndSubjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf
     */
    'relation': WebRelationAndSubjectOneOfRelationEnum;
    /**
     * 
     * @type {WebOwnerSubject}
     * @memberof WebRelationAndSubjectOneOf
     */
    'subject': WebOwnerSubject;
}

export const WebRelationAndSubjectOneOfRelationEnum = {
    Owner: 'owner'
} as const;

export type WebRelationAndSubjectOneOfRelationEnum = typeof WebRelationAndSubjectOneOfRelationEnum[keyof typeof WebRelationAndSubjectOneOfRelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf1
 */
export interface WebRelationAndSubjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf1
     */
    'relation': WebRelationAndSubjectOneOf1RelationEnum;
    /**
     * 
     * @type {WebEntityCreatorSubject}
     * @memberof WebRelationAndSubjectOneOf1
     */
    'subject': WebEntityCreatorSubject;
}

export const WebRelationAndSubjectOneOf1RelationEnum = {
    EntityCreator: 'entityCreator'
} as const;

export type WebRelationAndSubjectOneOf1RelationEnum = typeof WebRelationAndSubjectOneOf1RelationEnum[keyof typeof WebRelationAndSubjectOneOf1RelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf2
 */
export interface WebRelationAndSubjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf2
     */
    'relation': WebRelationAndSubjectOneOf2RelationEnum;
    /**
     * 
     * @type {WebEntityEditorSubject}
     * @memberof WebRelationAndSubjectOneOf2
     */
    'subject': WebEntityEditorSubject;
}

export const WebRelationAndSubjectOneOf2RelationEnum = {
    EntityEditor: 'entityEditor'
} as const;

export type WebRelationAndSubjectOneOf2RelationEnum = typeof WebRelationAndSubjectOneOf2RelationEnum[keyof typeof WebRelationAndSubjectOneOf2RelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf3
 */
export interface WebRelationAndSubjectOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf3
     */
    'relation': WebRelationAndSubjectOneOf3RelationEnum;
    /**
     * 
     * @type {WebEntityViewerSubject}
     * @memberof WebRelationAndSubjectOneOf3
     */
    'subject': WebEntityViewerSubject;
}

export const WebRelationAndSubjectOneOf3RelationEnum = {
    EntityViewer: 'entityViewer'
} as const;

export type WebRelationAndSubjectOneOf3RelationEnum = typeof WebRelationAndSubjectOneOf3RelationEnum[keyof typeof WebRelationAndSubjectOneOf3RelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf4
 */
export interface WebRelationAndSubjectOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf4
     */
    'relation': WebRelationAndSubjectOneOf4RelationEnum;
    /**
     * 
     * @type {WebEntityTypeViewerSubject}
     * @memberof WebRelationAndSubjectOneOf4
     */
    'subject': WebEntityTypeViewerSubject;
}

export const WebRelationAndSubjectOneOf4RelationEnum = {
    EntityTypeViewer: 'entityTypeViewer'
} as const;

export type WebRelationAndSubjectOneOf4RelationEnum = typeof WebRelationAndSubjectOneOf4RelationEnum[keyof typeof WebRelationAndSubjectOneOf4RelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf5
 */
export interface WebRelationAndSubjectOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf5
     */
    'relation': WebRelationAndSubjectOneOf5RelationEnum;
    /**
     * 
     * @type {WebPropertyTypeViewerSubject}
     * @memberof WebRelationAndSubjectOneOf5
     */
    'subject': WebPropertyTypeViewerSubject;
}

export const WebRelationAndSubjectOneOf5RelationEnum = {
    PropertyTypeViewer: 'propertyTypeViewer'
} as const;

export type WebRelationAndSubjectOneOf5RelationEnum = typeof WebRelationAndSubjectOneOf5RelationEnum[keyof typeof WebRelationAndSubjectOneOf5RelationEnum];

/**
 * 
 * @export
 * @interface WebRelationAndSubjectOneOf6
 */
export interface WebRelationAndSubjectOneOf6 {
    /**
     * 
     * @type {string}
     * @memberof WebRelationAndSubjectOneOf6
     */
    'relation': WebRelationAndSubjectOneOf6RelationEnum;
    /**
     * 
     * @type {WebDataTypeViewerSubject}
     * @memberof WebRelationAndSubjectOneOf6
     */
    'subject': WebDataTypeViewerSubject;
}

export const WebRelationAndSubjectOneOf6RelationEnum = {
    DataTypeViewer: 'dataTypeViewer'
} as const;

export type WebRelationAndSubjectOneOf6RelationEnum = typeof WebRelationAndSubjectOneOf6RelationEnum[keyof typeof WebRelationAndSubjectOneOf6RelationEnum];


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createAccount', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertAccountIdParams' is not null or undefined
            assertParamExists('createAccount', 'insertAccountIdParams', insertAccountIdParams)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertAccountIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: any): AxiosPromise<string> {
            return localVarFp.createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountIdParams} insertAccountIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig): AxiosPromise<string>;

}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountIdParams} insertAccountIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountGroupApi - axios parameter creator
 * @export
 */
export const AccountGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountGroupMember: async (xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'accountGroupId', accountGroupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'accountId', accountId)
            const localVarPath = `/account_groups/{account_group_id}/members/{account_id}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGroupPermission: async (xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'accountGroupId', accountGroupId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'permission', permission)
            const localVarPath = `/account_groups/{account_group_id}/permissions/{permission}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountGroup: async (xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createAccountGroup', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertAccountGroupIdParams' is not null or undefined
            assertParamExists('createAccountGroup', 'insertAccountGroupIdParams', insertAccountGroupIdParams)
            const localVarPath = `/account_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertAccountGroupIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountGroupMember: async (xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'accountGroupId', accountGroupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'accountId', accountId)
            const localVarPath = `/account_groups/{account_group_id}/members/{account_id}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountGroupApi - functional programming interface
 * @export
 */
export const AccountGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountGroupApi - factory interface
 * @export
 */
export const AccountGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountGroupApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: any): AxiosPromise<string> {
            return localVarFp.createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountGroupApi - interface
 * @export
 * @interface AccountGroupApi
 */
export interface AccountGroupApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to add the member to
     * @param {string} accountId The ID of the account to add to the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApiInterface
     */
    addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
     * @param {AccountGroupPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApiInterface
     */
    checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApiInterface
     */
    createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to remove the member from
     * @param {string} accountId The ID of the account to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApiInterface
     */
    removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AccountGroupApi - object-oriented interface
 * @export
 * @class AccountGroupApi
 * @extends {BaseAPI}
 */
export class AccountGroupApi extends BaseAPI implements AccountGroupApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to add the member to
     * @param {string} accountId The ID of the account to add to the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApi
     */
    public addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountGroupApiFp(this.configuration).addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
     * @param {AccountGroupPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApi
     */
    public checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig) {
        return AccountGroupApiFp(this.configuration).checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApi
     */
    public createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig) {
        return AccountGroupApiFp(this.configuration).createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to remove the member from
     * @param {string} accountId The ID of the account to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountGroupApi
     */
    public removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountGroupApiFp(this.configuration).removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataTypeApi - axios parameter creator
 * @export
 */
export const DataTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataType: async (xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archiveDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archiveDataTypeParams' is not null or undefined
            assertParamExists('archiveDataType', 'archiveDataTypeParams', archiveDataTypeParams)
            const localVarPath = `/data-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveDataTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDataTypePermission: async (xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkDataTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'dataTypeId' is not null or undefined
            assertParamExists('checkDataTypePermission', 'dataTypeId', dataTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkDataTypePermission', 'permission', permission)
            const localVarPath = `/data-types/{data_type_id}/permissions/{permission}`
                .replace(`{${"data_type_id"}}`, encodeURIComponent(String(dataTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataType: async (xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createDataTypeRequest' is not null or undefined
            assertParamExists('createDataType', 'createDataTypeRequest', createDataTypeRequest)
            const localVarPath = `/data-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, dataTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'dataTypeId' is not null or undefined
            assertParamExists('getDataTypeAuthorizationRelationships', 'dataTypeId', dataTypeId)
            const localVarPath = `/data-types/{data_type_id}/relationships`
                .replace(`{${"data_type_id"}}`, encodeURIComponent(String(dataTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeSubgraph: async (xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getDataTypeSubgraphParams' is not null or undefined
            assertParamExists('getDataTypeSubgraph', 'getDataTypeSubgraphParams', getDataTypeSubgraphParams)
            const localVarPath = `/data-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDataTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes: async (xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getDataTypesParams' is not null or undefined
            assertParamExists('getDataTypes', 'getDataTypesParams', getDataTypesParams)
            const localVarPath = `/data-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDataTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalDataType: async (xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalDataTypeRequest' is not null or undefined
            assertParamExists('loadExternalDataType', 'loadExternalDataTypeRequest', loadExternalDataTypeRequest)
            const localVarPath = `/data-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDataTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyDataTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyDataTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyDataTypeAuthorizationRelationships', 'modifyDataTypeAuthorizationRelationship', modifyDataTypeAuthorizationRelationship)
            const localVarPath = `/data-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyDataTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveDataType: async (xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchiveDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchiveDataTypeParams' is not null or undefined
            assertParamExists('unarchiveDataType', 'unarchiveDataTypeParams', unarchiveDataTypeParams)
            const localVarPath = `/data-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchiveDataTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataType: async (xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateDataTypeRequest' is not null or undefined
            assertParamExists('updateDataType', 'updateDataTypeRequest', updateDataTypeRequest)
            const localVarPath = `/data-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataTypeEmbeddings: async (xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateDataTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateDataTypeEmbeddingParams' is not null or undefined
            assertParamExists('updateDataTypeEmbeddings', 'updateDataTypeEmbeddingParams', updateDataTypeEmbeddingParams)
            const localVarPath = `/data-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataTypeApi - functional programming interface
 * @export
 */
export const DataTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfDataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataTypeApi - factory interface
 * @export
 */
export const DataTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: any): AxiosPromise<MaybeListOfDataTypeMetadata> {
            return localVarFp.createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: any): AxiosPromise<Array<DataTypeRelationAndSubject>> {
            return localVarFp.getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: any): AxiosPromise<GetDataTypeSubgraphResponse> {
            return localVarFp.getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: any): AxiosPromise<GetDataTypesResponse> {
            return localVarFp.getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: any): AxiosPromise<DataTypeMetadata> {
            return localVarFp.loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<DataTypeMetadata> {
            return localVarFp.updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataTypeApi - interface
 * @export
 * @interface DataTypeApi
 */
export interface DataTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveDataTypeParams} archiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The data type ID to check if the actor has the permission
     * @param {DataTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateDataTypeRequest} createDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfDataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The Data type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<DataTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetDataTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypesParams} getDataTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetDataTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig): AxiosPromise<DataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeRequest} updateDataTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of data types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<DataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApiInterface
     */
    updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * DataTypeApi - object-oriented interface
 * @export
 * @class DataTypeApi
 * @extends {BaseAPI}
 */
export class DataTypeApi extends BaseAPI implements DataTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveDataTypeParams} archiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The data type ID to check if the actor has the permission
     * @param {DataTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateDataTypeRequest} createDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The Data type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypesParams} getDataTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeRequest} updateDataTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of data types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return DataTypeApiFp(this.configuration).updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityAdministrator: async (xAuthenticatedUserActorId: string, entityId: string, administrator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addEntityAdministrator', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('addEntityAdministrator', 'entityId', entityId)
            // verify required parameter 'administrator' is not null or undefined
            assertParamExists('addEntityAdministrator', 'administrator', administrator)
            const localVarPath = `/entities/{entity_id}/administrators/{administrator}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"administrator"}}`, encodeURIComponent(String(administrator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityEditor: async (xAuthenticatedUserActorId: string, entityId: string, editor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addEntityEditor', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('addEntityEditor', 'entityId', entityId)
            // verify required parameter 'editor' is not null or undefined
            assertParamExists('addEntityEditor', 'editor', editor)
            const localVarPath = `/entities/{entity_id}/editors/{editor}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"editor"}}`, encodeURIComponent(String(editor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityPermission: async (xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkEntityPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('checkEntityPermission', 'entityId', entityId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkEntityPermission', 'permission', permission)
            const localVarPath = `/entities/{entity_id}/permissions/{permission}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntities: async (xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('countEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'countEntitiesParams' is not null or undefined
            assertParamExists('countEntities', 'countEntitiesParams', countEntitiesParams)
            const localVarPath = `/entities/query/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countEntitiesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities: async (xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityRequest' is not null or undefined
            assertParamExists('createEntities', 'createEntityRequest', createEntityRequest)
            const localVarPath = `/entities/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityRequest' is not null or undefined
            assertParamExists('createEntity', 'createEntityRequest', createEntityRequest)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diffEntity: async (xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('diffEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'diffEntityParams' is not null or undefined
            assertParamExists('diffEntity', 'diffEntityParams', diffEntityParams)
            const localVarPath = `/entities/diff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(diffEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities: async (xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntitiesRequest' is not null or undefined
            assertParamExists('getEntities', 'getEntitiesRequest', getEntitiesRequest)
            const localVarPath = `/entities/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntitiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAuthorizationRelationships: async (xAuthenticatedUserActorId: string, entityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntityAuthorizationRelationships', 'entityId', entityId)
            const localVarPath = `/entities/{entity_id}/relationships`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySubgraph: async (xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntitySubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntitySubgraphRequest' is not null or undefined
            assertParamExists('getEntitySubgraph', 'getEntitySubgraphRequest', getEntitySubgraphRequest)
            const localVarPath = `/entities/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntitySubgraphRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyEntityAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyEntityAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyEntityAuthorizationRelationships', 'modifyEntityAuthorizationRelationship', modifyEntityAuthorizationRelationship)
            const localVarPath = `/entities/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyEntityAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntity: async (xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('patchEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'patchEntityParams' is not null or undefined
            assertParamExists('patchEntity', 'patchEntityParams', patchEntityParams)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityAdministrator: async (xAuthenticatedUserActorId: string, entityId: string, administrator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'entityId', entityId)
            // verify required parameter 'administrator' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'administrator', administrator)
            const localVarPath = `/entities/{entity_id}/administrators/{administrator}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"administrator"}}`, encodeURIComponent(String(administrator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityEditor: async (xAuthenticatedUserActorId: string, entityId: string, editor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeEntityEditor', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('removeEntityEditor', 'entityId', entityId)
            // verify required parameter 'editor' is not null or undefined
            assertParamExists('removeEntityEditor', 'editor', editor)
            const localVarPath = `/entities/{entity_id}/editors/{editor}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"editor"}}`, encodeURIComponent(String(editor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityEmbeddings: async (xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityEmbeddingsParams' is not null or undefined
            assertParamExists('updateEntityEmbeddings', 'updateEntityEmbeddingsParams', updateEntityEmbeddingsParams)
            const localVarPath = `/entities/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityEmbeddingsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity: async (xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('validateEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'validateEntityParams' is not null or undefined
            assertParamExists('validateEntity', 'validateEntityParams', validateEntityParams)
            const localVarPath = `/entities/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countEntities(xAuthenticatedUserActorId, countEntitiesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntities(xAuthenticatedUserActorId, createEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(xAuthenticatedUserActorId, createEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffEntityResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diffEntity(xAuthenticatedUserActorId, diffEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitySubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntity(xAuthenticatedUserActorId, patchEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateEntity(xAuthenticatedUserActorId, validateEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: any): AxiosPromise<void> {
            return localVarFp.addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: any): AxiosPromise<void> {
            return localVarFp.addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: any): AxiosPromise<number> {
            return localVarFp.countEntities(xAuthenticatedUserActorId, countEntitiesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: any): AxiosPromise<Array<Entity>> {
            return localVarFp.createEntities(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: any): AxiosPromise<Entity> {
            return localVarFp.createEntity(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: any): AxiosPromise<DiffEntityResult> {
            return localVarFp.diffEntity(xAuthenticatedUserActorId, diffEntityParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: any): AxiosPromise<GetEntitiesResponse> {
            return localVarFp.getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: any): AxiosPromise<Array<EntityRelationAndSubject>> {
            return localVarFp.getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: any): AxiosPromise<GetEntitySubgraphResponse> {
            return localVarFp.getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: any): AxiosPromise<Entity> {
            return localVarFp.patchEntity(xAuthenticatedUserActorId, patchEntityParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: any): AxiosPromise<void> {
            return localVarFp.validateEntity(xAuthenticatedUserActorId, validateEntityParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityApi - interface
 * @export
 * @interface EntityApi
 */
export interface EntityApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the administrator to
     * @param {string} administrator The administrator to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the editor to
     * @param {string} editor The editor to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The entity ID to check if the actor has the permission
     * @param {EntityPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CountEntitiesParams} countEntitiesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig): AxiosPromise<number>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<CreateEntityRequest>} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig): AxiosPromise<Array<Entity>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityRequest} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig): AxiosPromise<Entity>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {DiffEntityParams} diffEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig): AxiosPromise<DiffEntityResult>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitiesRequest} getEntitiesRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<GetEntitiesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<GetEntitySubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {PatchEntityParams} patchEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig): AxiosPromise<Entity>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the administrator from
     * @param {string} administrator The administrator to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the editor from
     * @param {string} editor The editor to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ValidateEntityParams} validateEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApiInterface
     */
    validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI implements EntityApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the administrator to
     * @param {string} administrator The administrator to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the editor to
     * @param {string} editor The editor to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The entity ID to check if the actor has the permission
     * @param {EntityPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CountEntitiesParams} countEntitiesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).countEntities(xAuthenticatedUserActorId, countEntitiesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<CreateEntityRequest>} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).createEntities(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityRequest} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).createEntity(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {DiffEntityParams} diffEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).diffEntity(xAuthenticatedUserActorId, diffEntityParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitiesRequest} getEntitiesRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {PatchEntityParams} patchEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).patchEntity(xAuthenticatedUserActorId, patchEntityParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the administrator from
     * @param {string} administrator The administrator to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the editor from
     * @param {string} editor The editor to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ValidateEntityParams} validateEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig) {
        return EntityApiFp(this.configuration).validateEntity(xAuthenticatedUserActorId, validateEntityParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntityTypeApi - axios parameter creator
 * @export
 */
export const EntityTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEntityType: async (xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archiveEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archiveEntityTypeParams' is not null or undefined
            assertParamExists('archiveEntityType', 'archiveEntityTypeParams', archiveEntityTypeParams)
            const localVarPath = `/entity-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityTypePermission: async (xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityTypeId' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'entityTypeId', entityTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'permission', permission)
            const localVarPath = `/entity-types/{entity_type_id}/permissions/{permission}`
                .replace(`{${"entity_type_id"}}`, encodeURIComponent(String(entityTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityType: async (xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityTypeRequest' is not null or undefined
            assertParamExists('createEntityType', 'createEntityTypeRequest', createEntityTypeRequest)
            const localVarPath = `/entity-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedMultiEntityType: async (xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getClosedMultiEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getClosedMultiEntityTypeParams' is not null or undefined
            assertParamExists('getClosedMultiEntityType', 'getClosedMultiEntityTypeParams', getClosedMultiEntityTypeParams)
            const localVarPath = `/entity-types/query/multi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getClosedMultiEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, entityTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityTypeId' is not null or undefined
            assertParamExists('getEntityTypeAuthorizationRelationships', 'entityTypeId', entityTypeId)
            const localVarPath = `/entity-types/{entity_type_id}/relationships`
                .replace(`{${"entity_type_id"}}`, encodeURIComponent(String(entityTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeSubgraph: async (xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntityTypeSubgraphParams' is not null or undefined
            assertParamExists('getEntityTypeSubgraph', 'getEntityTypeSubgraphParams', getEntityTypeSubgraphParams)
            const localVarPath = `/entity-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntityTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes: async (xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntityTypesParams' is not null or undefined
            assertParamExists('getEntityTypes', 'getEntityTypesParams', getEntityTypesParams)
            const localVarPath = `/entity-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntityTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalEntityType: async (xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalEntityTypeRequest' is not null or undefined
            assertParamExists('loadExternalEntityType', 'loadExternalEntityTypeRequest', loadExternalEntityTypeRequest)
            const localVarPath = `/entity-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyEntityTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyEntityTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyEntityTypeAuthorizationRelationships', 'modifyEntityTypeAuthorizationRelationship', modifyEntityTypeAuthorizationRelationship)
            const localVarPath = `/entity-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyEntityTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveEntityType: async (xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchiveEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchiveEntityTypeParams' is not null or undefined
            assertParamExists('unarchiveEntityType', 'unarchiveEntityTypeParams', unarchiveEntityTypeParams)
            const localVarPath = `/entity-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchiveEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType: async (xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityTypeRequest' is not null or undefined
            assertParamExists('updateEntityType', 'updateEntityTypeRequest', updateEntityTypeRequest)
            const localVarPath = `/entity-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeEmbeddings: async (xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityTypeEmbeddingParams' is not null or undefined
            assertParamExists('updateEntityTypeEmbeddings', 'updateEntityTypeEmbeddingParams', updateEntityTypeEmbeddingParams)
            const localVarPath = `/entity-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityTypeApi - functional programming interface
 * @export
 */
export const EntityTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfEntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClosedMultiEntityTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntityTypeApi - factory interface
 * @export
 */
export const EntityTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: any): AxiosPromise<MaybeListOfEntityTypeMetadata> {
            return localVarFp.createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: any): AxiosPromise<GetClosedMultiEntityTypeResponse> {
            return localVarFp.getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: any): AxiosPromise<Array<EntityTypeRelationAndSubject>> {
            return localVarFp.getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: any): AxiosPromise<GetEntityTypeSubgraphResponse> {
            return localVarFp.getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: any): AxiosPromise<GetEntityTypesResponse> {
            return localVarFp.getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: any): AxiosPromise<EntityTypeMetadata> {
            return localVarFp.loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<EntityTypeMetadata> {
            return localVarFp.updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityTypeApi - interface
 * @export
 * @interface EntityTypeApi
 */
export interface EntityTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The entity type ID to check if the actor has the permission
     * @param {EntityTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityTypeRequest} createEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfEntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<GetClosedMultiEntityTypeResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The Entity type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetEntityTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypesParams} getEntityTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetEntityTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entity types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<EntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApiInterface
     */
    updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * EntityTypeApi - object-oriented interface
 * @export
 * @class EntityTypeApi
 * @extends {BaseAPI}
 */
export class EntityTypeApi extends BaseAPI implements EntityTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The entity type ID to check if the actor has the permission
     * @param {EntityTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityTypeRequest} createEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The Entity type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypesParams} getEntityTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entity types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityTypeApi
     */
    public updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return EntityTypeApiFp(this.configuration).updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountGroupMember: async (xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'accountGroupId', accountGroupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAccountGroupMember', 'accountId', accountId)
            const localVarPath = `/account_groups/{account_group_id}/members/{account_id}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityAdministrator: async (xAuthenticatedUserActorId: string, entityId: string, administrator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addEntityAdministrator', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('addEntityAdministrator', 'entityId', entityId)
            // verify required parameter 'administrator' is not null or undefined
            assertParamExists('addEntityAdministrator', 'administrator', administrator)
            const localVarPath = `/entities/{entity_id}/administrators/{administrator}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"administrator"}}`, encodeURIComponent(String(administrator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityEditor: async (xAuthenticatedUserActorId: string, entityId: string, editor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('addEntityEditor', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('addEntityEditor', 'entityId', entityId)
            // verify required parameter 'editor' is not null or undefined
            assertParamExists('addEntityEditor', 'editor', editor)
            const localVarPath = `/entities/{entity_id}/editors/{editor}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"editor"}}`, encodeURIComponent(String(editor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataType: async (xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archiveDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archiveDataTypeParams' is not null or undefined
            assertParamExists('archiveDataType', 'archiveDataTypeParams', archiveDataTypeParams)
            const localVarPath = `/data-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveDataTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEntityType: async (xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archiveEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archiveEntityTypeParams' is not null or undefined
            assertParamExists('archiveEntityType', 'archiveEntityTypeParams', archiveEntityTypeParams)
            const localVarPath = `/entity-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archiveEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePropertyType: async (xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archivePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archivePropertyTypeParams' is not null or undefined
            assertParamExists('archivePropertyType', 'archivePropertyTypeParams', archivePropertyTypeParams)
            const localVarPath = `/property-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archivePropertyTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGroupPermission: async (xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'accountGroupId', accountGroupId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkAccountGroupPermission', 'permission', permission)
            const localVarPath = `/account_groups/{account_group_id}/permissions/{permission}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDataTypePermission: async (xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkDataTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'dataTypeId' is not null or undefined
            assertParamExists('checkDataTypePermission', 'dataTypeId', dataTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkDataTypePermission', 'permission', permission)
            const localVarPath = `/data-types/{data_type_id}/permissions/{permission}`
                .replace(`{${"data_type_id"}}`, encodeURIComponent(String(dataTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityPermission: async (xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkEntityPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('checkEntityPermission', 'entityId', entityId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkEntityPermission', 'permission', permission)
            const localVarPath = `/entities/{entity_id}/permissions/{permission}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityTypePermission: async (xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityTypeId' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'entityTypeId', entityTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkEntityTypePermission', 'permission', permission)
            const localVarPath = `/entity-types/{entity_type_id}/permissions/{permission}`
                .replace(`{${"entity_type_id"}}`, encodeURIComponent(String(entityTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPropertyTypePermission: async (xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'propertyTypeId' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'propertyTypeId', propertyTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'permission', permission)
            const localVarPath = `/property-types/{property_type_id}/permissions/{permission}`
                .replace(`{${"property_type_id"}}`, encodeURIComponent(String(propertyTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkWebPermission: async (xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkWebPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'webId' is not null or undefined
            assertParamExists('checkWebPermission', 'webId', webId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkWebPermission', 'permission', permission)
            const localVarPath = `/webs/{web_id}/permissions/{permission}`
                .replace(`{${"web_id"}}`, encodeURIComponent(String(webId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntities: async (xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('countEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'countEntitiesParams' is not null or undefined
            assertParamExists('countEntities', 'countEntitiesParams', countEntitiesParams)
            const localVarPath = `/entities/query/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countEntitiesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createAccount', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertAccountIdParams' is not null or undefined
            assertParamExists('createAccount', 'insertAccountIdParams', insertAccountIdParams)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertAccountIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountGroup: async (xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createAccountGroup', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertAccountGroupIdParams' is not null or undefined
            assertParamExists('createAccountGroup', 'insertAccountGroupIdParams', insertAccountGroupIdParams)
            const localVarPath = `/account_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertAccountGroupIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataType: async (xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createDataTypeRequest' is not null or undefined
            assertParamExists('createDataType', 'createDataTypeRequest', createDataTypeRequest)
            const localVarPath = `/data-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities: async (xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityRequest' is not null or undefined
            assertParamExists('createEntities', 'createEntityRequest', createEntityRequest)
            const localVarPath = `/entities/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity: async (xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityRequest' is not null or undefined
            assertParamExists('createEntity', 'createEntityRequest', createEntityRequest)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityType: async (xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createEntityTypeRequest' is not null or undefined
            assertParamExists('createEntityType', 'createEntityTypeRequest', createEntityTypeRequest)
            const localVarPath = `/entity-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType: async (xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createPropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createPropertyTypeRequest' is not null or undefined
            assertParamExists('createPropertyType', 'createPropertyTypeRequest', createPropertyTypeRequest)
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb: async (xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createWeb', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertWebIdParams' is not null or undefined
            assertParamExists('createWeb', 'insertWebIdParams', insertWebIdParams)
            const localVarPath = `/webs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertWebIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diffEntity: async (xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('diffEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'diffEntityParams' is not null or undefined
            assertParamExists('diffEntity', 'diffEntityParams', diffEntityParams)
            const localVarPath = `/entities/diff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(diffEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedMultiEntityType: async (xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getClosedMultiEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getClosedMultiEntityTypeParams' is not null or undefined
            assertParamExists('getClosedMultiEntityType', 'getClosedMultiEntityTypeParams', getClosedMultiEntityTypeParams)
            const localVarPath = `/entity-types/query/multi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getClosedMultiEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, dataTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'dataTypeId' is not null or undefined
            assertParamExists('getDataTypeAuthorizationRelationships', 'dataTypeId', dataTypeId)
            const localVarPath = `/data-types/{data_type_id}/relationships`
                .replace(`{${"data_type_id"}}`, encodeURIComponent(String(dataTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeSubgraph: async (xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getDataTypeSubgraphParams' is not null or undefined
            assertParamExists('getDataTypeSubgraph', 'getDataTypeSubgraphParams', getDataTypeSubgraphParams)
            const localVarPath = `/data-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDataTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes: async (xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getDataTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getDataTypesParams' is not null or undefined
            assertParamExists('getDataTypes', 'getDataTypesParams', getDataTypesParams)
            const localVarPath = `/data-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDataTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities: async (xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntities', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntitiesRequest' is not null or undefined
            assertParamExists('getEntities', 'getEntitiesRequest', getEntitiesRequest)
            const localVarPath = `/entities/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntitiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAuthorizationRelationships: async (xAuthenticatedUserActorId: string, entityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getEntityAuthorizationRelationships', 'entityId', entityId)
            const localVarPath = `/entities/{entity_id}/relationships`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySubgraph: async (xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntitySubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntitySubgraphRequest' is not null or undefined
            assertParamExists('getEntitySubgraph', 'getEntitySubgraphRequest', getEntitySubgraphRequest)
            const localVarPath = `/entities/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntitySubgraphRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, entityTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityTypeId' is not null or undefined
            assertParamExists('getEntityTypeAuthorizationRelationships', 'entityTypeId', entityTypeId)
            const localVarPath = `/entity-types/{entity_type_id}/relationships`
                .replace(`{${"entity_type_id"}}`, encodeURIComponent(String(entityTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeSubgraph: async (xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntityTypeSubgraphParams' is not null or undefined
            assertParamExists('getEntityTypeSubgraph', 'getEntityTypeSubgraphParams', getEntityTypeSubgraphParams)
            const localVarPath = `/entity-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntityTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes: async (xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getEntityTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getEntityTypesParams' is not null or undefined
            assertParamExists('getEntityTypes', 'getEntityTypesParams', getEntityTypesParams)
            const localVarPath = `/entity-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEntityTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, propertyTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'propertyTypeId' is not null or undefined
            assertParamExists('getPropertyTypeAuthorizationRelationships', 'propertyTypeId', propertyTypeId)
            const localVarPath = `/property-types/{property_type_id}/relationships`
                .replace(`{${"property_type_id"}}`, encodeURIComponent(String(propertyTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeSubgraph: async (xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getPropertyTypeSubgraphParams' is not null or undefined
            assertParamExists('getPropertyTypeSubgraph', 'getPropertyTypeSubgraphParams', getPropertyTypeSubgraphParams)
            const localVarPath = `/property-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPropertyTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypes: async (xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getPropertyTypesParams' is not null or undefined
            assertParamExists('getPropertyTypes', 'getPropertyTypesParams', getPropertyTypesParams)
            const localVarPath = `/property-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPropertyTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAuthorizationRelationships: async (xAuthenticatedUserActorId: string, webId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getWebAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'webId' is not null or undefined
            assertParamExists('getWebAuthorizationRelationships', 'webId', webId)
            const localVarPath = `/webs/{web_id}/relationships`
                .replace(`{${"web_id"}}`, encodeURIComponent(String(webId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalDataType: async (xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalDataTypeRequest' is not null or undefined
            assertParamExists('loadExternalDataType', 'loadExternalDataTypeRequest', loadExternalDataTypeRequest)
            const localVarPath = `/data-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalEntityType: async (xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalEntityTypeRequest' is not null or undefined
            assertParamExists('loadExternalEntityType', 'loadExternalEntityTypeRequest', loadExternalEntityTypeRequest)
            const localVarPath = `/entity-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalPropertyType: async (xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalPropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalPropertyTypeRequest' is not null or undefined
            assertParamExists('loadExternalPropertyType', 'loadExternalPropertyTypeRequest', loadExternalPropertyTypeRequest)
            const localVarPath = `/property-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDataTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyDataTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyDataTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyDataTypeAuthorizationRelationships', 'modifyDataTypeAuthorizationRelationship', modifyDataTypeAuthorizationRelationship)
            const localVarPath = `/data-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyDataTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyEntityAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyEntityAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyEntityAuthorizationRelationships', 'modifyEntityAuthorizationRelationship', modifyEntityAuthorizationRelationship)
            const localVarPath = `/entities/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyEntityAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyEntityTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyEntityTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyEntityTypeAuthorizationRelationships', 'modifyEntityTypeAuthorizationRelationship', modifyEntityTypeAuthorizationRelationship)
            const localVarPath = `/entity-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyEntityTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPropertyTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyPropertyTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyPropertyTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyPropertyTypeAuthorizationRelationships', 'modifyPropertyTypeAuthorizationRelationship', modifyPropertyTypeAuthorizationRelationship)
            const localVarPath = `/property-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyPropertyTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyWebAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyWebAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyWebAuthorizationRelationships', 'modifyWebAuthorizationRelationship', modifyWebAuthorizationRelationship)
            const localVarPath = `/webs/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyWebAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntity: async (xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('patchEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'patchEntityParams' is not null or undefined
            assertParamExists('patchEntity', 'patchEntityParams', patchEntityParams)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountGroupMember: async (xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'accountGroupId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'accountGroupId', accountGroupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAccountGroupMember', 'accountId', accountId)
            const localVarPath = `/account_groups/{account_group_id}/members/{account_id}`
                .replace(`{${"account_group_id"}}`, encodeURIComponent(String(accountGroupId)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityAdministrator: async (xAuthenticatedUserActorId: string, entityId: string, administrator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'entityId', entityId)
            // verify required parameter 'administrator' is not null or undefined
            assertParamExists('removeEntityAdministrator', 'administrator', administrator)
            const localVarPath = `/entities/{entity_id}/administrators/{administrator}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"administrator"}}`, encodeURIComponent(String(administrator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityEditor: async (xAuthenticatedUserActorId: string, entityId: string, editor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('removeEntityEditor', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('removeEntityEditor', 'entityId', entityId)
            // verify required parameter 'editor' is not null or undefined
            assertParamExists('removeEntityEditor', 'editor', editor)
            const localVarPath = `/entities/{entity_id}/editors/{editor}`
                .replace(`{${"entity_id"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"editor"}}`, encodeURIComponent(String(editor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveDataType: async (xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchiveDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchiveDataTypeParams' is not null or undefined
            assertParamExists('unarchiveDataType', 'unarchiveDataTypeParams', unarchiveDataTypeParams)
            const localVarPath = `/data-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchiveDataTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveEntityType: async (xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchiveEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchiveEntityTypeParams' is not null or undefined
            assertParamExists('unarchiveEntityType', 'unarchiveEntityTypeParams', unarchiveEntityTypeParams)
            const localVarPath = `/entity-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchiveEntityTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchivePropertyType: async (xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchivePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchivePropertyTypeParams' is not null or undefined
            assertParamExists('unarchivePropertyType', 'unarchivePropertyTypeParams', unarchivePropertyTypeParams)
            const localVarPath = `/property-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchivePropertyTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataType: async (xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateDataType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateDataTypeRequest' is not null or undefined
            assertParamExists('updateDataType', 'updateDataTypeRequest', updateDataTypeRequest)
            const localVarPath = `/data-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataTypeEmbeddings: async (xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateDataTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateDataTypeEmbeddingParams' is not null or undefined
            assertParamExists('updateDataTypeEmbeddings', 'updateDataTypeEmbeddingParams', updateDataTypeEmbeddingParams)
            const localVarPath = `/data-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityEmbeddings: async (xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityEmbeddingsParams' is not null or undefined
            assertParamExists('updateEntityEmbeddings', 'updateEntityEmbeddingsParams', updateEntityEmbeddingsParams)
            const localVarPath = `/entities/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityEmbeddingsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType: async (xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityTypeRequest' is not null or undefined
            assertParamExists('updateEntityType', 'updateEntityTypeRequest', updateEntityTypeRequest)
            const localVarPath = `/entity-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeEmbeddings: async (xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updateEntityTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updateEntityTypeEmbeddingParams' is not null or undefined
            assertParamExists('updateEntityTypeEmbeddings', 'updateEntityTypeEmbeddingParams', updateEntityTypeEmbeddingParams)
            const localVarPath = `/entity-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEntityTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType: async (xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updatePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
            assertParamExists('updatePropertyType', 'updatePropertyTypeRequest', updatePropertyTypeRequest)
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyTypeEmbeddings: async (xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updatePropertyTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updatePropertyTypeEmbeddingParams' is not null or undefined
            assertParamExists('updatePropertyTypeEmbeddings', 'updatePropertyTypeEmbeddingParams', updatePropertyTypeEmbeddingParams)
            const localVarPath = `/property-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity: async (xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('validateEntity', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'validateEntityParams' is not null or undefined
            assertParamExists('validateEntity', 'validateEntityParams', validateEntityParams)
            const localVarPath = `/entities/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateEntityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkWebPermission(xAuthenticatedUserActorId, webId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countEntities(xAuthenticatedUserActorId, countEntitiesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfDataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntities(xAuthenticatedUserActorId, createEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(xAuthenticatedUserActorId, createEntityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfEntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfPropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWeb(xAuthenticatedUserActorId, insertWebIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffEntityResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diffEntity(xAuthenticatedUserActorId, diffEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClosedMultiEntityTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntitySubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntityTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPropertyTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPropertyTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntity(xAuthenticatedUserActorId, patchEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateEntity(xAuthenticatedUserActorId, validateEntityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to add the member to
         * @param {string} accountId The ID of the account to add to the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the administrator to
         * @param {string} administrator The administrator to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: any): AxiosPromise<void> {
            return localVarFp.addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to add the editor to
         * @param {string} editor The editor to add to the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: any): AxiosPromise<void> {
            return localVarFp.addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveDataTypeParams} archiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
         * @param {AccountGroupPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The data type ID to check if the actor has the permission
         * @param {DataTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The entity ID to check if the actor has the permission
         * @param {EntityPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The entity type ID to check if the actor has the permission
         * @param {EntityTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkWebPermission(xAuthenticatedUserActorId, webId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CountEntitiesParams} countEntitiesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: any): AxiosPromise<number> {
            return localVarFp.countEntities(xAuthenticatedUserActorId, countEntitiesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountIdParams} insertAccountIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: any): AxiosPromise<string> {
            return localVarFp.createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: any): AxiosPromise<string> {
            return localVarFp.createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateDataTypeRequest} createDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: any): AxiosPromise<MaybeListOfDataTypeMetadata> {
            return localVarFp.createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<CreateEntityRequest>} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: any): AxiosPromise<Array<Entity>> {
            return localVarFp.createEntities(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityRequest} createEntityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: any): AxiosPromise<Entity> {
            return localVarFp.createEntity(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreateEntityTypeRequest} createEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: any): AxiosPromise<MaybeListOfEntityTypeMetadata> {
            return localVarFp.createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: any): AxiosPromise<MaybeListOfPropertyTypeMetadata> {
            return localVarFp.createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: any): AxiosPromise<void> {
            return localVarFp.createWeb(xAuthenticatedUserActorId, insertWebIdParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {DiffEntityParams} diffEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: any): AxiosPromise<DiffEntityResult> {
            return localVarFp.diffEntity(xAuthenticatedUserActorId, diffEntityParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: any): AxiosPromise<GetClosedMultiEntityTypeResponse> {
            return localVarFp.getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} dataTypeId The Data type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: any): AxiosPromise<Array<DataTypeRelationAndSubject>> {
            return localVarFp.getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: any): AxiosPromise<GetDataTypeSubgraphResponse> {
            return localVarFp.getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetDataTypesParams} getDataTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: any): AxiosPromise<GetDataTypesResponse> {
            return localVarFp.getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitiesRequest} getEntitiesRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: any): AxiosPromise<GetEntitiesResponse> {
            return localVarFp.getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: any): AxiosPromise<Array<EntityRelationAndSubject>> {
            return localVarFp.getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entities to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: any): AxiosPromise<GetEntitySubgraphResponse> {
            return localVarFp.getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityTypeId The Entity type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: any): AxiosPromise<Array<EntityTypeRelationAndSubject>> {
            return localVarFp.getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: any): AxiosPromise<GetEntityTypeSubgraphResponse> {
            return localVarFp.getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetEntityTypesParams} getEntityTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: any): AxiosPromise<GetEntityTypesResponse> {
            return localVarFp.getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: any): AxiosPromise<Array<PropertyTypeRelationAndSubject>> {
            return localVarFp.getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: any): AxiosPromise<GetPropertyTypeSubgraphResponse> {
            return localVarFp.getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: any): AxiosPromise<GetPropertyTypesResponse> {
            return localVarFp.getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: any): AxiosPromise<Array<WebRelationAndSubject>> {
            return localVarFp.getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: any): AxiosPromise<DataTypeMetadata> {
            return localVarFp.loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: any): AxiosPromise<EntityTypeMetadata> {
            return localVarFp.loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: any): AxiosPromise<PropertyTypeMetadata> {
            return localVarFp.loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {PatchEntityParams} patchEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: any): AxiosPromise<Entity> {
            return localVarFp.patchEntity(xAuthenticatedUserActorId, patchEntityParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} accountGroupId The ID of the account group to remove the member from
         * @param {string} accountId The ID of the account to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the administrator from
         * @param {string} administrator The administrator to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} entityId The Entity to remove the editor from
         * @param {string} editor The editor to remove from the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeRequest} updateDataTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of data types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<DataTypeMetadata> {
            return localVarFp.updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of entity types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<EntityTypeMetadata> {
            return localVarFp.updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<PropertyTypeMetadata> {
            return localVarFp.updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ValidateEntityParams} validateEntityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: any): AxiosPromise<void> {
            return localVarFp.validateEntity(xAuthenticatedUserActorId, validateEntityParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - interface
 * @export
 * @interface GraphApi
 */
export interface GraphApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to add the member to
     * @param {string} accountId The ID of the account to add to the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the administrator to
     * @param {string} administrator The administrator to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the editor to
     * @param {string} editor The editor to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveDataTypeParams} archiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
     * @param {AccountGroupPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The data type ID to check if the actor has the permission
     * @param {DataTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The entity ID to check if the actor has the permission
     * @param {EntityPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The entity type ID to check if the actor has the permission
     * @param {EntityTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The property type ID to check if the actor has the permission
     * @param {PropertyTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web ID to check if the actor has the permission
     * @param {WebPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CountEntitiesParams} countEntitiesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig): AxiosPromise<number>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountIdParams} insertAccountIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateDataTypeRequest} createDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfDataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<CreateEntityRequest>} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig): AxiosPromise<Array<Entity>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityRequest} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig): AxiosPromise<Entity>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityTypeRequest} createEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfEntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfPropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertWebIdParams} insertWebIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {DiffEntityParams} diffEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig): AxiosPromise<DiffEntityResult>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<GetClosedMultiEntityTypeResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The Data type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<DataTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetDataTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypesParams} getDataTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetDataTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitiesRequest} getEntitiesRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<GetEntitiesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<GetEntitySubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The Entity type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EntityTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetEntityTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypesParams} getEntityTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetEntityTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The Property type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<PropertyTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetPropertyTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypesParams} getPropertyTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetPropertyTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig): AxiosPromise<Array<WebRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig): AxiosPromise<DataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig): AxiosPromise<PropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {PatchEntityParams} patchEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig): AxiosPromise<Entity>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to remove the member from
     * @param {string} accountId The ID of the account to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the administrator from
     * @param {string} administrator The administrator to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the editor from
     * @param {string} editor The editor to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeRequest} updateDataTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of data types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<DataTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entity types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<EntityTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of property types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<PropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ValidateEntityParams} validateEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApiInterface
     */
    validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI implements GraphApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to add the member to
     * @param {string} accountId The ID of the account to add to the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public addAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).addAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the administrator to
     * @param {string} administrator The administrator to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public addEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).addEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to add the editor to
     * @param {string} editor The editor to add to the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public addEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).addEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveDataTypeParams} archiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public archiveDataType(xAuthenticatedUserActorId: string, archiveDataTypeParams: ArchiveDataTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).archiveDataType(xAuthenticatedUserActorId, archiveDataTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchiveEntityTypeParams} archiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public archiveEntityType(xAuthenticatedUserActorId: string, archiveEntityTypeParams: ArchiveEntityTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).archiveEntityType(xAuthenticatedUserActorId, archiveEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to check if the actor has the permission
     * @param {AccountGroupPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkAccountGroupPermission(xAuthenticatedUserActorId: string, accountGroupId: string, permission: AccountGroupPermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkAccountGroupPermission(xAuthenticatedUserActorId, accountGroupId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The data type ID to check if the actor has the permission
     * @param {DataTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkDataTypePermission(xAuthenticatedUserActorId: string, dataTypeId: string, permission: DataTypePermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkDataTypePermission(xAuthenticatedUserActorId, dataTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The entity ID to check if the actor has the permission
     * @param {EntityPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkEntityPermission(xAuthenticatedUserActorId: string, entityId: string, permission: EntityPermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkEntityPermission(xAuthenticatedUserActorId, entityId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The entity type ID to check if the actor has the permission
     * @param {EntityTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkEntityTypePermission(xAuthenticatedUserActorId: string, entityTypeId: string, permission: EntityTypePermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkEntityTypePermission(xAuthenticatedUserActorId, entityTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The property type ID to check if the actor has the permission
     * @param {PropertyTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web ID to check if the actor has the permission
     * @param {WebPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).checkWebPermission(xAuthenticatedUserActorId, webId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CountEntitiesParams} countEntitiesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public countEntities(xAuthenticatedUserActorId: string, countEntitiesParams: CountEntitiesParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).countEntities(xAuthenticatedUserActorId, countEntitiesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountIdParams} insertAccountIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createAccount(xAuthenticatedUserActorId: string, insertAccountIdParams: InsertAccountIdParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createAccount(xAuthenticatedUserActorId, insertAccountIdParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertAccountGroupIdParams} insertAccountGroupIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createAccountGroup(xAuthenticatedUserActorId: string, insertAccountGroupIdParams: InsertAccountGroupIdParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createAccountGroup(xAuthenticatedUserActorId, insertAccountGroupIdParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateDataTypeRequest} createDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createDataType(xAuthenticatedUserActorId: string, createDataTypeRequest: CreateDataTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createDataType(xAuthenticatedUserActorId, createDataTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<CreateEntityRequest>} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createEntities(xAuthenticatedUserActorId: string, createEntityRequest: Array<CreateEntityRequest>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createEntities(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityRequest} createEntityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createEntity(xAuthenticatedUserActorId: string, createEntityRequest: CreateEntityRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createEntity(xAuthenticatedUserActorId, createEntityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreateEntityTypeRequest} createEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createEntityType(xAuthenticatedUserActorId: string, createEntityTypeRequest: CreateEntityTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createEntityType(xAuthenticatedUserActorId, createEntityTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertWebIdParams} insertWebIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).createWeb(xAuthenticatedUserActorId, insertWebIdParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {DiffEntityParams} diffEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public diffEntity(xAuthenticatedUserActorId: string, diffEntityParams: DiffEntityParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).diffEntity(xAuthenticatedUserActorId, diffEntityParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetClosedMultiEntityTypeParams} getClosedMultiEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getClosedMultiEntityType(xAuthenticatedUserActorId: string, getClosedMultiEntityTypeParams: GetClosedMultiEntityTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getClosedMultiEntityType(xAuthenticatedUserActorId, getClosedMultiEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} dataTypeId The Data type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, dataTypeId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, dataTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypeSubgraphParams} getDataTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getDataTypeSubgraph(xAuthenticatedUserActorId: string, getDataTypeSubgraphParams: GetDataTypeSubgraphParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getDataTypeSubgraph(xAuthenticatedUserActorId, getDataTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetDataTypesParams} getDataTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getDataTypes(xAuthenticatedUserActorId: string, getDataTypesParams: GetDataTypesParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getDataTypes(xAuthenticatedUserActorId, getDataTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitiesRequest} getEntitiesRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntities(xAuthenticatedUserActorId: string, getEntitiesRequest: GetEntitiesRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntities(xAuthenticatedUserActorId, getEntitiesRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, entityId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntityAuthorizationRelationships(xAuthenticatedUserActorId, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntitySubgraphRequest} getEntitySubgraphRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entities to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntitySubgraph(xAuthenticatedUserActorId: string, getEntitySubgraphRequest: GetEntitySubgraphRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntitySubgraph(xAuthenticatedUserActorId, getEntitySubgraphRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityTypeId The Entity type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, entityTypeId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, entityTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypeSubgraphParams} getEntityTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntityTypeSubgraph(xAuthenticatedUserActorId: string, getEntityTypeSubgraphParams: GetEntityTypeSubgraphParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntityTypeSubgraph(xAuthenticatedUserActorId, getEntityTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetEntityTypesParams} getEntityTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getEntityTypes(xAuthenticatedUserActorId: string, getEntityTypesParams: GetEntityTypesParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getEntityTypes(xAuthenticatedUserActorId, getEntityTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The Property type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypesParams} getPropertyTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalDataTypeRequest} loadExternalDataTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public loadExternalDataType(xAuthenticatedUserActorId: string, loadExternalDataTypeRequest: LoadExternalDataTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).loadExternalDataType(xAuthenticatedUserActorId, loadExternalDataTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalEntityTypeRequest} loadExternalEntityTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public loadExternalEntityType(xAuthenticatedUserActorId: string, loadExternalEntityTypeRequest: LoadExternalEntityTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).loadExternalEntityType(xAuthenticatedUserActorId, loadExternalEntityTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyDataTypeAuthorizationRelationship>} modifyDataTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyDataTypeAuthorizationRelationship: Array<ModifyDataTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).modifyDataTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyDataTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityAuthorizationRelationship>} modifyEntityAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityAuthorizationRelationship: Array<ModifyEntityAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).modifyEntityAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyEntityTypeAuthorizationRelationship>} modifyEntityTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyEntityTypeAuthorizationRelationship: Array<ModifyEntityTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).modifyEntityTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyEntityTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {PatchEntityParams} patchEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public patchEntity(xAuthenticatedUserActorId: string, patchEntityParams: PatchEntityParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).patchEntity(xAuthenticatedUserActorId, patchEntityParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} accountGroupId The ID of the account group to remove the member from
     * @param {string} accountId The ID of the account to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public removeAccountGroupMember(xAuthenticatedUserActorId: string, accountGroupId: string, accountId: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).removeAccountGroupMember(xAuthenticatedUserActorId, accountGroupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the administrator from
     * @param {string} administrator The administrator to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public removeEntityAdministrator(xAuthenticatedUserActorId: string, entityId: string, administrator: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).removeEntityAdministrator(xAuthenticatedUserActorId, entityId, administrator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} entityId The Entity to remove the editor from
     * @param {string} editor The editor to remove from the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public removeEntityEditor(xAuthenticatedUserActorId: string, entityId: string, editor: string, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).removeEntityEditor(xAuthenticatedUserActorId, entityId, editor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveDataTypeParams} unarchiveDataTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public unarchiveDataType(xAuthenticatedUserActorId: string, unarchiveDataTypeParams: UnarchiveDataTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).unarchiveDataType(xAuthenticatedUserActorId, unarchiveDataTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchiveEntityTypeParams} unarchiveEntityTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public unarchiveEntityType(xAuthenticatedUserActorId: string, unarchiveEntityTypeParams: UnarchiveEntityTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).unarchiveEntityType(xAuthenticatedUserActorId, unarchiveEntityTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeRequest} updateDataTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of data types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updateDataType(xAuthenticatedUserActorId: string, updateDataTypeRequest: UpdateDataTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updateDataType(xAuthenticatedUserActorId, updateDataTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateDataTypeEmbeddingParams} updateDataTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updateDataTypeEmbeddings(xAuthenticatedUserActorId: string, updateDataTypeEmbeddingParams: UpdateDataTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updateDataTypeEmbeddings(xAuthenticatedUserActorId, updateDataTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityEmbeddingsParams} updateEntityEmbeddingsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updateEntityEmbeddings(xAuthenticatedUserActorId: string, updateEntityEmbeddingsParams: UpdateEntityEmbeddingsParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updateEntityEmbeddings(xAuthenticatedUserActorId, updateEntityEmbeddingsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeRequest} updateEntityTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of entity types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updateEntityType(xAuthenticatedUserActorId: string, updateEntityTypeRequest: UpdateEntityTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updateEntityType(xAuthenticatedUserActorId, updateEntityTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdateEntityTypeEmbeddingParams} updateEntityTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updateEntityTypeEmbeddings(xAuthenticatedUserActorId: string, updateEntityTypeEmbeddingParams: UpdateEntityTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updateEntityTypeEmbeddings(xAuthenticatedUserActorId, updateEntityTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of property types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ValidateEntityParams} validateEntityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public validateEntity(xAuthenticatedUserActorId: string, validateEntityParams: ValidateEntityParams, options?: AxiosRequestConfig) {
        return GraphApiFp(this.configuration).validateEntity(xAuthenticatedUserActorId, validateEntityParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertyTypeApi - axios parameter creator
 * @export
 */
export const PropertyTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePropertyType: async (xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('archivePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'archivePropertyTypeParams' is not null or undefined
            assertParamExists('archivePropertyType', 'archivePropertyTypeParams', archivePropertyTypeParams)
            const localVarPath = `/property-types/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(archivePropertyTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPropertyTypePermission: async (xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'propertyTypeId' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'propertyTypeId', propertyTypeId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkPropertyTypePermission', 'permission', permission)
            const localVarPath = `/property-types/{property_type_id}/permissions/{permission}`
                .replace(`{${"property_type_id"}}`, encodeURIComponent(String(propertyTypeId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType: async (xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createPropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'createPropertyTypeRequest' is not null or undefined
            assertParamExists('createPropertyType', 'createPropertyTypeRequest', createPropertyTypeRequest)
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, propertyTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'propertyTypeId' is not null or undefined
            assertParamExists('getPropertyTypeAuthorizationRelationships', 'propertyTypeId', propertyTypeId)
            const localVarPath = `/property-types/{property_type_id}/relationships`
                .replace(`{${"property_type_id"}}`, encodeURIComponent(String(propertyTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeSubgraph: async (xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypeSubgraph', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getPropertyTypeSubgraphParams' is not null or undefined
            assertParamExists('getPropertyTypeSubgraph', 'getPropertyTypeSubgraphParams', getPropertyTypeSubgraphParams)
            const localVarPath = `/property-types/query/subgraph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPropertyTypeSubgraphParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypes: async (xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getPropertyTypes', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'getPropertyTypesParams' is not null or undefined
            assertParamExists('getPropertyTypes', 'getPropertyTypesParams', getPropertyTypesParams)
            const localVarPath = `/property-types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPropertyTypesParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalPropertyType: async (xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('loadExternalPropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'loadExternalPropertyTypeRequest' is not null or undefined
            assertParamExists('loadExternalPropertyType', 'loadExternalPropertyTypeRequest', loadExternalPropertyTypeRequest)
            const localVarPath = `/property-types/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadExternalPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPropertyTypeAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyPropertyTypeAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyPropertyTypeAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyPropertyTypeAuthorizationRelationships', 'modifyPropertyTypeAuthorizationRelationship', modifyPropertyTypeAuthorizationRelationship)
            const localVarPath = `/property-types/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyPropertyTypeAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchivePropertyType: async (xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('unarchivePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'unarchivePropertyTypeParams' is not null or undefined
            assertParamExists('unarchivePropertyType', 'unarchivePropertyTypeParams', unarchivePropertyTypeParams)
            const localVarPath = `/property-types/unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unarchivePropertyTypeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType: async (xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updatePropertyType', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updatePropertyTypeRequest' is not null or undefined
            assertParamExists('updatePropertyType', 'updatePropertyTypeRequest', updatePropertyTypeRequest)
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyTypeEmbeddings: async (xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('updatePropertyTypeEmbeddings', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'updatePropertyTypeEmbeddingParams' is not null or undefined
            assertParamExists('updatePropertyTypeEmbeddings', 'updatePropertyTypeEmbeddingParams', updatePropertyTypeEmbeddingParams)
            const localVarPath = `/property-types/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePropertyTypeEmbeddingParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyTypeApi - functional programming interface
 * @export
 */
export const PropertyTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaybeListOfPropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyTypeRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPropertyTypeSubgraphResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPropertyTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologyTemporalMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyTypeMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertyTypeApi - factory interface
 * @export
 */
export const PropertyTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The property type ID to check if the actor has the permission
         * @param {PropertyTypePermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: any): AxiosPromise<MaybeListOfPropertyTypeMetadata> {
            return localVarFp.createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} propertyTypeId The Property type to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: any): AxiosPromise<Array<PropertyTypeRelationAndSubject>> {
            return localVarFp.getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: any): AxiosPromise<GetPropertyTypeSubgraphResponse> {
            return localVarFp.getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {GetPropertyTypesParams} getPropertyTypesParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: any): AxiosPromise<GetPropertyTypesResponse> {
            return localVarFp.getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: any): AxiosPromise<PropertyTypeMetadata> {
            return localVarFp.loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: any): AxiosPromise<OntologyTemporalMetadata> {
            return localVarFp.unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
         * @param {string} [after] The cursor to start reading from
         * @param {number} [limit] The maximum number of property types to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: any): AxiosPromise<PropertyTypeMetadata> {
            return localVarFp.updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: any): AxiosPromise<void> {
            return localVarFp.updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyTypeApi - interface
 * @export
 * @interface PropertyTypeApi
 */
export interface PropertyTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The property type ID to check if the actor has the permission
     * @param {PropertyTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig): AxiosPromise<MaybeListOfPropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The Property type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig): AxiosPromise<Array<PropertyTypeRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig): AxiosPromise<GetPropertyTypeSubgraphResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypesParams} getPropertyTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig): AxiosPromise<GetPropertyTypesResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig): AxiosPromise<PropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig): AxiosPromise<OntologyTemporalMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of property types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<PropertyTypeMetadata>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApiInterface
     */
    updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * PropertyTypeApi - object-oriented interface
 * @export
 * @class PropertyTypeApi
 * @extends {BaseAPI}
 */
export class PropertyTypeApi extends BaseAPI implements PropertyTypeApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {ArchivePropertyTypeParams} archivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public archivePropertyType(xAuthenticatedUserActorId: string, archivePropertyTypeParams: ArchivePropertyTypeParams, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).archivePropertyType(xAuthenticatedUserActorId, archivePropertyTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The property type ID to check if the actor has the permission
     * @param {PropertyTypePermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public checkPropertyTypePermission(xAuthenticatedUserActorId: string, propertyTypeId: string, permission: PropertyTypePermission, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).checkPropertyTypePermission(xAuthenticatedUserActorId, propertyTypeId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {CreatePropertyTypeRequest} createPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public createPropertyType(xAuthenticatedUserActorId: string, createPropertyTypeRequest: CreatePropertyTypeRequest, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).createPropertyType(xAuthenticatedUserActorId, createPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} propertyTypeId The Property type to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, propertyTypeId: string, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).getPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, propertyTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypeSubgraphParams} getPropertyTypeSubgraphParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public getPropertyTypeSubgraph(xAuthenticatedUserActorId: string, getPropertyTypeSubgraphParams: GetPropertyTypeSubgraphParams, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).getPropertyTypeSubgraph(xAuthenticatedUserActorId, getPropertyTypeSubgraphParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {GetPropertyTypesParams} getPropertyTypesParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public getPropertyTypes(xAuthenticatedUserActorId: string, getPropertyTypesParams: GetPropertyTypesParams, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).getPropertyTypes(xAuthenticatedUserActorId, getPropertyTypesParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {LoadExternalPropertyTypeRequest} loadExternalPropertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public loadExternalPropertyType(xAuthenticatedUserActorId: string, loadExternalPropertyTypeRequest: LoadExternalPropertyTypeRequest, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).loadExternalPropertyType(xAuthenticatedUserActorId, loadExternalPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyPropertyTypeAuthorizationRelationship>} modifyPropertyTypeAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyPropertyTypeAuthorizationRelationship: Array<ModifyPropertyTypeAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).modifyPropertyTypeAuthorizationRelationships(xAuthenticatedUserActorId, modifyPropertyTypeAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UnarchivePropertyTypeParams} unarchivePropertyTypeParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public unarchivePropertyType(xAuthenticatedUserActorId: string, unarchivePropertyTypeParams: UnarchivePropertyTypeParams, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).unarchivePropertyType(xAuthenticatedUserActorId, unarchivePropertyTypeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeRequest} updatePropertyTypeRequest 
     * @param {string} [after] The cursor to start reading from
     * @param {number} [limit] The maximum number of property types to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public updatePropertyType(xAuthenticatedUserActorId: string, updatePropertyTypeRequest: UpdatePropertyTypeRequest, after?: string, limit?: number, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).updatePropertyType(xAuthenticatedUserActorId, updatePropertyTypeRequest, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {UpdatePropertyTypeEmbeddingParams} updatePropertyTypeEmbeddingParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypeApi
     */
    public updatePropertyTypeEmbeddings(xAuthenticatedUserActorId: string, updatePropertyTypeEmbeddingParams: UpdatePropertyTypeEmbeddingParams, options?: AxiosRequestConfig) {
        return PropertyTypeApiFp(this.configuration).updatePropertyTypeEmbeddings(xAuthenticatedUserActorId, updatePropertyTypeEmbeddingParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebApi - axios parameter creator
 * @export
 */
export const WebApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkWebPermission: async (xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('checkWebPermission', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'webId' is not null or undefined
            assertParamExists('checkWebPermission', 'webId', webId)
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('checkWebPermission', 'permission', permission)
            const localVarPath = `/webs/{web_id}/permissions/{permission}`
                .replace(`{${"web_id"}}`, encodeURIComponent(String(webId)))
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb: async (xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('createWeb', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'insertWebIdParams' is not null or undefined
            assertParamExists('createWeb', 'insertWebIdParams', insertWebIdParams)
            const localVarPath = `/webs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertWebIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAuthorizationRelationships: async (xAuthenticatedUserActorId: string, webId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('getWebAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'webId' is not null or undefined
            assertParamExists('getWebAuthorizationRelationships', 'webId', webId)
            const localVarPath = `/webs/{web_id}/relationships`
                .replace(`{${"web_id"}}`, encodeURIComponent(String(webId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebAuthorizationRelationships: async (xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthenticatedUserActorId' is not null or undefined
            assertParamExists('modifyWebAuthorizationRelationships', 'xAuthenticatedUserActorId', xAuthenticatedUserActorId)
            // verify required parameter 'modifyWebAuthorizationRelationship' is not null or undefined
            assertParamExists('modifyWebAuthorizationRelationships', 'modifyWebAuthorizationRelationship', modifyWebAuthorizationRelationship)
            const localVarPath = `/webs/relationships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthenticatedUserActorId != null) {
                localVarHeaderParameter['X-Authenticated-User-Actor-Id'] = String(xAuthenticatedUserActorId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyWebAuthorizationRelationship, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebApi - functional programming interface
 * @export
 */
export const WebApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkWebPermission(xAuthenticatedUserActorId, webId, permission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWeb(xAuthenticatedUserActorId, insertWebIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebRelationAndSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebApi - factory interface
 * @export
 */
export const WebApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web ID to check if the actor has the permission
         * @param {WebPermission} permission The permission to check for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: any): AxiosPromise<PermissionResponse> {
            return localVarFp.checkWebPermission(xAuthenticatedUserActorId, webId, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {InsertWebIdParams} insertWebIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: any): AxiosPromise<void> {
            return localVarFp.createWeb(xAuthenticatedUserActorId, insertWebIdParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {string} webId The web to read the relations for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: any): AxiosPromise<Array<WebRelationAndSubject>> {
            return localVarFp.getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
         * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: any): AxiosPromise<void> {
            return localVarFp.modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebApi - interface
 * @export
 * @interface WebApi
 */
export interface WebApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web ID to check if the actor has the permission
     * @param {WebPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApiInterface
     */
    checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig): AxiosPromise<PermissionResponse>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertWebIdParams} insertWebIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApiInterface
     */
    createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApiInterface
     */
    getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig): AxiosPromise<Array<WebRelationAndSubject>>;

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApiInterface
     */
    modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * WebApi - object-oriented interface
 * @export
 * @class WebApi
 * @extends {BaseAPI}
 */
export class WebApi extends BaseAPI implements WebApiInterface {
    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web ID to check if the actor has the permission
     * @param {WebPermission} permission The permission to check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public checkWebPermission(xAuthenticatedUserActorId: string, webId: string, permission: WebPermission, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).checkWebPermission(xAuthenticatedUserActorId, webId, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {InsertWebIdParams} insertWebIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public createWeb(xAuthenticatedUserActorId: string, insertWebIdParams: InsertWebIdParams, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).createWeb(xAuthenticatedUserActorId, insertWebIdParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {string} webId The web to read the relations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public getWebAuthorizationRelationships(xAuthenticatedUserActorId: string, webId: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).getWebAuthorizationRelationships(xAuthenticatedUserActorId, webId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xAuthenticatedUserActorId The ID of the actor which is used to authorize the request
     * @param {Array<ModifyWebAuthorizationRelationship>} modifyWebAuthorizationRelationship 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public modifyWebAuthorizationRelationships(xAuthenticatedUserActorId: string, modifyWebAuthorizationRelationship: Array<ModifyWebAuthorizationRelationship>, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).modifyWebAuthorizationRelationships(xAuthenticatedUserActorId, modifyWebAuthorizationRelationship, options).then((request) => request(this.axios, this.basePath));
    }
}


