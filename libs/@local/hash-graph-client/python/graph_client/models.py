# generated by datamodel-codegen:
#   filename:  openapi.bundle.json
#   version:   0.21.3

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Literal
from uuid import UUID

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel


class AccountId(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: UUID


class BaseUrl(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: str


class DataTypeQueryToken(Enum):
    """
    A single token in a [`DataTypeQueryPath`].
    """

    base_url = "baseUrl"
    version = "version"
    versioned_url = "versionedUrl"
    owned_by_id = "ownedById"
    record_created_by_id = "recordCreatedById"
    title = "title"
    description = "description"
    type = "type"


class DecisionTime(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Literal["decisionTime"] = Field(
        ...,
        description="Time axis for the decision time.\n\nThis is used as the generic argument to time-related structs and can be used as tag value.",
    )


class EdgeResolveDepths(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    incoming: int = Field(..., ge=0)
    outgoing: int = Field(..., ge=0)


class EntityEditionId(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: UUID


class EntityId(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: str


class EntityProperties(BaseModel):
    pass
    model_config = ConfigDict(
        populate_by_name=True,
    )


class EntityQueryToken(Enum):
    """
    A single token in an [`EntityQueryPath`].
    """

    uuid = "uuid"
    edition_id = "editionId"
    archived = "archived"
    owned_by_id = "ownedById"
    record_created_by_id = "recordCreatedById"
    type = "type"
    properties = "properties"
    incoming_links = "incomingLinks"
    outgoing_links = "outgoingLinks"
    left_entity = "leftEntity"
    right_entity = "rightEntity"
    left_to_right_order = "leftToRightOrder"
    right_to_left_order = "rightToLeftOrder"


class EntityRecordId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    edition_id: EntityEditionId = Field(..., alias="editionId")
    entity_id: EntityId = Field(..., alias="entityId")


class EntityTypeQueryToken(Enum):
    """
    A single token in a [`EntityTypeQueryPath`].
    """

    base_url = "baseUrl"
    version = "version"
    versioned_url = "versionedUrl"
    owned_by_id = "ownedById"
    record_created_by_id = "recordCreatedById"
    title = "title"
    description = "description"
    examples = "examples"
    properties = "properties"
    required = "required"
    label_property = "labelProperty"
    links = "links"
    inherits_from = "inheritsFrom"


class EntityUuid(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: UUID


class FilterExpressionItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    parameter: Any


class KnowledgeGraphEdgeKind(Enum):
    has_left_entity = "HAS_LEFT_ENTITY"
    has_right_entity = "HAS_RIGHT_ENTITY"


class LinkOrder(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: int


class NullableTimestamp(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: datetime | None = None


class OntologyEdgeKind(Enum):
    inherits_from = "INHERITS_FROM"
    constrains_values_on = "CONSTRAINS_VALUES_ON"
    constrains_properties_on = "CONSTRAINS_PROPERTIES_ON"
    constrains_links_on = "CONSTRAINS_LINKS_ON"
    constrains_link_destinations_on = "CONSTRAINS_LINK_DESTINATIONS_ON"


class OntologyTypeRecordId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_url: str = Field(..., alias="baseUrl")
    version: int = Field(..., ge=0)


class OntologyTypeVersion(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: int = Field(..., ge=0)


class OpenTemporalBoundItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["unbounded"]


class OutgoingEdgeResolveDepth(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    outgoing: int = Field(..., ge=0)


class OwnedById(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: UUID


class PropertyTypeQueryToken(Enum):
    """
    A single token in a [`DataTypeQueryPath`].
    """

    base_url = "baseUrl"
    version = "version"
    versioned_url = "versionedUrl"
    owned_by_id = "ownedById"
    record_created_by_id = "recordCreatedById"
    title = "title"
    description = "description"
    data_types = "dataTypes"
    property_types = "propertyTypes"


class PropertyTypeVertexId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_id: BaseUrl = Field(..., alias="baseId")
    revision_id: OntologyTypeVersion = Field(..., alias="revisionId")


class Pinned1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: DecisionTime
    timestamp: datetime


class Pinned3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: DecisionTime
    timestamp: NullableTimestamp


class RecordCreatedById(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: UUID


class Selector(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Literal["*"]


class SharedEdgeKind(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Literal["IS_OF_TYPE"]


class TemporalBoundItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["unbounded"]


class Timestamp(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: datetime


class TransactionTime(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Literal["transactionTime"] = Field(
        ...,
        description="Time axis for the transaction time.\n\nThis is used as the generic argument to time-related structs and can be used as tag value.",
    )


class Schema4(BaseModel):
    """
    The contents of a Data Type update request
    """

    model_config = ConfigDict(
        extra="allow",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/data-type"
    ] = Field(..., alias="$schema")
    kind: Literal["dataType"]
    title: str
    description: str | None = None
    type: str


class UpdateDataTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    schema_: Schema4 = Field(
        ..., alias="schema", description="The contents of a Data Type update request"
    )
    type_to_update: str = Field(..., alias="typeToUpdate")


class VersionedUrl(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: AnyUrl = Field(
        ...,
        description="The versioned URL of a Block Protocol ontology type (the $id of the schema). It should be of the form `${baseUrl}v/${versionNumber}`",
        max_length=2048,
        title="Versioned URL",
    )


class BaseUrlModel(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: AnyUrl = Field(
        ...,
        description="The base URL of a Block Protocol ontology type (the $id of the schema, without the versioned suffix). It should a valid URL, with a trailing slash.",
        max_length=2048,
        title="Base URL",
    )


class LinkTypeObject(BaseModel):
    pass
    model_config = ConfigDict(
        populate_by_name=True,
    )


class PropertyTypeObject(BaseModel):
    """
    A JSON object where each entry is constrained by a property type.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )


class DataTypeReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: VersionedUrl = Field(..., alias="$ref")


class EntityTypeReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: AnyUrl = Field(..., alias="$ref")


class PropertyTypeReference(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: AnyUrl = Field(..., alias="$ref")


class DataTypeReferenceUpdate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: AnyUrl = Field(..., alias="$ref")


class PropertyTypeReferenceUpdate(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: AnyUrl = Field(..., alias="$ref")


class ClosedTemporalBoundItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["inclusive"]
    limit: Timestamp


class ClosedTemporalBound(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: ClosedTemporalBoundItem = Field(..., discriminator="kind")


class DataTypeVertexId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_id: BaseUrl = Field(..., alias="baseId")
    revision_id: OntologyTypeVersion = Field(..., alias="revisionId")


class Schema1(BaseModel):
    """
    Specifies the structure of a Data Type
    """

    model_config = ConfigDict(
        extra="allow",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/data-type"
    ] = Field(..., alias="$schema")
    kind: Literal["dataType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    title: str
    description: str | None = None
    type: str


class EntityLinkOrder(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    left_to_right_order: LinkOrder | None = Field(None, alias="leftToRightOrder")
    right_to_left_order: LinkOrder | None = Field(None, alias="rightToLeftOrder")


class EntityTypeVertexId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_id: BaseUrl = Field(..., alias="baseId")
    revision_id: OntologyTypeVersion = Field(..., alias="revisionId")


class EntityVertexId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_id: EntityId = Field(..., alias="baseId")
    revision_id: Timestamp = Field(..., alias="revisionId")


class FilterExpressionItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    path: list[
        DataTypeQueryToken
        | PropertyTypeQueryToken
        | EntityTypeQueryToken
        | EntityQueryToken
        | Selector
        | str
        | float
    ]


class FilterExpression(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: FilterExpressionItem | FilterExpressionItem1


class GraphElementVertexId(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: DataTypeVertexId | PropertyTypeVertexId | EntityTypeVertexId | EntityVertexId


class GraphResolveDepths(BaseModel):
    """
    TODO: DOC - <https://app.asana.com/0/0/1203438518991188/f>
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    constrains_link_destinations_on: OutgoingEdgeResolveDepth = Field(
        ..., alias="constrainsLinkDestinationsOn"
    )
    constrains_links_on: OutgoingEdgeResolveDepth = Field(
        ..., alias="constrainsLinksOn"
    )
    constrains_properties_on: OutgoingEdgeResolveDepth = Field(
        ..., alias="constrainsPropertiesOn"
    )
    constrains_values_on: OutgoingEdgeResolveDepth = Field(
        ..., alias="constrainsValuesOn"
    )
    has_left_entity: EdgeResolveDepths = Field(..., alias="hasLeftEntity")
    has_right_entity: EdgeResolveDepths = Field(..., alias="hasRightEntity")
    inherits_from: OutgoingEdgeResolveDepth = Field(..., alias="inheritsFrom")
    is_of_type: OutgoingEdgeResolveDepth = Field(..., alias="isOfType")


class LimitedTemporalBoundItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["inclusive"]
    limit: Timestamp


class LimitedTemporalBoundItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["exclusive"]
    limit: Timestamp


class LimitedTemporalBound(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: LimitedTemporalBoundItem | LimitedTemporalBoundItem1 = Field(
        ..., discriminator="kind"
    )


class LinkData(EntityLinkOrder):
    """
    The associated information for 'Link' entities
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    left_entity_id: EntityId = Field(..., alias="leftEntityId")
    right_entity_id: EntityId = Field(..., alias="rightEntityId")


class LoadExternalDataTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    data_type_id: str = Field(..., alias="dataTypeId")


class LoadExternalEntityTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    entity_type_id: str = Field(..., alias="entityTypeId")


class LoadExternalPropertyTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    property_type_id: str = Field(..., alias="propertyTypeId")


class OntologyTypeVertexId(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: DataTypeVertexId | PropertyTypeVertexId | EntityTypeVertexId


class OpenTemporalBoundItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["exclusive"]
    limit: Timestamp


class OpenTemporalBound(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: OpenTemporalBoundItem | OpenTemporalBoundItem1 = Field(
        ..., discriminator="kind"
    )


class ProvenanceMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    record_created_by_id: RecordCreatedById = Field(..., alias="recordCreatedById")


class Pinned(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: TransactionTime
    timestamp: datetime


class Pinned2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: TransactionTime
    timestamp: NullableTimestamp


class TemporalBoundItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["inclusive"]
    limit: Timestamp


class TemporalBoundItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: Literal["exclusive"]
    limit: Timestamp


class TemporalBound(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: TemporalBoundItem | TemporalBoundItem1 | TemporalBoundItem2 = Field(
        ..., discriminator="kind"
    )


class UnresolvedRightBoundedTemporalInterval(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    end: LimitedTemporalBound | None = Field(...)
    start: TemporalBound | None = Field(...)


class UpdateEntityRequest(EntityLinkOrder):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    archived: bool
    entity_id: EntityId = Field(..., alias="entityId")
    entity_type_id: str = Field(..., alias="entityTypeId")
    properties: EntityProperties


class Schema(BaseModel):
    """
    Specifies the structure of a Data Type
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/data-type"
    ] = Field(..., alias="$schema")
    kind: Literal["dataType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    title: str
    description: str | None = None
    type: str


class EntityTypeReferenceModel(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_ref: VersionedUrl = Field(..., alias="$ref")


class PropertyValue(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["object"]
    properties: PropertyTypeObject


class OneOfItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["array"]
    items: EntityTypeReference | None = None
    ordered: bool
    min_items: int | None = Field(None, alias="minItems", ge=0)
    max_items: int | None = Field(None, alias="maxItems", ge=0)


class LinkTypeObject1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    one_of: list[EntityTypeReference | OneOfItem] | None = Field(
        None, alias="oneOf", min_length=1
    )


class LinkTypeObjectModel(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, LinkTypeObject1]


class PropertyTypeObjectItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["array"]
    items: PropertyTypeReference
    min_items: int | None = Field(None, alias="minItems", ge=0)
    max_items: int | None = Field(None, alias="maxItems", ge=0)


class PropertyTypeObjectModel(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, PropertyTypeReference | PropertyTypeObjectItem]


class PropertyTypeObjectItem1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["array"]
    items: PropertyTypeReferenceUpdate
    min_items: int | None = Field(None, alias="minItems", ge=0)
    max_items: int | None = Field(None, alias="maxItems", ge=0)


class PropertyTypeObjectModel1(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, PropertyTypeReferenceUpdate | PropertyTypeObjectItem1] = Field(
        ..., title="PropertyTypeObject"
    )


class CreateDataTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    schema_: Schema | list[Schema] = Field(..., alias="schema")


class CreateEntityRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    entity_type_id: str = Field(..., alias="entityTypeId")
    entity_uuid: EntityUuid | None = Field(None, alias="entityUuid")
    link_data: LinkData | None = Field(None, alias="linkData")
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    properties: EntityProperties


class Schema2(BaseModel):
    """
    Specifies the structure of a Block Protocol entity type
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type"
    ] = Field(..., alias="$schema")
    kind: Literal["entityType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    type: Literal["object"]
    title: str
    description: str | None = None
    all_of: list[EntityTypeReferenceModel] | None = Field(None, alias="allOf")
    examples: list[dict[str, Any]] | None = None
    properties: PropertyTypeObject
    required: list[BaseUrlModel] | None = None
    links: LinkTypeObject | None = None


class FilterItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    equal: list[FilterExpression] = Field(..., max_length=2, min_length=2)


class FilterItem4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    not_equal: list[FilterExpression] = Field(
        ..., alias="notEqual", max_length=2, min_length=2
    )


class FilterItem5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    starts_with: list[FilterExpression] = Field(
        ..., alias="startsWith", max_length=2, min_length=2
    )


class FilterItem6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    ends_with: list[FilterExpression] = Field(
        ..., alias="endsWith", max_length=2, min_length=2
    )


class FilterItem7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    contains_segment: list[FilterExpression] = Field(
        ..., alias="containsSegment", max_length=2, min_length=2
    )


class KnowledgeGraphOutwardEdgeItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: SharedEdgeKind
    reversed: bool
    right_endpoint: OntologyTypeVertexId = Field(..., alias="rightEndpoint")


class LeftClosedTemporalInterval(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    end: OpenTemporalBound
    start: ClosedTemporalBound


class OntologyOutwardEdgeItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: OntologyEdgeKind
    reversed: bool
    right_endpoint: OntologyTypeVertexId = Field(..., alias="rightEndpoint")


class OntologyTemporalMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    transaction_time: LeftClosedTemporalInterval = Field(..., alias="transactionTime")


class Variable2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: DecisionTime
    interval: UnresolvedRightBoundedTemporalInterval


class QueryTemporalAxesUnresolvedItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pinned: Pinned2
    variable: Variable2


class Variable3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: TransactionTime
    interval: UnresolvedRightBoundedTemporalInterval


class QueryTemporalAxesUnresolvedItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pinned: Pinned3
    variable: Variable3


class QueryTemporalAxesUnresolved(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: QueryTemporalAxesUnresolvedItem | QueryTemporalAxesUnresolvedItem1 = Field(
        ...,
        description="Defines the two possible combinations of pinned/variable temporal axes that are used in queries\nthat return [`Subgraph`]s.\n\nThe [`VariableTemporalAxisUnresolved`] is optionally bounded, in the absence of provided\nbounds an inclusive bound at the timestamp at point of resolving is assumed.\n\n[`Subgraph`]: crate::subgraph::Subgraph",
    )


class RightBoundedTemporalInterval(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    end: LimitedTemporalBound
    start: TemporalBound


class Schema5(BaseModel):
    """
    The contents of an Entity Type update request
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type"
    ] = Field(..., alias="$schema")
    kind: Literal["entityType"]
    type: Literal["object"]
    title: str
    description: str | None = None
    examples: list[dict[str, Any]] | None = None
    properties: PropertyTypeObjectModel
    required: list[AnyUrl] | None = None
    links: LinkTypeObjectModel | None = None


class UpdateEntityTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    label_property: BaseUrl | None = Field(None, alias="labelProperty")
    schema_: Schema5 = Field(
        ..., alias="schema", description="The contents of an Entity Type update request"
    )
    type_to_update: str = Field(..., alias="typeToUpdate")


class SchemaModel(BaseModel):
    """
    Specifies the structure of a Block Protocol entity type
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/entity-type"
    ] = Field(..., alias="$schema")
    kind: Literal["entityType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    type: Literal["object"]
    title: str
    description: str | None = None
    all_of: list[EntityTypeReferenceModel] | None = Field(None, alias="allOf")
    examples: list[dict[str, Any]] | None = None
    properties: PropertyTypeObject
    required: list[BaseUrlModel] | None = None
    links: LinkTypeObject | None = None


class PropertyValuesUpdateItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["object"]
    properties: PropertyTypeObjectModel1


class CreateEntityTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    label_property: BaseUrl | None = Field(None, alias="labelProperty")
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    schema_: SchemaModel | list[SchemaModel] = Field(..., alias="schema")


class CustomEntityTypeMetadatum(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    label_property: BaseUrl | None = Field(None, alias="labelProperty")
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    provenance: ProvenanceMetadata
    temporal_versioning: OntologyTemporalMetadata = Field(
        ..., alias="temporalVersioning"
    )


class CustomEntityTypeMetadatum1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    fetched_at: str = Field(..., alias="fetchedAt")
    label_property: BaseUrl | None = Field(None, alias="labelProperty")
    provenance: ProvenanceMetadata
    temporal_versioning: OntologyTemporalMetadata = Field(
        ..., alias="temporalVersioning"
    )


class CustomEntityTypeMetadata(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: CustomEntityTypeMetadatum | CustomEntityTypeMetadatum1


class CustomOntologyMetadatum(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    provenance: ProvenanceMetadata
    temporal_versioning: OntologyTemporalMetadata = Field(
        ..., alias="temporalVersioning"
    )


class CustomOntologyMetadatum1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    fetched_at: str = Field(..., alias="fetchedAt")
    provenance: ProvenanceMetadata
    temporal_versioning: OntologyTemporalMetadata = Field(
        ..., alias="temporalVersioning"
    )


class CustomOntologyMetadata(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: CustomOntologyMetadatum | CustomOntologyMetadatum1


class EntityIdWithInterval(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    entity_id: EntityId = Field(..., alias="entityId")
    interval: LeftClosedTemporalInterval


class EntityTemporalMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    decision_time: LeftClosedTemporalInterval = Field(..., alias="decisionTime")
    transaction_time: LeftClosedTemporalInterval = Field(..., alias="transactionTime")


class EntityTypeMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    custom: CustomEntityTypeMetadata
    record_id: OntologyTypeRecordId = Field(..., alias="recordId")


class EntityTypeWithMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    metadata: EntityTypeMetadata
    schema_: Schema2 = Field(
        ...,
        alias="schema",
        description="Specifies the structure of a Block Protocol entity type",
        title="Entity Type",
    )


class KnowledgeGraphOutwardEdgeItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: KnowledgeGraphEdgeKind
    reversed: bool
    right_endpoint: EntityIdWithInterval = Field(..., alias="rightEndpoint")


class KnowledgeGraphOutwardEdge(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: KnowledgeGraphOutwardEdgeItem | KnowledgeGraphOutwardEdgeItem1


class MaybeListOfEntityTypeMetadata(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: EntityTypeMetadata | list[EntityTypeMetadata]


class OntologyElementMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    custom: CustomOntologyMetadata
    record_id: OntologyTypeRecordId = Field(..., alias="recordId")


class OntologyOutwardEdgeItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    kind: SharedEdgeKind
    reversed: bool
    right_endpoint: EntityIdWithInterval = Field(..., alias="rightEndpoint")


class OntologyOutwardEdge(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: OntologyOutwardEdgeItem | OntologyOutwardEdgeItem1


class OntologyVertexItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inner: EntityTypeWithMetadata
    kind: Literal["entityType"]


class Variable(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: DecisionTime
    interval: RightBoundedTemporalInterval


class QueryTemporalAx(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pinned: Pinned
    variable: Variable


class Variable1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    axis: TransactionTime
    interval: RightBoundedTemporalInterval


class QueryTemporalAx1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pinned: Pinned1
    variable: Variable1


class QueryTemporalAxes(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: QueryTemporalAx | QueryTemporalAx1 = Field(
        ...,
        description="Defines the two possible combinations of pinned/variable temporal axes that are used in\nresponses to queries that return [`Subgraph`]s.\n\nWhen querying the Graph, temporal data is returned. The Graph is implemented as a bitemporal\ndata store, which means the knowledge data contains information about the time of when the\nknowledge was inserted into the Graph, the [`TransactionTime`], and when the knowledge was\ndecided to be inserted, the [`DecisionTime`].\n\nIn order to query data from the Graph, only one of the two time axes can be used. This is\nachieved by using a `TemporalAxes`. The `TemporalAxes` pins one axis to a specified\n[`Timestamp`], while the other axis can be a [`Interval`]. The pinned axis is called the\n[`PinnedTemporalAxis`] and the other axis is called the [`VariableTemporalAxis`]. The returned\ndata will then only contain temporal data that is contained in the [`Interval`] of the\n[`VariableTemporalAxis`] for the given [`Timestamp`] of the [`PinnedTemporalAxis`].\n\n[`Subgraph`]: crate::subgraph::Subgraph\n[`Interval`]: crate::interval::Interval",
    )


class SubgraphTemporalAxes(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    initial: QueryTemporalAxesUnresolved
    resolved: QueryTemporalAxes


class DataTypeWithMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    metadata: OntologyElementMetadata
    schema_: Schema1 = Field(
        ...,
        alias="schema",
        description="Specifies the structure of a Data Type",
        title="Data Type",
    )


class Edges(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[
        str, dict[str, list[OntologyOutwardEdge | KnowledgeGraphOutwardEdge]]
    ] | None = None


class EntityMetadata(BaseModel):
    """
    The metadata of an [`Entity`] record.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    archived: bool
    entity_type_id: str = Field(..., alias="entityTypeId")
    provenance: ProvenanceMetadata
    record_id: EntityRecordId = Field(..., alias="recordId")
    temporal_versioning: EntityTemporalMetadata = Field(..., alias="temporalVersioning")


class MaybeListOfOntologyElementMetadata(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: OntologyElementMetadata | list[OntologyElementMetadata]


class OntologyVertexItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inner: DataTypeWithMetadata
    kind: Literal["dataType"]


class Entity(BaseModel):
    """
    A record of an [`Entity`] that has been persisted in the datastore, with its associated
    metadata.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    link_data: LinkData | None = Field(None, alias="linkData")
    metadata: EntityMetadata
    properties: EntityProperties


class KnowledgeGraphVertexItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inner: Entity
    kind: Literal["entity"]


class KnowledgeGraphVertex(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: KnowledgeGraphVertexItem = Field(..., discriminator="kind")


class KnowledgeGraphVertices(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, dict[str, KnowledgeGraphVertex]] | None = None


class CreatePropertyTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    owned_by_id: OwnedById = Field(..., alias="ownedById")
    schema_: SchemaModel1 | list[SchemaModel1] = Field(..., alias="schema")


class DataTypeStructuralQuery(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Filter
    graph_resolve_depths: GraphResolveDepths = Field(..., alias="graphResolveDepths")
    temporal_axes: QueryTemporalAxesUnresolved = Field(..., alias="temporalAxes")


class EntityStructuralQuery(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Filter
    graph_resolve_depths: GraphResolveDepths = Field(..., alias="graphResolveDepths")
    temporal_axes: QueryTemporalAxesUnresolved = Field(..., alias="temporalAxes")


class EntityTypeStructuralQuery(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Filter
    graph_resolve_depths: GraphResolveDepths = Field(..., alias="graphResolveDepths")
    temporal_axes: QueryTemporalAxesUnresolved = Field(..., alias="temporalAxes")


class FilterItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    all: list[Filter]


class FilterItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    any: list[Filter]


class FilterItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    not_: Filter = Field(..., alias="not")


class Filter(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: FilterItem | FilterItem1 | FilterItem2 | FilterItem3 | FilterItem4 | FilterItem5 | FilterItem6 | FilterItem7


class OntologyVertexItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inner: PropertyTypeWithMetadata
    kind: Literal["propertyType"]


class OntologyVertex(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: OntologyVertexItem | OntologyVertexItem1 | OntologyVertexItem2 = Field(
        ..., discriminator="kind"
    )


class OntologyVertices(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, dict[str, OntologyVertex]] | None = None


class PropertyTypeStructuralQuery(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Filter
    graph_resolve_depths: GraphResolveDepths = Field(..., alias="graphResolveDepths")
    temporal_axes: QueryTemporalAxesUnresolved = Field(..., alias="temporalAxes")


class Schema3(BaseModel):
    """
    Specifies the structure of a Block Protocol property type
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/property-type"
    ] = Field(..., alias="$schema")
    kind: Literal["propertyType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    title: str
    description: str | None = None
    one_of: list[PropertyValues] = Field(..., alias="oneOf")


class PropertyTypeWithMetadata(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    metadata: OntologyElementMetadata
    schema_: Schema3 = Field(
        ...,
        alias="schema",
        description="Specifies the structure of a Block Protocol property type",
        title="Property Type",
    )


class Subgraph(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    depths: GraphResolveDepths
    edges: Edges
    roots: list[GraphElementVertexId]
    temporal_axes: SubgraphTemporalAxes = Field(..., alias="temporalAxes")
    vertices: Vertices


class Schema6(BaseModel):
    """
    The contents of a Property Type update request
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/property-type"
    ] = Field(..., alias="$schema")
    kind: Literal["propertyType"]
    title: str
    description: str | None = None
    one_of: list[PropertyValuesUpdate] = Field(..., alias="oneOf")


class UpdatePropertyTypeRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    actor_id: RecordCreatedById = Field(..., alias="actorId")
    schema_: Schema6 = Field(
        ...,
        alias="schema",
        description="The contents of a Property Type update request",
    )
    type_to_update: str = Field(..., alias="typeToUpdate")


class Vertex(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: OntologyVertex | KnowledgeGraphVertex


class Vertices(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: dict[str, dict[str, KnowledgeGraphVertex | OntologyVertex]] | None = None


class SchemaModel1(BaseModel):
    """
    Specifies the structure of a Block Protocol property type
    """

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    field_schema: Literal[
        "https://blockprotocol.org/types/modules/graph/0.3/schema/property-type"
    ] = Field(..., alias="$schema")
    kind: Literal["propertyType"]
    field_id: VersionedUrl = Field(..., alias="$id")
    title: str
    description: str | None = None
    one_of: list[PropertyValues] = Field(..., alias="oneOf")


class Items(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    one_of: list[PropertyValues] = Field(..., alias="oneOf", min_length=1)


class PropertyValue1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["array"]
    items: Items
    min_items: int | None = Field(None, alias="minItems", ge=0)
    max_items: int | None = Field(None, alias="maxItems", ge=0)


class PropertyValues(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: DataTypeReference | PropertyValue | PropertyValue1 = Field(
        ...,
        description="The definition of potential property values, either references to data types, objects made up of more property types, or an array where the items are defined from a set of other property values definitions.",
        title="propertyValues",
    )


class Items1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    one_of: list[PropertyValuesUpdate] = Field(..., alias="oneOf", min_length=1)


class PropertyValuesUpdateItem1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    type: Literal["array"]
    items: Items1
    min_items: int | None = Field(None, alias="minItems", ge=0)
    max_items: int | None = Field(None, alias="maxItems", ge=0)


class PropertyValuesUpdate(RootModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: DataTypeReferenceUpdate | PropertyValuesUpdateItem | PropertyValuesUpdateItem1 = Field(
        ..., title="PropertyValuesUpdate"
    )


CreatePropertyTypeRequest.model_rebuild()
DataTypeStructuralQuery.model_rebuild()
EntityStructuralQuery.model_rebuild()
EntityTypeStructuralQuery.model_rebuild()
FilterItem.model_rebuild()
FilterItem1.model_rebuild()
FilterItem2.model_rebuild()
OntologyVertexItem1.model_rebuild()
Schema3.model_rebuild()
Subgraph.model_rebuild()
Schema6.model_rebuild()
SchemaModel1.model_rebuild()
Items.model_rebuild()
Items1.model_rebuild()
