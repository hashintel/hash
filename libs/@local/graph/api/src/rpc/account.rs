use alloc::{borrow::Cow, sync::Arc};
use core::{
    error::{self, Error},
    marker::PhantomData,
};

use error_stack::{Report, ResultExt as _};
use harpc_client::{connection::Connection, utils::invoke_call_discrete};
use harpc_codec::{decode::ReportDecoder, encode::Encoder};
use harpc_server::{
    error::{DelegationError, Forbidden},
    session::Session,
    utils::{delegate_call_discrete, parse_procedure_id},
};
use harpc_system::delegate::SubsystemDelegate;
use harpc_tower::{body::Body, either::Either, request::Request, response::Response};
use harpc_types::{error_code::ErrorCode, response_kind::ResponseKind};
use hash_graph_authorization::policies::store::{
    PrincipalStore, RoleAssignmentStatus, RoleUnassignmentStatus,
};
use hash_graph_store::pool::StorePool;
use hash_temporal_client::TemporalClient;
use type_system::principal::{
    actor::ActorEntityUuid, actor_group::ActorGroupEntityUuid, role::RoleName,
};

use super::session::Account;

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct PermissionResponse {
    pub has_permission: bool,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, derive_more::Display)]
#[display("account {id} does not exist in the graph")]
pub struct AccountNotFoundError {
    id: ActorEntityUuid,
}

impl Error for AccountNotFoundError {
    fn provide<'a>(&'a self, request: &mut error::Request<'a>) {
        request.provide_value(ErrorCode::RESOURCE_NOT_FOUND);
    }
}

#[must_use]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, derive_more::Display, derive_more::Error)]
#[display("unable to fullfil account request")]
pub struct AccountError;

pub trait AccountSystem {
    type ExecutionScope;

    async fn assign_actor_group_role(
        &self,
        scope: Self::ExecutionScope,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleAssignmentStatus, Report<AccountError>>;

    async fn unassign_actor_group_role(
        &self,
        scope: Self::ExecutionScope,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleUnassignmentStatus, Report<AccountError>>;
}

// TODO: this can be auto generated by the `harpc` crate
pub mod meta {
    //! The `meta` module contains the metadata for the account service.
    //! In the future this will be automatically generated by the `harpc` crate.

    use frunk::HList;
    use harpc_system::{
        Subsystem,
        procedure::{Procedure, ProcedureIdentifier},
    };
    use harpc_types::{procedure::ProcedureId, version::Version};

    use crate::rpc::GraphSubsystemId;

    pub enum AccountProcedureId {
        AssignActorGroupRole,
        UnassignActorGroupRole,
    }

    impl ProcedureIdentifier for AccountProcedureId {
        type Subsystem = AccountSystem;

        fn from_id(id: ProcedureId) -> Option<Self> {
            match id.value() {
                0x00 => Some(Self::AssignActorGroupRole),
                0x01 => Some(Self::UnassignActorGroupRole),
                _ => None,
            }
        }

        fn into_id(self) -> ProcedureId {
            match self {
                Self::AssignActorGroupRole => ProcedureId::new(0x00),
                Self::UnassignActorGroupRole => ProcedureId::new(0x01),
            }
        }
    }

    pub struct AccountSystem;

    impl Subsystem for AccountSystem {
        type ProcedureId = AccountProcedureId;
        type Procedures = HList![
            ProcedureAddAccountGroupMember,
            ProcedureRemoveAccountGroupMember
        ];
        type SubsystemId = GraphSubsystemId;

        const ID: GraphSubsystemId = GraphSubsystemId::Account;
        const VERSION: Version = Version {
            major: 0x00,
            minor: 0x00,
        };
    }

    pub struct ProcedureAddAccountGroupMember;

    impl Procedure for ProcedureAddAccountGroupMember {
        type Subsystem = AccountSystem;

        const ID: <Self::Subsystem as Subsystem>::ProcedureId =
            AccountProcedureId::AssignActorGroupRole;
    }

    pub struct ProcedureRemoveAccountGroupMember;

    impl Procedure for ProcedureRemoveAccountGroupMember {
        type Subsystem = AccountSystem;

        const ID: <Self::Subsystem as Subsystem>::ProcedureId =
            AccountProcedureId::UnassignActorGroupRole;
    }
}

#[derive(Debug)]
#[derive_where::derive_where(Clone)]
pub struct AccountServer<S> {
    pub temporal_client: Option<Arc<TemporalClient>>,
    pub store_pool: Arc<S>,
}

impl<S> AccountServer<S>
where
    S: StorePool + Send + Sync,
{
    async fn store(&self) -> Result<S::Store<'_>, Report<AccountError>> {
        self.store_pool
            .acquire(self.temporal_client.clone())
            .await
            .inspect_err(|report| {
                tracing::error!(error=?report, "Could not acquire store");
            })
            .change_context(AccountError)
    }

    fn actor(session: &Session<Account>) -> Result<ActorEntityUuid, Report<AccountError>> {
        let &Account {
            actor_id: Some(actor_id),
        } = session.get()
        else {
            let request_info = session.request_info();

            return Err(Report::new(Forbidden {
                subsystem: request_info.subsystem,
                procedure: request_info.procedure,
                reason: Cow::Borrowed("user authentication required"),
            })
            .change_context(AccountError));
        };

        Ok(actor_id)
    }
}

impl<S> AccountSystem for AccountServer<S>
where
    S: StorePool + Send + Sync,
    for<'p> S::Store<'p>: PrincipalStore,
{
    type ExecutionScope = Session<Account>;

    async fn assign_actor_group_role(
        &self,
        scope: Session<Account>,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleAssignmentStatus, Report<AccountError>> {
        self.store()
            .await?
            .assign_role(Self::actor(&scope)?, account_id, actor_group_id, role_name)
            .await
            .inspect_err(|error| {
                tracing::error!(?error, "Could not assign role to account group");
            })
            .change_context(AccountError)
    }

    async fn unassign_actor_group_role(
        &self,
        scope: Session<Account>,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleUnassignmentStatus, Report<AccountError>> {
        self.store()
            .await?
            .unassign_role(Self::actor(&scope)?, account_id, actor_group_id, role_name)
            .await
            .inspect_err(|error| {
                tracing::error!(?error, "Could not unassign role from account group");
            })
            .change_context(AccountError)
    }
}

// TODO: this can be auto generated by the `harpc` crate
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccountDelegate<T> {
    inner: T,
}

impl<T> AccountDelegate<T> {
    #[must_use]
    pub const fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T, C> SubsystemDelegate<C> for AccountDelegate<T>
where
    T: AccountSystem<
            assign_actor_group_role(..): Send,
            unassign_actor_group_role(..): Send,
            ExecutionScope: Send,
        > + Send,
    C: Encoder + ReportDecoder + Clone + Send,
{
    type Error = Report<DelegationError>;
    type ExecutionScope = T::ExecutionScope;
    type Subsystem = meta::AccountSystem;

    type Body<Source>
        = impl Body<Control: AsRef<ResponseKind>, Error = <C as Encoder>::Error>
    where
        Source: Body<Control = !, Error: Send + Sync> + Send;

    async fn call<B>(
        self,
        request: Request<B>,
        scope: T::ExecutionScope,
        codec: C,
    ) -> Result<Response<Self::Body<B>>, Self::Error>
    where
        B: Body<Control = !, Error: Send + Sync> + Send,
    {
        let id = parse_procedure_id(&request)?;

        // The Either chain here isn't... great, but the only other way would be to box. To box we'd
        // need to require that the `Decoder<Output>` is both `Send` and `Sync`, which it can be,
        // but to completely write out the trait bound is a bit of a pain.
        // We would instead most likely need to add `+ Sync` to the GAT, which would over-constrain
        // it unnecessarily, but would _in theory_ allow us to remove the `Either` chain.
        match id {
            meta::AccountProcedureId::AssignActorGroupRole => delegate_call_discrete(
                request,
                codec,
                |(account_group_id, role_name, account_id)| async move {
                    self.inner
                        .assign_actor_group_role(scope, account_group_id, role_name, account_id)
                        .await
                },
            )
            .await
            .map(|response| response.map_body(Either::Left)),
            meta::AccountProcedureId::UnassignActorGroupRole => delegate_call_discrete(
                request,
                codec,
                |(account_group_id, role_name, account_id)| async move {
                    self.inner
                        .unassign_actor_group_role(scope, account_group_id, role_name, account_id)
                        .await
                },
            )
            .await
            .map(|response| response.map_body(Either::Right)),
        }
    }
}

// TODO: this can be auto generated by the `harpc` crate
#[derive_where::derive_where(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AccountClient<S, C> {
    _session: PhantomData<fn() -> *const S>,
    _codec: PhantomData<fn() -> *const C>,
}

impl<S, C> AccountClient<S, C> {
    #[must_use]
    pub fn new() -> Self {
        Self {
            _session: PhantomData,
            _codec: PhantomData,
        }
    }
}

impl<S, C> Default for AccountClient<S, C> {
    fn default() -> Self {
        Self::new()
    }
}

impl<S, C> AccountSystem for AccountClient<S, C>
where
    S: harpc_client::connection::ConnectionService<C>,
    C: harpc_client::connection::ConnectionCodec,
{
    type ExecutionScope = Connection<S, C>;

    async fn assign_actor_group_role(
        &self,
        scope: Connection<S, C>,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleAssignmentStatus, Report<AccountError>> {
        invoke_call_discrete(
            scope,
            meta::AccountProcedureId::AssignActorGroupRole,
            [(actor_group_id, role_name, account_id)],
        )
        .await
        .change_context(AccountError)
    }

    async fn unassign_actor_group_role(
        &self,
        scope: Connection<S, C>,
        actor_group_id: ActorGroupEntityUuid,
        role_name: RoleName,
        account_id: ActorEntityUuid,
    ) -> Result<RoleUnassignmentStatus, Report<AccountError>> {
        invoke_call_discrete(
            scope,
            meta::AccountProcedureId::UnassignActorGroupRole,
            [(actor_group_id, role_name, account_id)],
        )
        .await
        .change_context(AccountError)
    }
}
