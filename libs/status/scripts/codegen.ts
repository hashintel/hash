/** @todo - extract this into a shared @local/* package for generating things through quicktype */

import { existsSync, lstatSync, rmSync } from "node:fs";
import { mkdir, readdir, writeFile } from "node:fs/promises";
import * as path from "node:path";
import { argv } from "node:process";

// We don't want/need sync but we can't seem to import the normal async execa function in ESM with
// execa 5.1.1. If we upgrade to 6.x it might work.
import { sync as execaSync } from "execa";
import snakeCase from "lodash/snakeCase";

const removeOldGenDirs = (outDir: string) => {
  const outDirParent = path.dirname(outDir);

  if (!existsSync(outDirParent)) {
    throw new Error(
      `Couldn't find parent of output directory, are you sure you're running in the correct working directory? Input dir was: ${outDir}, resolved parent was: ${outDirParent}`,
    );
  }
  if (!lstatSync(outDirParent).isDirectory()) {
    throw new Error("Expected parent of output directory to be a directory.");
  }

  rmSync(outDir, { recursive: true, force: true });
};

async function* getFiles(dir: string): AsyncGenerator<string> {
  const dirEntries = await readdir(dir, { withFileTypes: true });
  for (const dirEntry of dirEntries) {
    const resolvedChildPath = path.resolve(dir, dirEntry.name);
    if (dirEntry.isDirectory()) {
      yield* getFiles(resolvedChildPath);
    } else {
      yield resolvedChildPath;
    }
  }
}

const RUST_MODULE_TEMPLATE_STRING = `//! This is an autogenerated module declaration file. All sub-modules were produced by \`quicktype\`\n`;

const postProcessRustDir = async (dir: string) => {
  const moduleNames = [];

  for (const childDirEntry of await readdir(dir, { withFileTypes: true })) {
    const childDirEntryPath = path.join(dir, childDirEntry.name);

    if (childDirEntry.isDirectory()) {
      // If it has a Rust file we need to keep traversing
      if (
        (await readdir(childDirEntryPath)).findIndex((nestedChildDirEntry) => {
          return path.extname(nestedChildDirEntry) === ".rs";
        }) !== -1
      ) {
        await postProcessRustDir(childDirEntryPath);
      }
    }
    const moduleName = path.parse(childDirEntryPath).name;
    moduleNames.push(moduleName);
  }

  const moduleContents = moduleNames.reduce((contents, moduleName) => {
    return contents.concat(`pub mod ${moduleName};\n`);
  }, RUST_MODULE_TEMPLATE_STRING);

  // We stick to the outdated format of `mod.rs`
  // (https://doc.rust-lang.org/reference/items/modules.html#module-source-filenames)
  //
  // As otherwise the generated modules are not encapsulated within the generated directory and we would need to create
  // a `gen.rs` or similar module in the _parent_ of the generated directory
  await writeFile(path.join(dir, "mod.rs"), moduleContents);
};

/**
 *  @todo - Consider using `quicktype-core` and orchestrating ourselves from TS instead of calling
 *    the CLI (https://blog.quicktype.io/customizing-quicktype/)
 */
const codegen = async (typeDefsDir: string, rustOutputDir: string) => {
  for await (const filePath of getFiles(typeDefsDir)) {
    const fileParentStructure = path.relative(
      typeDefsDir,
      path.dirname(filePath),
    );
    const fileName = path.parse(filePath).name;
    const fileExtension = path.extname(filePath);

    if (fileExtension === ".ts") {
      const rustParentsPath = path.join(rustOutputDir, fileParentStructure);
      await mkdir(rustParentsPath, { recursive: true });

      const rustOutputPath = path.join(
        rustParentsPath,
        `${snakeCase(fileName)}.rs`,
      );

      execaSync("quicktype", [
        filePath,
        "-o",
        rustOutputPath,
        "--no-combine-classes",
        "--visibility",
        "crate",
        "--derive-debug",
        "--edition-2018",
      ]);
    } else {
      throw new Error(`Unsupported quicktype input format: ${fileExtension}`);
    }
  }

  await postProcessRustDir(rustOutputDir);
};

void (async () => {
  const [entryPointDir, outDir] = argv.slice(2);

  if (!entryPointDir) {
    throw new Error(
      "Expected an entry point directory to be given as the first command-line argument",
    );
  }

  if (!outDir) {
    throw new Error(
      "Expected an output directory to be given as the second command-line argument",
    );
  }

  console.log("Removing old directories for generated files");
  removeOldGenDirs(outDir);

  console.log("Running codegen");
  await codegen(entryPointDir, outDir);
})();
