//! Code generation using `quote!` and `prettyplease`.
#![expect(clippy::indexing_slicing)]

use alloc::{collections::BTreeMap, ffi::CString};
use std::{fs, path::Path};

use convert_case::{Case, Casing as _};
use proc_macro2::TokenStream;
use quote::{ToTokens, format_ident, quote};

use crate::database::{ChipDatabase, EventData, MERGES};

/// A unified event across all chips.
struct UnifiedEvent {
    variant: String,
    /// `chip_label` -> `EventData` reference.
    chips: BTreeMap<String, UnifiedChipEvent>,
}

struct UnifiedChipEvent {
    data: EventData,
}

pub(crate) fn generate(
    out_dir: impl AsRef<Path>,
    chips: &[ChipDatabase],
) -> Result<usize, Box<dyn core::error::Error>> {
    let unified = build_unified_events(chips);

    let lib_tokens = generate_lib(&unified, chips);
    write_formatted(
        out_dir.as_ref().join("lib.rs"),
        "// Auto-generated by `darwin-kperf-codegen`. Do not edit.\n\n",
        lib_tokens,
    )?;

    for chip in chips {
        let tokens = generate_chip_module(&unified, chip);
        let filename = format!("{}.rs", chip.def.label.to_ascii_lowercase());

        write_formatted(
            out_dir.as_ref().join(filename),
            "//! Auto-generated by `darwin-kperf-codegen`. Do not edit.\n\n",
            tokens,
        )?;
    }

    Ok(unified.len())
}

fn write_formatted(
    path: impl AsRef<Path>,
    header: &str,
    tokens: TokenStream,
) -> Result<(), Box<dyn core::error::Error>> {
    let file = syn::parse2::<syn::File>(tokens)?;
    let formatted = prettyplease::unparse(&file);
    let output = format!("{header}{formatted}");
    fs::write(path, output)?;
    Ok(())
}

fn to_pascal_case(name: &str) -> String {
    name.to_case(Case::Pascal)
}

fn build_merge_map() -> BTreeMap<&'static str, &'static str> {
    let mut map = BTreeMap::new();
    for &(variant, raw_names) in MERGES {
        for &raw_name in raw_names {
            map.insert(raw_name, variant);
        }
    }
    map
}

fn build_unified_events(chips: &[ChipDatabase]) -> Vec<UnifiedEvent> {
    let merge_map = build_merge_map();
    let mut unified: BTreeMap<String, UnifiedEvent> = BTreeMap::new();

    for chip in chips {
        for event in &chip.events {
            let variant = if let Some(&merged_variant) = merge_map.get(event.name.as_str()) {
                merged_variant.to_owned()
            } else {
                to_pascal_case(&event.name)
            };

            let entry = unified
                .entry(variant.clone())
                .or_insert_with(|| UnifiedEvent {
                    variant,
                    chips: BTreeMap::new(),
                });

            entry.chips.insert(
                chip.def.label.to_owned(),
                UnifiedChipEvent {
                    data: event.clone(),
                },
            );
        }
    }

    unified.into_values().collect()
}

fn quote_option(value: Option<impl ToTokens>) -> TokenStream {
    value.map_or_else(|| quote! { None }, |value| quote! { Some(#value) })
}

/// Target width for doc comment text (excluding the `/// ` prefix).
const DOC_WIDTH: usize = 76;

fn ensure_period(text: &str) -> String {
    if text.ends_with('.') {
        text.to_owned()
    } else {
        format!("{text}.")
    }
}

/// Wraps `text` into doc-comment lines, each prefixed with a space.
///
/// Lines are broken at word boundaries to stay within [`DOC_WIDTH`].
fn wrap_doc(text: &str) -> Vec<String> {
    let mut lines = Vec::new();
    let mut current = String::with_capacity(DOC_WIDTH);

    for word in text.split_whitespace() {
        if current.is_empty() {
            // do nothing
        } else if current.len() + 1 + word.len() > DOC_WIDTH {
            lines.push(format!(" {current}"));
            current.clear();
        } else {
            current.push(' ');
        }

        current.push_str(word);
    }

    if !current.is_empty() {
        lines.push(format!(" {current}"));
    }

    lines
}

fn doc_attrs(text: &str) -> TokenStream {
    let lines = wrap_doc(text);
    quote! { #(#[doc = #lines])* }
}

fn chip_doc_for_event(description: &str, name: &str) -> String {
    if description.is_empty() {
        format!("`{name}`.")
    } else {
        ensure_period(description)
    }
}

fn event_doc_line(event: &UnifiedEvent) -> String {
    let first_chip_event = event.chips.values().next().expect("at least one event");
    let description = &first_chip_event.data.description;
    let name = &first_chip_event.data.name;
    let is_fixed = first_chip_event.data.fixed_counter.is_some();

    if is_fixed {
        let fallback = &first_chip_event.data.fallback;
        fallback.as_ref().map_or_else(
            || "Fixed counter.".to_owned(),
            |fb| format!("Fixed counter (fallback: `{fb}`)."),
        )
    } else if description.is_empty() {
        format!("`{name}`.")
    } else {
        ensure_period(description)
    }
}

fn event_support_line(event: &UnifiedEvent, chips: &[ChipDatabase]) -> String {
    let total = chips.len();
    let present: Vec<&str> = chips
        .iter()
        .filter(|chip| event.chips.contains_key(chip.def.label))
        .map(|chip| chip.def.label)
        .collect();

    if present.len() == total {
        "All generations.".to_owned()
    } else {
        format!("{} only.", present.join(", "))
    }
}

fn generate_lib(unified: &[UnifiedEvent], chips: &[ChipDatabase]) -> TokenStream {
    let mod_names: Vec<_> = chips
        .iter()
        .map(|chip| format_ident!("{}", chip.def.label.to_ascii_lowercase()))
        .collect();

    let event_type_names: Vec<_> = chips
        .iter()
        .map(|chip| format_ident!("{}Event", chip.def.label))
        .collect();

    let mod_decls = quote! { #(mod #mod_names;)* };
    let use_decls = quote! { #(pub use #mod_names::#event_type_names;)* };

    let cpu_enum = generate_cpu_enum(chips);
    let event_info_trait = generate_event_info_trait();
    let any_event_enum = generate_any_event_enum(chips);
    let resolved_event = generate_resolved_event();
    let event_enum = generate_event_enum(unified, chips);
    let event_impl = generate_event_impl(chips);

    quote! {
        //! Hardware performance counter events for Apple Silicon.
        //!
        //! This crate is auto-generated by `darwin-kperf-codegen` from the PMC
        //! database plists in `/usr/share/kpep/`. **Do not edit by hand.**
        //!
        //! # Types
        //!
        //! - [`Event`]: chip-agnostic event enum covering M1 through M5. Use [`Event::on`] to resolve an
        //!   event for a specific [`Cpu`], which checks availability and returns the chip-specific
        //!   metadata.
        //! - [`Cpu`]: Apple Silicon chip generation, identified by the `kpep_db.name` field at runtime.
        //! - [`EventInfo`]: trait providing event metadata (name, description, counter mask, etc.),
        //!   implemented by per-chip enums ([`M1Event`], [`M2Event`], ...) and by [`ResolvedEvent`].
        //! - [`ResolvedEvent`]: an [`Event`] resolved for a specific [`Cpu`], returned by [`Event::on`].
        #![no_std]

        #![expect(
            clippy::match_same_arms,
            clippy::too_many_lines,
            clippy::unnecessary_wraps,
            clippy::decimal_literal_representation,
            clippy::unseparated_literal_suffix
        )]

        #mod_decls

        #use_decls

        #cpu_enum

        #event_info_trait

        #any_event_enum

        #resolved_event

        #event_enum

        #event_impl
    }
}

fn generate_cpu_enum(chips: &[ChipDatabase]) -> TokenStream {
    let variants = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let doc = doc_attrs(&format!("{}.", chip.marketing_name));
        quote! {
            #doc
            #label
        }
    });

    let from_db_name_arms = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let aliases = chip.def.aliases;
        if aliases.len() == 1 {
            let alias_bytes = proc_macro2::Literal::byte_string(aliases[0].as_bytes());
            quote! { #alias_bytes => Some(Self::#label) }
        } else {
            let alias_patterns: Vec<_> = aliases
                .iter()
                .map(|alias| proc_macro2::Literal::byte_string(alias.as_bytes()))
                .collect();
            quote! { #(#alias_patterns)|* => Some(Self::#label) }
        }
    });

    let marketing_name_arms = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let name = chip.marketing_name.as_str();
        quote! { Self::#label => #name }
    });

    let fixed_counters_arms = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let val = chip.fixed_counters;
        quote! { Self::#label => #val }
    });

    let config_counters_arms = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let val = chip.config_counters;
        quote! { Self::#label => #val }
    });

    let power_counters_arms = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let val = chip.power_counters;
        quote! { Self::#label => #val }
    });

    quote! {
        /// Apple Silicon chip generation, as identified by `kpep_db.name`.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        #[non_exhaustive]
        pub enum Cpu {
            #(#variants),*
        }

        impl Cpu {
            /// Matches the `name` field from a `kpep_db` to a known generation.
            ///
            /// Returns `None` for unrecognized CPU names.
            #[must_use]
            pub const fn from_db_name(name: &str) -> Option<Self> {
                // kpep_db.name values that map to each generation.
                // Multiple plist names can alias the same chip (e.g. as1=as2=as3=a16).
                match name.as_bytes() {
                    #(#from_db_name_arms,)*
                    _ => None,
                }
            }

            /// Marketing name from the PMC database (e.g. `"Apple A14/M1"`).
            #[must_use]
            pub const fn marketing_name(self) -> &'static str {
                match self {
                    #(#marketing_name_arms),*
                }
            }

            /// Bitmask of fixed counter registers.
            #[must_use]
            pub const fn fixed_counters(self) -> u32 {
                match self {
                    #(#fixed_counters_arms),*
                }
            }

            /// Bitmask of configurable counter registers.
            #[must_use]
            pub const fn config_counters(self) -> u32 {
                match self {
                    #(#config_counters_arms),*
                }
            }

            /// Bitmask of power counter registers.
            #[must_use]
            pub const fn power_counters(self) -> u32 {
                match self {
                    #(#power_counters_arms),*
                }
            }
        }
    }
}

fn generate_event_info_trait() -> TokenStream {
    quote! {
        /// Metadata for a hardware performance counter event on a specific chip.
        pub trait EventInfo {
            /// The kpep event name string (e.g. `"INST_ALL"`).
            fn name(&self) -> &'static str;

            /// The kpep event name as a NUL-terminated C string (e.g. `c"INST_ALL"`).
            fn c_name(&self) -> &'static core::ffi::CStr;

            /// Human-readable description from the PMC database.
            fn description(&self) -> &'static str;

            /// Bitmask of counters this event can be programmed on.
            fn counters_mask(&self) -> Option<u32>;

            /// Event number (selector value written to the PMC config register).
            fn number(&self) -> Option<u16>;

            /// Fixed counter index, or `None` for configurable events.
            fn fixed_counter(&self) -> Option<u8>;

            /// Fallback event name for fixed counters.
            fn fallback(&self) -> Option<&'static str>;

            /// Human-readable alias names (e.g. `"Cycles"`, `"Instructions"`).
            fn aliases(&self) -> &'static [&'static str];
        }
    }
}

fn generate_any_event_enum(chips: &[ChipDatabase]) -> TokenStream {
    let variants = chips.iter().map(|chip| {
        let label = format_ident!("{}", chip.def.label);
        let event_type = format_ident!("{}Event", chip.def.label);
        let doc = doc_attrs(&format!("Event on {}.", chip.def.label));
        quote! {
            #doc
            #label(#event_type)
        }
    });

    let delegate = |method_name: &str| -> TokenStream {
        let method = format_ident!("{}", method_name);
        let arms = chips.iter().map(|chip| {
            let label = format_ident!("{}", chip.def.label);
            quote! { Self::#label(event) => event.#method() }
        });

        quote! {
            match self {
                #(#arms),*
            }
        }
    };

    let name_impl = delegate("name");
    let c_name_impl = delegate("c_name");
    let description_impl = delegate("description");
    let counters_mask_impl = delegate("counters_mask");
    let number_impl = delegate("number");
    let fixed_counter_impl = delegate("fixed_counter");
    let fallback_impl = delegate("fallback");
    let aliases_impl = delegate("aliases");

    quote! {
        /// A chip-specific event, erasing which chip it belongs to.
        ///
        /// Each variant wraps a per-chip event enum that implements [`EventInfo`].
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        enum AnyEvent {
            #(#variants),*
        }

        impl EventInfo for AnyEvent {
            #[inline]
            fn name(&self) -> &'static str {
                #name_impl
            }

            #[inline]
            fn c_name(&self) -> &'static core::ffi::CStr {
                #c_name_impl
            }

            #[inline]
            fn description(&self) -> &'static str {
                #description_impl
            }

            #[inline]
            fn counters_mask(&self) -> Option<u32> {
                #counters_mask_impl
            }

            #[inline]
            fn number(&self) -> Option<u16> {
                #number_impl
            }

            #[inline]
            fn fixed_counter(&self) -> Option<u8> {
                #fixed_counter_impl
            }

            #[inline]
            fn fallback(&self) -> Option<&'static str> {
                #fallback_impl
            }

            #[inline]
            fn aliases(&self) -> &'static [&'static str] {
                #aliases_impl
            }
        }
    }
}

fn generate_resolved_event() -> TokenStream {
    quote! {
        /// A resolved view of an [`Event`] on a specific [`Cpu`].
        ///
        /// Returned by [`Event::on`]. Wraps a chip-specific event and forwards
        /// [`EventInfo`] to the chip-specific implementation.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub struct ResolvedEvent(AnyEvent);

        impl EventInfo for ResolvedEvent {
            #[inline]
            fn name(&self) -> &'static str {
                self.0.name()
            }

            #[inline]
            fn c_name(&self) -> &'static core::ffi::CStr {
                self.0.c_name()
            }

            #[inline]
            fn description(&self) -> &'static str {
                self.0.description()
            }

            #[inline]
            fn counters_mask(&self) -> Option<u32> {
                self.0.counters_mask()
            }

            #[inline]
            fn number(&self) -> Option<u16> {
                self.0.number()
            }

            #[inline]
            fn fixed_counter(&self) -> Option<u8> {
                self.0.fixed_counter()
            }

            #[inline]
            fn fallback(&self) -> Option<&'static str> {
                self.0.fallback()
            }

            #[inline]
            fn aliases(&self) -> &'static [&'static str] {
                self.0.aliases()
            }
        }
    }
}

fn generate_event_enum(unified: &[UnifiedEvent], chips: &[ChipDatabase]) -> TokenStream {
    let variants = unified.iter().map(|event| {
        let variant_ident = format_ident!("{}", event.variant);
        let doc = doc_attrs(&event_doc_line(event));
        let support = doc_attrs(&event_support_line(event, chips));

        quote! {
            #doc
            ///
            #support
            #variant_ident
        }
    });

    quote! {
        /// A hardware performance counter event from Apple's kpep database.
        ///
        /// Covers Apple Silicon generations M1â€“M5.
        /// Each variant maps to a named event in the PMC database; the event's
        /// availability on a specific chip is noted in the variant doc comment.
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        #[non_exhaustive]
        pub enum Event {
            #(#variants),*
        }
    }
}

fn generate_event_impl(chips: &[ChipDatabase]) -> TokenStream {
    let match_arms = chips.iter().map(|chip| {
        let cpu_label = format_ident!("{}", chip.def.label);
        let event_type = format_ident!("{}Event", chip.def.label);

        quote! {
            Cpu::#cpu_label => AnyEvent::#cpu_label(#event_type::from_event(self)?)
        }
    });

    quote! {
        impl Event {
            /// Resolves this event for the given CPU, returning its chip-specific
            /// metadata, or `None` if the event is unavailable on that chip.
            #[must_use]
            pub fn on(self, cpu: Cpu) -> Option<ResolvedEvent> {
                let any = match cpu {
                    #(#match_arms),*
                };

                Some(ResolvedEvent(any))
            }
        }
    }
}

#[expect(clippy::too_many_lines)]
fn generate_chip_module(unified: &[UnifiedEvent], chip: &ChipDatabase) -> TokenStream {
    let label = chip.def.label;
    let enum_ident = format_ident!("{}Event", label);

    let chip_events: Vec<(&UnifiedEvent, &EventData)> = unified
        .iter()
        .filter_map(|event| {
            event
                .chips
                .get(label)
                .map(|chip_event| (event, &chip_event.data))
        })
        .collect();

    let enum_variants = chip_events.iter().map(|(event, event_data)| {
        let variant_ident = format_ident!("{}", event.variant);
        let doc = doc_attrs(&chip_doc_for_event(
            &event_data.description,
            &event_data.name,
        ));
        quote! {
            #doc
            #variant_ident
        }
    });

    let from_event_arms = unified.iter().map(|event| {
        let variant = format_ident!("{}", event.variant);

        let result = if event.chips.contains_key(label) {
            quote! { Some(Self::#variant) }
        } else {
            quote! { None }
        };

        quote! { Event::#variant => #result }
    });

    let name_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let name = event_data.name.as_str();
        quote! { Self::#variant => #name }
    });

    let c_name_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let name =
            CString::new(event_data.name.as_bytes()).expect("name should not contain NUL byte");

        quote! { Self::#variant => #name }
    });

    let description_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let description = event_data.description.as_str();

        quote! { Self::#variant => #description }
    });

    let counters_mask_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let mask = quote_option(event_data.counters_mask);

        quote! { Self::#variant => #mask }
    });

    let number_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let number = quote_option(event_data.number);

        quote! { Self::#variant => #number }
    });

    let fixed_counter_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let fixed_counter = quote_option(event_data.fixed_counter);

        quote! { Self::#variant => #fixed_counter }
    });

    let fallback_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let fallback = quote_option(event_data.fallback.as_ref());

        quote! { Self::#variant => #fallback }
    });

    let aliases_arms = chip_events.iter().map(|(event, event_data)| {
        let variant = format_ident!("{}", event.variant);
        let aliases = &event_data.aliases;

        quote! { Self::#variant => &[#(#aliases),*] }
    });

    let enum_doc = doc_attrs(&format!(
        "Hardware performance counter events available on {label}."
    ));
    let from_event_doc = doc_attrs(&format!(
        "Converts a generic [`Event`] to its {label}-specific variant, returning `None` if the \
         event is unavailable on {label}."
    ));

    quote! {
        use super::{Event, EventInfo};

        #enum_doc
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        #[non_exhaustive]
        pub enum #enum_ident {
            #(#enum_variants),*
        }

        impl #enum_ident {
            #from_event_doc
            #[must_use]
            #[inline]
            pub const fn from_event(event: Event) -> Option<Self> {
                match event {
                    #(#from_event_arms),*
                }
            }
        }

        impl EventInfo for #enum_ident {
            #[inline]
            fn name(&self) -> &'static str {
                match self {
                    #(#name_arms),*
                }
            }

            #[inline]
            fn c_name(&self) -> &'static core::ffi::CStr {
                match self {
                    #(#c_name_arms),*
                }
            }

            #[inline]
            fn description(&self) -> &'static str {
                match self {
                    #(#description_arms),*
                }
            }

            #[inline]
            fn counters_mask(&self) -> Option<u32> {
                match self {
                    #(#counters_mask_arms),*
                }
            }

            #[inline]
            fn number(&self) -> Option<u16> {
                match self {
                    #(#number_arms),*
                }
            }

            #[inline]
            fn fixed_counter(&self) -> Option<u8> {
                match self {
                    #(#fixed_counter_arms),*
                }
            }

            #[inline]
            fn fallback(&self) -> Option<&'static str> {
                match self {
                    #(#fallback_arms),*
                }
            }

            #[inline]
            fn aliases(&self) -> &'static [&'static str] {
                match self {
                    #(#aliases_arms),*
                }
            }
        }
    }
}
